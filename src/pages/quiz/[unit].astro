---
import Layout from '../../layouts/Layout.astro';
import * as yaml from 'yaml';
import fs from 'fs';
import path from 'path';

export async function getStaticPaths() {
  try {
    const indexPath = path.join(process.cwd(), 'public/questions/index.yaml');
    const indexContent = fs.readFileSync(indexPath, 'utf-8');
    const indexData = yaml.parse(indexContent);

    // æ–°ã—ã„index.yamlæ§‹é€ ã«å¯¾å¿œ: questionSetsã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é…åˆ—
    return indexData.questionSets.map((questionSet: any) => ({
      params: { unit: questionSet.id }
    }));
  } catch (error) {
    console.error('Error loading question sets:', error);
    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ã®ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒªã‚¹ãƒˆ
    return [
      { params: { unit: 'binary_conversion' } },
      { params: { unit: 'copyright' } },
      { params: { unit: 'industrial' } }
    ];
  }
}

const { unit } = Astro.params;
---

<Layout title={`å•é¡Œæ¼”ç¿’ - ${unit} - ã˜ã‚‡ã†ã»ã†ã‚‰ã„ãµ`}>
  <div class="container mx-auto px-4 py-8">
    <div id="quiz-app" class="max-w-4xl mx-auto">
      <div class="flex items-center justify-center py-12">
        <div class="flex items-center space-x-2">
          <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
          <span class="text-gray-600">å•é¡Œã‚’èª­ã¿è¾¼ã¿ä¸­...</span>
        </div>
      </div>
    </div>
  </div>
</Layout>

<script define:vars={{ unit }}>
async function loadQuestionSet(setId) {
  try {
    const response = await fetch(`/questions/${setId}/questions.yaml`);
    if (!response.ok) {
      throw new Error(`Failed to load question set: ${response.status}`);
    }
    
    const yamlContent = await response.text();
    console.log('Loaded YAML for', setId, ':', yamlContent.substring(0, 200));
    
    // YAML parsing with proper indentation handling
    const lines = yamlContent.split('\n');
    const questionSet = {
      id: setId,
      title: '',
      description: '',
      icon: 'ğŸ“',
      difficulty: 'medium',
      estimatedTime: 10,
      questions: [],
      tags: [],
      category: 'general'
    };
    
    let currentQuestion = null;
    let currentOption = null;
    let inQuestions = false;
    let inTags = false;
    let inOptions = false;
    let inQuestionTags = false;
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmed = line.trim();
      const indent = line.length - line.trimStart().length;
      
      if (!trimmed || trimmed.startsWith('#')) continue;
      
      // Root level properties
      if (indent === 0 && trimmed.includes(':')) {
        const [key, value] = trimmed.split(':').map(s => s.trim());
        if (key === 'title') {
          questionSet.title = value.replace(/['"]/g, '');
        } else if (key === 'description') {
          questionSet.description = value.replace(/['"]/g, '');
        } else if (key === 'icon') {
          questionSet.icon = value.replace(/['"]/g, '');
        } else if (key === 'difficulty') {
          questionSet.difficulty = value.replace(/['"]/g, '');
        } else if (key === 'estimatedTime') {
          questionSet.estimatedTime = parseInt(value) || 10;
        } else if (key === 'category') {
          questionSet.category = value.replace(/['"]/g, '');
        } else if (key === 'questions') {
          inQuestions = true;
          inTags = false;
        } else if (key === 'tags') {
          inTags = true;
          inQuestions = false;
        }
      }
      // Tags section
      else if (inTags && indent === 2 && trimmed.startsWith('- ')) {
        questionSet.tags.push(trimmed.substring(2).trim().replace(/['"]/g, ''));
      }
      // Questions section
      else if (inQuestions && indent === 2 && trimmed.startsWith('- id:')) {
        currentQuestion = {
          id: trimmed.substring(5).trim().replace(/['"]/g, ''),
          type: 'single-choice',
          title: '',
          description: '',
          options: [],
          explanation: '',
          difficulty: 'medium',
          tags: [],
          points: 1
        };
        questionSet.questions.push(currentQuestion);
        inOptions = false;
        inQuestionTags = false;
      }
      // Question properties
      else if (currentQuestion && indent === 4 && trimmed.includes(':')) {
        const [key, ...valueParts] = trimmed.split(':');
        const value = valueParts.join(':').trim();
        
        if (key === 'type') {
          currentQuestion.type = value.replace(/['"]/g, '');
        } else if (key === 'title') {
          currentQuestion.title = value.replace(/['"]/g, '');
        } else if (key === 'description') {
          if (value === '|' || value === '>') {
            // Multi-line text starting
            currentQuestion.description = '';
            currentQuestion._isReadingDescription = true;
          } else {
            currentQuestion.description = value.replace(/['"]/g, '');
          }
        } else if (key === 'explanation') {
          if (value === '|' || value === '>') {
            // Multi-line text starting
            currentQuestion.explanation = '';
            currentQuestion._isReadingExplanation = true;
          } else {
            currentQuestion.explanation = value.replace(/['"]/g, '');
          }
        } else if (key === 'difficulty') {
          currentQuestion.difficulty = value.replace(/['"]/g, '');
        } else if (key === 'points') {
          currentQuestion.points = parseInt(value) || 1;
        } else if (key === 'hint') {
          currentQuestion.hint = value.replace(/['"]/g, '');
        } else if (key === 'answer') {
          currentQuestion.answer = value.replace(/['"]/g, '');
        } else if (key === 'downloadFile') {
          currentQuestion.downloadFile = value.replace(/['"]/g, '');
        } else if (key === 'expectedChanges') {
          currentQuestion.expectedChanges = [];
          currentQuestion._isReadingExpectedChanges = true;
          currentQuestion._currentExpectedChange = null;
        } else if (key === 'options') {
          inOptions = true;
          inQuestionTags = false;
          // Clear multi-line reading flags
          if (currentQuestion) {
            currentQuestion._isReadingDescription = false;
            currentQuestion._isReadingExplanation = false;
            currentQuestion._isReadingExpectedChanges = false;
            currentQuestion._currentExpectedChange = null;
          }
        } else if (key === 'tags') {
          inQuestionTags = true;
          inOptions = false;
          // Clear multi-line reading flags
          if (currentQuestion) {
            currentQuestion._isReadingDescription = false;
            currentQuestion._isReadingExplanation = false;
            currentQuestion._isReadingExpectedChanges = false;
            currentQuestion._currentExpectedChange = null;
          }
        }
      }
      // Expected changes properties (indent 6 or 8 for array items)
      else if (currentQuestion && currentQuestion._isReadingExpectedChanges && (indent === 6 || indent === 8) && trimmed.includes(':')) {
        const [key, ...valueParts] = trimmed.split(':');
        const value = valueParts.join(':').trim();

        if (key === '- deviceName') {
          // Start a new expected change item
          currentQuestion._currentExpectedChange = {
            deviceName: value.replace(/['"]/g, ''),
            property: '',
            expectedPattern: '',
            explanation: '',
            excludeValues: []
          };
          currentQuestion.expectedChanges.push(currentQuestion._currentExpectedChange);
        } else if (key === 'deviceName' && currentQuestion._currentExpectedChange) {
          currentQuestion._currentExpectedChange.deviceName = value.replace(/['"]/g, '');
        } else if (key === 'property' && currentQuestion._currentExpectedChange) {
          currentQuestion._currentExpectedChange.property = value.replace(/['"]/g, '');
        } else if (key === 'expectedPattern' && currentQuestion._currentExpectedChange) {
          const rawValue = value;
          const cleanedValue = value.replace(/['"]/g, '');
          console.log('YAMLè§£æ expectedPattern:', { rawValue, cleanedValue });
          currentQuestion._currentExpectedChange.expectedPattern = cleanedValue;
        } else if (key === 'explanation' && currentQuestion._currentExpectedChange) {
          currentQuestion._currentExpectedChange.explanation = value.replace(/['"]/g, '');
        } else if (key === 'excludeValues' && currentQuestion._currentExpectedChange) {
          currentQuestion._currentExpectedChange.excludeValues = [];
          currentQuestion._isReadingExcludeValues = true;
        }
      }
      // Exclude values array
      else if (currentQuestion && currentQuestion._isReadingExcludeValues && indent === 8 && trimmed.startsWith('- ')) {
        const value = trimmed.substring(2).trim().replace(/['"]/g, '');
        if (currentQuestion._currentExpectedChange) {
          currentQuestion._currentExpectedChange.excludeValues.push(value);
        }
      }
      // Multi-line content
      else if (currentQuestion && indent >= 6 && (currentQuestion._isReadingDescription || currentQuestion._isReadingExplanation)) {
        const content = line.substring(6); // Remove 6 spaces of indentation
        console.log(`[DEBUG] indent=${indent}, isReadingDescription=${currentQuestion._isReadingDescription}, content="${content}"`);
        if (currentQuestion._isReadingDescription) {
          currentQuestion.description += (currentQuestion.description ? '\n' : '') + content;
        } else if (currentQuestion._isReadingExplanation) {
          currentQuestion.explanation += (currentQuestion.explanation ? '\n' : '') + content;
        }
      }
      // Question tags
      else if (inQuestionTags && indent === 6 && trimmed.startsWith('- ')) {
        currentQuestion.tags.push(trimmed.substring(2).trim().replace(/['"]/g, ''));
      }
      // Options
      else if (inOptions && indent === 6 && trimmed.startsWith('- id:')) {
        currentOption = {
          id: trimmed.substring(5).trim().replace(/['"]/g, ''),
          text: '',
          isCorrect: false,
          explanation: ''
        };
        currentQuestion.options.push(currentOption);
      }
      // Option properties
      else if (currentOption && indent === 8 && trimmed.includes(':')) {
        const [key, value] = trimmed.split(':').map(s => s.trim());
        if (key === 'text') {
          currentOption.text = value.replace(/['"]/g, '');
        } else if (key === 'isCorrect') {
          currentOption.isCorrect = value.replace(/['"]/g, '') === 'true';
        } else if (key === 'explanation') {
          currentOption.explanation = value.replace(/['"]/g, '');
        }
      }
    }
    
    console.log('Parsed question set:', questionSet);
    return questionSet;
  } catch (error) {
    console.error(`Error loading question set ${setId}:`, error);
    return null;
  }
}

function shuffleArray(array) {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

function parseMarkdown(text) {
  if (!text) return '';

  return text
    // ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯: ```language\ncode\n``` -> <pre><code>code</code></pre>
    .replace(/```(\w+)?\n([\s\S]*?)```/g, (match, lang, code) => {
      // Split into lines first (before trim to preserve structure)
      const lines = code.split('\n');

      // Remove leading/trailing empty lines
      while (lines.length > 0 && lines[0].trim() === '') lines.shift();
      while (lines.length > 0 && lines[lines.length - 1].trim() === '') lines.pop();

      // Find minimum indentation (excluding empty lines)
      const minIndent = lines
        .filter(line => line.trim().length > 0)
        .reduce((min, line) => {
          const indent = line.match(/^\s*/)[0].length;
          return Math.min(min, indent);
        }, Infinity);

      // Remove common indentation from all lines
      const dedented = lines
        .map(line => {
          if (line.trim().length === 0) return '';
          return minIndent === Infinity ? line : line.slice(minIndent);
        })
        .join('\n');

      return `<pre style="background: #1e293b; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; overflow-x: auto; margin: 1rem 0; font-family: 'Courier New', monospace; font-size: 0.875rem; line-height: 1.5;"><code style="display: block; color: #e2e8f0 !important; background: transparent !important; margin: 0; padding: 0; white-space: pre;">${dedented}</code></pre>`;
    })
    // å¤ªå­—: **text** -> <strong>text</strong>
    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
    // æ–œä½“: *text* -> <em>text</em>
    .replace(/(?<!\*)\*(?!\*)([^*]+)\*(?!\*)/g, '<em>$1</em>')
    // ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚³ãƒ¼ãƒ‰: `code` -> <code>code</code>
    .replace(/`([^`]+)`/g, '<code style="background: #f3f4f6; padding: 0.125rem 0.25rem; border-radius: 0.25rem; font-family: monospace; color: #374151;">$1</code>')
    // æ”¹è¡Œ: <br> -> <br>
    .replace(/<br>/g, '<br>')
    // æ”¹è¡Œ: \n -> <br> (å¿…è¦ã«å¿œã˜ã¦)
    .replace(/\n/g, '<br>')
    // ãƒªãƒ³ã‚¯: [text](url) -> <a href="url">text</a>
    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer" style="color: var(--primary-color); text-decoration: underline;">$1</a>');
}

class QuizSession {
  constructor(unit) {
    this.unit = unit;
    this.questionSet = null;
    this.questions = [];
    this.currentQuestionIndex = 0;
    this.answers = {};
    this.firstAnswers = {}; // æœ€åˆã®è§£ç­”ã®ã¿ã‚’è¨˜éŒ²
    this.score = 0;
    this.startTime = new Date();
    this.isCompleted = false;
    this.showingExplanation = false;
    this.userName = '';
    this.showingNameInput = true;
    this.showingCertificate = false;
    this.shuffledOptionsCache = {}; // å„å•é¡Œã®é¸æŠè‚¢ã‚·ãƒ£ãƒƒãƒ•ãƒ«çµæœã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥

    // ãªã‚Šã™ã¾ã—é˜²æ­¢ã®ãŸã‚ã®IPã‚¢ãƒ‰ãƒ¬ã‚¹å–å¾—ã‚’é–‹å§‹
    this.cachedIpAddress = null;
    this.tryGetIPAddress();

    // æ—§å¼ã®ç«¯æœ«è­˜åˆ¥ã‚·ã‚¹ãƒ†ãƒ ã‚’ã‚¯ãƒªã‚¢ï¼ˆæ–°ã‚·ã‚¹ãƒ†ãƒ ã¸ã®ç§»è¡Œã®ãŸã‚ï¼‰
    this.clearLegacyDeviceId();

    this.init();
  }

  async init() {
    try {
      this.questionSet = await loadQuestionSet(this.unit);
      if (!this.questionSet) {
        throw new Error('Question set not found');
      }
      
      this.questions = shuffleArray(this.questionSet.questions);
      this.render();
    } catch (error) {
      console.error('Error loading question set:', error);
      this.renderError();
    }
  }

  render() {
    const container = document.getElementById('quiz-app');
    if (!container) return;

    if (this.showingNameInput) {
      this.renderNameInput();
      return;
    }

    if (this.showingCertificate) {
      this.renderCertificate();
      return;
    }

    if (this.isCompleted) {
      this.renderResult();
      return;
    }

    if (this.showingExplanation) {
      this.renderExplanation();
      return;
    }

    const currentQuestion = this.questions[this.currentQuestionIndex];
    const timeElapsed = Math.floor((new Date() - this.startTime) / 1000);
    const correctAnswers = Object.keys(this.firstAnswers).filter(questionId => {
      const question = this.questions.find(q => q.id === questionId);
      return this.isAnswerCorrect(question, this.firstAnswers[questionId]);
    }).length;

    container.innerHTML = `
      <div class="space-y-6">
        <!-- Progress Bar -->
        <div class="card" style="margin-bottom: 2rem;">
          <div style="margin-bottom: 1.5rem;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
              <span style="font-size: 0.875rem; font-weight: 500; color: var(--text-primary);">é€²æ—</span>
              <span style="font-size: 0.875rem; color: var(--text-secondary);">
                ${this.currentQuestionIndex + 1} / ${this.questions.length}
              </span>
            </div>
            <div style="width: 100%; background: var(--border); border-radius: var(--radius-md); height: 8px;">
              <div 
                style="background: linear-gradient(90deg, var(--primary-color), var(--secondary-color)); height: 8px; border-radius: var(--radius-md); transition: all 0.3s ease; width: ${((this.currentQuestionIndex + 1) / this.questions.length) * 100}%;"
              ></div>
            </div>
          </div>
          
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem; text-align: center;">
            <div style="background: var(--surface); border-radius: var(--radius-md); padding: 1rem;">
              <div style="font-size: 1.5rem; font-weight: 700; color: var(--primary-color);">${this.currentQuestionIndex + 1}</div>
              <div style="font-size: 0.75rem; color: var(--primary-color); font-weight: 500;">è§£ç­”æ¸ˆã¿</div>
            </div>
            <div style="background: var(--surface); border-radius: var(--radius-md); padding: 1rem;">
              <div style="font-size: 1.5rem; font-weight: 700; color: var(--secondary-color);">${correctAnswers}</div>
              <div style="font-size: 0.75rem; color: var(--secondary-color); font-weight: 500;">æ­£è§£</div>
            </div>
            <div style="background: var(--surface); border-radius: var(--radius-md); padding: 1rem;">
              <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-color);">
                ${this.currentQuestionIndex > 0 ? Math.round((correctAnswers / this.currentQuestionIndex) * 100) : 0}%
              </div>
              <div style="font-size: 0.75rem; color: var(--accent-color); font-weight: 500;">æ­£è§£ç‡</div>
            </div>
            <div style="background: var(--surface); border-radius: var(--radius-md); padding: 1rem;">
              <div style="font-size: 1.5rem; font-weight: 700; color: var(--primary-color);">
                ${Math.floor(timeElapsed / 60)}:${(timeElapsed % 60).toString().padStart(2, '0')}
              </div>
              <div style="font-size: 0.75rem; color: var(--primary-color); font-weight: 500;">çµŒéæ™‚é–“</div>
            </div>
          </div>
        </div>

        <!-- Question Card -->
        <div class="card" style="overflow: hidden; margin-bottom: 2rem;">
          <!-- Header -->
          <div style="background: linear-gradient(135deg, var(--primary-color), var(--secondary-color)); padding: 2rem; color: white;">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem;">
              <div style="display: flex; align-items: center; gap: 0.75rem;">
                <span style="font-size: 1.5rem; font-weight: 700;">å•é¡Œ ${this.currentQuestionIndex + 1}</span>
                <span style="opacity: 0.8;">/ ${this.questions.length}</span>
              </div>
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <span style="background: rgba(255,255,255,0.2); padding: 0.25rem 0.75rem; border-radius: var(--radius-md); font-size: 0.875rem; font-weight: 500;">
                  ${this.getDifficultyText(currentQuestion.difficulty)}
                </span>
                <span style="background: rgba(255,255,255,0.2); padding: 0.25rem 0.75rem; border-radius: var(--radius-md); font-size: 0.875rem; font-weight: 500;">
                  ${currentQuestion.points}ç‚¹
                </span>
              </div>
            </div>
          </div>

          <!-- Question Content -->
          <div style="padding: 2rem;">
            <h3 style="font-size: 1.25rem; font-weight: 600; color: var(--text-primary); margin-bottom: 1rem;">
              ${parseMarkdown(currentQuestion.title)}
            </h3>
            
            <div style="color: var(--text-secondary); margin-bottom: 2rem; line-height: 1.6;">
              ${parseMarkdown(currentQuestion.description)}
            </div>

            ${currentQuestion.type === 'text-input' ? `
              <!-- Text Input for Code Trace Questions -->
              <div style="margin-bottom: 2rem;">
                <label style="display: block; font-weight: 500; color: var(--text-primary); margin-bottom: 0.5rem;">
                  è§£ç­”ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š
                </label>
                <input
                  type="text"
                  id="text-input-answer"
                  data-question-id="${currentQuestion.id}"
                  value="${this.answers[currentQuestion.id] || ''}"
                  placeholder="å‡ºåŠ›çµæœã‚’å…¥åŠ›"
                  style="
                    width: 100%;
                    padding: 0.75rem;
                    border: 2px solid var(--border);
                    border-radius: var(--radius-md);
                    font-size: 1rem;
                    transition: all 0.2s ease;
                    outline: none;
                  "
                  onfocus="this.style.borderColor='var(--primary-color)'"
                  onblur="this.style.borderColor='var(--border)'"
                />
                <p style="font-size: 0.875rem; color: var(--text-muted); margin-top: 0.5rem;">
                  â€» åŠè§’ãƒ»å…¨è§’ã€å¤§æ–‡å­—ãƒ»å°æ–‡å­—ã‚’åŒºåˆ¥ã—ã¾ã™ã€‚æ­£ç¢ºã«å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚
                </p>
              </div>
            ` : currentQuestion.type === 'file-analysis' ? `
              <!-- File Operations Section -->
              <div style="margin-bottom: 2rem;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                  <button
                    id="download-problem-file"
                    class="btn btn-primary"
                    style="display: flex; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.75rem;"
                    data-file-url="${currentQuestion.downloadFile || ''}"
                  >
                    <svg style="width: 20px; height: 20px;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                    </svg>
                    èª²é¡Œãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                  </button>

                  <div style="position: relative;">
                    <input
                      type="file"
                      id="upload-solution-file"
                      accept=".json"
                      style="position: absolute; opacity: 0; width: 100%; height: 100%; cursor: pointer;"
                    />
                    <button
                      class="btn btn-secondary"
                      style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.75rem; pointer-events: none;"
                    >
                      <svg style="width: 20px; height: 20px;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                      </svg>
                      è§£ç­”ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
                    </button>
                  </div>
                </div>

                <div id="file-status" style="display: none; margin-bottom: 1rem;">
                  <div style="padding: 1rem; border-radius: var(--radius-md); border: 1px solid #e5e7eb; background: #f9fafb;">
                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                      <span id="file-status-icon">ğŸ“</span>
                      <span id="file-status-text" style="font-weight: 500;">ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¾ã—ãŸ</span>
                    </div>
                    <div id="file-name" style="font-size: 0.875rem; color: var(--text-secondary);"></div>
                  </div>
                </div>

                <div id="analysis-result" style="display: none; margin-bottom: 1rem;">
                  <div style="padding: 1rem; border-radius: var(--radius-md); border: 1px solid; background: var(--surface);">
                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                      <span id="result-icon">ğŸ”</span>
                      <span id="result-title" style="font-weight: 600;">è§£æçµæœ</span>
                    </div>
                    <div id="result-message" style="line-height: 1.5;"></div>
                  </div>
                </div>
              </div>
            ` : `
              <!-- Options -->
              <div style="margin-bottom: 2rem;">
                ${this.getShuffledOptions(currentQuestion).map((option, index) => `
                <button
                  class="option-button"
                  data-question-id="${currentQuestion.id}"
                  data-option-id="${option.id}"
                  style="
                    width: 100%; 
                    padding: 1rem; 
                    margin-bottom: 0.75rem;
                    border-radius: var(--radius-md); 
                    border: 2px solid ${this.isOptionSelected(currentQuestion.id, option.id) ? 'var(--primary-color)' : 'var(--border)'}; 
                    text-align: left; 
                    transition: all 0.2s ease;
                    background: ${this.isOptionSelected(currentQuestion.id, option.id) ? 'var(--surface)' : 'white'};
                    color: ${this.isOptionSelected(currentQuestion.id, option.id) ? 'var(--primary-color)' : 'var(--text-primary)'};
                    cursor: pointer;
                  "
                >
                  <div style="display: flex; align-items: center;">
                    <div style="margin-right: 0.75rem;">
                      <div style="
                        width: 20px; 
                        height: 20px; 
                        border-radius: ${currentQuestion.type === 'multiple-choice' ? 'var(--radius-sm)' : '50%'}; 
                        border: 2px solid ${this.isOptionSelected(currentQuestion.id, option.id) ? 'var(--primary-color)' : 'var(--border)'};
                        background: ${this.isOptionSelected(currentQuestion.id, option.id) ? 'var(--primary-color)' : 'white'};
                        display: flex;
                        align-items: center;
                        justify-content: center;
                      ">
                        ${this.isOptionSelected(currentQuestion.id, option.id) ? (
                          currentQuestion.type === 'multiple-choice' 
                            ? '<span style="color: white; font-size: 12px;">âœ“</span>'
                            : '<div style="width: 8px; height: 8px; background: white; border-radius: 50%;"></div>'
                        ) : ''}
                      </div>
                    </div>
                    <span style="flex: 1;">${parseMarkdown(option.text)}</span>
                  </div>
                </button>
              `).join('')}
              </div>
            `}

            <!-- Hint -->
            ${currentQuestion.hint ? `
              <div style="margin-bottom: 2rem;">
                <button
                  id="hint-button"
                  style="
                    display: flex; 
                    align-items: center; 
                    color: var(--accent-color); 
                    background: none; 
                    border: none; 
                    cursor: pointer; 
                    transition: all 0.3s ease;
                    font-size: 0.875rem;
                    font-weight: 500;
                  "
                >
                  <svg style="width: 20px; height: 20px; margin-right: 8px;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
                  </svg>
                  ãƒ’ãƒ³ãƒˆ
                </button>
                <div 
                  id="hint-content"
                  style="
                    margin-top: 0.5rem; 
                    background: #fef3c7; 
                    border: 1px solid #f59e0b; 
                    border-radius: var(--radius-md); 
                    padding: 0.75rem;
                    display: none;
                  "
                >
                  <p style="color: #92400e; font-size: 0.875rem; margin: 0;">${parseMarkdown(currentQuestion.hint)}</p>
                </div>
              </div>
            ` : ''}

            <!-- Navigation -->
            <div style="display: flex; justify-content: space-between; align-items: center;">
              ${currentQuestion.type === 'multiple-choice' ? `
                <div style="font-size: 0.875rem; color: var(--text-muted);">è¤‡æ•°é¸æŠå¯èƒ½</div>
              ` : '<div></div>'}

              <button
                id="next-button"
                ${!this.isQuestionAnswered(currentQuestion.id) ? 'disabled' : ''}
                class="btn ${this.isQuestionAnswered(currentQuestion.id) ? 'btn-primary' : 'btn-secondary'}"
                style="display: flex; align-items: center; ${!this.isQuestionAnswered(currentQuestion.id) ? 'opacity: 0.5; cursor: not-allowed;' : ''}"
              >
                ${this.currentQuestionIndex === this.questions.length - 1 ? 'çµæœã‚’è¦‹ã‚‹' : 'æ¬¡ã®å•é¡Œ'}
                <svg style="width: 20px; height: 20px; margin-left: 8px;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                </svg>
              </button>
            </div>
          </div>
        </div>
      </div>
    `;
    
    // Add event listeners after DOM is updated
    setTimeout(() => {
      // File operation events for file-analysis questions
      if (currentQuestion.type === 'file-analysis') {
        this.setupFileOperationEvents(currentQuestion);
      }

      // Text input for text-input questions
      if (currentQuestion.type === 'text-input') {
        const textInput = document.getElementById('text-input-answer');
        if (textInput) {
          textInput.addEventListener('input', (e) => {
            const questionId = e.target.getAttribute('data-question-id');
            const value = e.target.value;
            this.answers[questionId] = value;
            // Update next button state without re-rendering entire view
            const nextButton = document.getElementById('next-button');
            if (nextButton) {
              const isAnswered = value.trim().length > 0;
              nextButton.disabled = !isAnswered;
              nextButton.className = isAnswered ? 'btn btn-primary' : 'btn btn-secondary';
              nextButton.style.opacity = isAnswered ? '1' : '0.5';
              nextButton.style.cursor = isAnswered ? 'pointer' : 'not-allowed';
            }
          });

          // Focus on input field
          textInput.focus();
        }
      }

      // Option buttons
      const optionButtons = document.querySelectorAll('.option-button');
      optionButtons.forEach(button => {
        button.addEventListener('click', () => {
          const questionId = button.getAttribute('data-question-id');
          const optionId = button.getAttribute('data-option-id');
          this.selectOption(questionId, optionId);
        });
      });
      
      // Hint button
      const hintButton = document.getElementById('hint-button');
      const hintContent = document.getElementById('hint-content');
      
      if (hintButton && hintContent) {
        hintButton.addEventListener('click', () => {
          if (hintContent.style.display === 'none') {
            hintContent.style.display = 'block';
          } else {
            hintContent.style.display = 'none';
          }
        });
        
        // Add hover effects
        hintButton.addEventListener('mouseenter', () => {
          hintButton.style.opacity = '0.8';
        });
        
        hintButton.addEventListener('mouseleave', () => {
          hintButton.style.opacity = '1';
        });
      }
      
      // Navigation button - Clone to remove old event listeners
      const nextButton = document.getElementById('next-button');

      if (nextButton) {
        const newNextButton = nextButton.cloneNode(true);
        nextButton.parentNode.replaceChild(newNextButton, nextButton);
        newNextButton.addEventListener('click', () => this.nextQuestion());
      }
    }, 0);
  }

  renderNameInput() {
    const container = document.getElementById('quiz-app');
    if (!container) return;

    // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰ä¿å­˜ã•ã‚ŒãŸåå‰ã‚’å–å¾—
    const savedName = localStorage.getItem('quizStudentName');
    
    container.innerHTML = `
      <div style="max-width: 600px; margin: 0 auto; text-align: center;">
        <div class="card" style="padding: 3rem;">
          <div style="margin-bottom: 2rem;">
            <div style="font-size: 3rem; margin-bottom: 1rem;">
              ${this.questionSet?.icon || 'ğŸ“'}
            </div>
            <h2 style="font-size: 1.75rem; font-weight: 700; color: var(--text-primary); margin-bottom: 0.5rem; line-height: 1.2; hyphens: auto; word-break: break-word;">
              <span style="display: inline-block; max-width: 100%; font-size: clamp(1.25rem, 4vw, 1.75rem);">
                ${this.questionSet?.title || this.unit} å•é¡Œæ¼”ç¿’
              </span>
            </h2>
            <p style="color: var(--text-secondary); margin-bottom: 2rem;">
              ${this.questionSet?.description || ''}
            </p>
            <div style="display: flex; justify-content: center; gap: 2rem; margin-bottom: 2rem; font-size: 0.875rem; color: var(--text-muted);">
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <svg style="width: 16px; height: 16px;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                ç´„${this.questionSet?.estimatedTime || 0}åˆ†
              </div>
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <svg style="width: 16px; height: 16px;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
                å…¨${this.questions?.length || 0}å•
              </div>
            </div>
          </div>

          <div style="border-top: 1px solid var(--border); padding-top: 2rem;">
            ${savedName && savedName.trim() ? `
              <!-- åå‰ç¢ºèªç”»é¢ -->
              <h3 style="font-size: 1.25rem; font-weight: 600; color: var(--text-primary); margin-bottom: 1rem;">
                ğŸ¯ å•é¡Œæ¼”ç¿’é–‹å§‹ï¼
              </h3>
              <p style="color: var(--text-secondary); margin-bottom: 2rem; font-size: 1rem;">
                ${savedName}ã•ã‚“ã€å•é¡Œæ¼”ç¿’ã‚’é–‹å§‹ã—ã¾ã™ã‹ï¼Ÿ
              </p>
              
              <div style="display: flex; flex-direction: column; gap: 1rem; align-items: center;">
                <button
                  id="start-quiz-button"
                  class="btn btn-primary"
                  style="padding: 0.75rem 2rem; font-size: 1rem;"
                >
                  ã¯ã„ã€é–‹å§‹ã™ã‚‹
                </button>
                
                <button
                  id="change-name-button"
                  class="btn btn-secondary"
                  style="font-size: 0.875rem;"
                >
                  åˆ¥ã®åå‰ã§é–‹å§‹
                </button>
                
                <button
                  onclick="window.location.href='/quiz'"
                  class="btn btn-secondary"
                  style="font-size: 0.875rem;"
                >
                  ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹
                </button>
              </div>
            ` : `
              <!-- åå‰å…¥åŠ›ç”»é¢ -->
              <h3 style="font-size: 1.25rem; font-weight: 600; color: var(--text-primary); margin-bottom: 1rem;">
                ãŠåå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„
              </h3>
              <p style="color: var(--text-secondary); margin-bottom: 2rem; font-size: 0.875rem;">
                100%ã®æ­£ç­”ç‡ã§å…¨å•æ­£è§£ã™ã‚‹ã¨ã€ä¿®äº†è¨¼ãŒç™ºè¡Œã•ã‚Œã¾ã™<br>
                â€»å…¥åŠ›ã•ã‚ŒãŸæ°åã¯ã€ä¿®äº†è¨¼ç™ºè¡Œã«ã®ã¿ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
              </p>
              
              <div style="margin-bottom: 2rem;">
                <input 
                  type="text" 
                  id="user-name-input"
                  placeholder="å±±ç”°å¤ªéƒ"
                  style="
                    width: 100%; 
                    max-width: 300px;
                    padding: 0.75rem 1rem; 
                    border: 2px solid var(--border); 
                    border-radius: var(--radius-md); 
                    font-size: 1rem;
                    text-align: center;
                    transition: border-color 0.2s ease;
                  "
                  maxlength="20"
                />
              </div>

              <div style="display: flex; flex-direction: column; gap: 1rem; align-items: center;">
                <button
                  id="start-quiz-button"
                  class="btn btn-primary"
                  style="padding: 0.75rem 2rem; font-size: 1rem;"
                  disabled
                >
                  å•é¡Œæ¼”ç¿’ã‚’é–‹å§‹
                </button>
                
                <button
                  onclick="window.location.href='/quiz'"
                  class="btn btn-secondary"
                  style="font-size: 0.875rem;"
                >
                  ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹
                </button>
              </div>
            `}
          </div>
        </div>
      </div>
    `;

    // Add event listeners
    setTimeout(() => {
      const nameInput = document.getElementById('user-name-input');
      const startButton = document.getElementById('start-quiz-button');
      const changeNameButton = document.getElementById('change-name-button');
      
      // ä¿å­˜ã•ã‚ŒãŸåå‰ãŒã‚ã‚‹å ´åˆã®å‡¦ç†
      const savedName = localStorage.getItem('quizStudentName');
      if (savedName && savedName.trim()) {
        // åå‰ãŒä¿å­˜ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ç›´æ¥é–‹å§‹å¯èƒ½
        if (startButton) {
          startButton.addEventListener('click', () => {
            this.userName = savedName;
            this.startQuiz();
          });
        }
        
        // åå‰å¤‰æ›´ãƒœã‚¿ãƒ³ã®å‡¦ç†
        if (changeNameButton) {
          changeNameButton.addEventListener('click', () => {
            localStorage.removeItem('quizStudentName');
            this.renderNameInput(); // ç”»é¢ã‚’å†æç”»
          });
        }
      } else {
        // åå‰å…¥åŠ›ãŒå¿…è¦ãªå ´åˆã®å‡¦ç†
        if (nameInput && startButton) {
          const validateInput = () => {
            const name = nameInput.value.trim();
            startButton.disabled = name.length === 0;
            startButton.style.opacity = name.length === 0 ? '0.5' : '1';
          };
          
          nameInput.addEventListener('input', validateInput);
          nameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && nameInput.value.trim()) {
              this.startQuiz();
            }
          });
          
          startButton.addEventListener('click', () => this.startQuiz());
          nameInput.focus();
        }
      }
    }, 0);
  }

  renderExplanation() {
    const container = document.getElementById('quiz-app');
    if (!container) return;

    const currentQuestion = this.questions[this.currentQuestionIndex];
    const userAnswer = this.answers[currentQuestion.id];
    const isCorrect = this.isAnswerCorrect(currentQuestion, userAnswer);
    const timeElapsed = Math.floor((new Date() - this.startTime) / 1000);
    const correctAnswers = Object.keys(this.firstAnswers).filter(questionId => {
      const question = this.questions.find(q => q.id === questionId);
      return this.isAnswerCorrect(question, this.firstAnswers[questionId]);
    }).length;

    container.innerHTML = `
      <div class="space-y-6">
        <!-- Progress Bar -->
        <div class="card" style="margin-bottom: 2rem;">
          <div style="margin-bottom: 1.5rem;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
              <span style="font-size: 0.875rem; font-weight: 500; color: var(--text-primary);">é€²æ—</span>
              <span style="font-size: 0.875rem; color: var(--text-secondary);">
                ${this.currentQuestionIndex + 1} / ${this.questions.length}
              </span>
            </div>
            <div style="width: 100%; background: var(--border); border-radius: var(--radius-md); height: 8px;">
              <div 
                style="background: linear-gradient(90deg, var(--primary-color), var(--secondary-color)); height: 8px; border-radius: var(--radius-md); transition: all 0.3s ease; width: ${((this.currentQuestionIndex + 1) / this.questions.length) * 100}%;"
              ></div>
            </div>
          </div>
          
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem; text-align: center;">
            <div style="background: var(--surface); border-radius: var(--radius-md); padding: 1rem;">
              <div style="font-size: 1.5rem; font-weight: 700; color: var(--primary-color);">${this.currentQuestionIndex + 1}</div>
              <div style="font-size: 0.75rem; color: var(--primary-color); font-weight: 500;">è§£ç­”æ¸ˆã¿</div>
            </div>
            <div style="background: var(--surface); border-radius: var(--radius-md); padding: 1rem;">
              <div style="font-size: 1.5rem; font-weight: 700; color: var(--secondary-color);">${correctAnswers}</div>
              <div style="font-size: 0.75rem; color: var(--secondary-color); font-weight: 500;">æ­£è§£</div>
            </div>
            <div style="background: var(--surface); border-radius: var(--radius-md); padding: 1rem;">
              <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-color);">
                ${Math.round((correctAnswers / (this.currentQuestionIndex + 1)) * 100)}%
              </div>
              <div style="font-size: 0.75rem; color: var(--accent-color); font-weight: 500;">æ­£è§£ç‡</div>
            </div>
            <div style="background: var(--surface); border-radius: var(--radius-md); padding: 1rem;">
              <div style="font-size: 1.5rem; font-weight: 700; color: var(--primary-color);">
                ${Math.floor(timeElapsed / 60)}:${(timeElapsed % 60).toString().padStart(2, '0')}
              </div>
              <div style="font-size: 0.75rem; color: var(--primary-color); font-weight: 500;">çµŒéæ™‚é–“</div>
            </div>
          </div>
        </div>

        <!-- Result Card -->
        <div class="card" style="overflow: hidden; margin-bottom: 2rem;">
          <!-- Header -->
          <div style="background: linear-gradient(135deg, ${isCorrect ? '#10b981, #059669' : '#ef4444, #dc2626'}); padding: 2rem; color: white;">
            <div style="text-align: center;">
              <div style="font-size: 3rem; margin-bottom: 1rem;">
                ${isCorrect ? 'ğŸ‰' : 'ğŸ“š'}
              </div>
              <h2 style="font-size: 1.5rem; font-weight: 700; margin-bottom: 0.5rem;">
                ${isCorrect ? 'æ­£è§£ã§ã™ï¼' : 'ä¸æ­£è§£ã§ã™'}
              </h2>
              <p style="opacity: 0.9;">
                å•é¡Œ ${this.currentQuestionIndex + 1}: ${parseMarkdown(currentQuestion.title)}
              </p>
            </div>
          </div>

          <!-- Content -->
          <div style="padding: 2rem;">
            <div style="margin-bottom: 2rem;">
              <h3 style="font-size: 1.125rem; font-weight: 600; color: var(--text-primary); margin-bottom: 1rem;">å•é¡Œæ–‡</h3>
              <div style="color: var(--text-secondary); line-height: 1.6; margin-bottom: 1.5rem;">
                ${parseMarkdown(currentQuestion.description)}
              </div>
            </div>

            <!-- Answer Options -->
            <div style="margin-bottom: 2rem;">
              <h3 style="font-size: 1.125rem; font-weight: 600; color: var(--text-primary); margin-bottom: 1rem;">ã‚ãªãŸã®è§£ç­”</h3>
              <div style="space-y: 0.75rem;">
                ${currentQuestion.type === 'text-input' ? `
                  <!-- Text Input Answer Display -->
                  <div style="
                    border: 2px solid ${isCorrect ? '#10b981' : '#ef4444'};
                    border-radius: var(--radius-md);
                    padding: 1rem;
                    margin-bottom: 0.75rem;
                    background: ${isCorrect ? '#f0fdf4' : '#fef2f2'};
                    color: ${isCorrect ? '#065f46' : '#991b1b'};
                  ">
                    <div style="display: flex; align-items: flex-start; margin-bottom: 0.5rem;">
                      <div style="margin-right: 0.75rem; margin-top: 0.125rem;">
                        <div style="
                          width: 24px;
                          height: 24px;
                          border-radius: 50%;
                          border: 2px solid ${isCorrect ? '#10b981' : '#ef4444'};
                          background: ${isCorrect ? '#10b981' : '#ef4444'};
                          display: flex;
                          align-items: center;
                          justify-content: center;
                          font-weight: bold;
                          color: white;
                        ">
                          ${isCorrect ? 'âœ“' : 'âœ—'}
                        </div>
                      </div>
                      <div style="flex: 1;">
                        <div style="font-weight: 500; margin-bottom: 0.5rem;">
                          ã‚ãªãŸã®è§£ç­”: <code style="background: rgba(0,0,0,0.1); padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-family: monospace;">${userAnswer}</code>
                        </div>
                        ${!isCorrect ? `
                          <div style="font-weight: 500; margin-bottom: 0.5rem; color: #065f46;">
                            æ­£è§£: <code style="background: rgba(16, 185, 129, 0.2); padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-family: monospace;">${currentQuestion.answer}</code>
                          </div>
                        ` : ''}
                      </div>
                    </div>
                  </div>
                ` : this.getShuffledOptions(currentQuestion).map((option, index) => {
                  const isUserSelected = this.isOptionSelected(currentQuestion.id, option.id);
                  const isCorrectOption = option.isCorrect;

                  // ä¸æ­£è§£æ™‚ã«ã‚‚æ­£è§£ã‚’è¡¨ç¤ºã™ã‚‹å•é¡Œæ¼”ç¿’ã®ãƒªã‚¹ãƒˆ
                  const showAnswerWhenWrong = [
                    'sports_festival_smartphone',
                    'binary_conversion',
                    'hex_conversion',
                    'image_digitization',
                    'copyright',
                    'industrial',
                    'portrait',
                    'moraru'
                  ].includes(this.questionSet.id);

                  if (!showAnswerWhenWrong && (!isUserSelected || isCorrectOption)) {
                    return '';
                  }

                  // ä¸æ­£è§£æ™‚ã«æ­£è§£è¡¨ç¤ºã™ã‚‹å ´åˆã§é¸æŠã—ã¦ã„ãªã„é¸æŠè‚¢ã¯ã‚¹ã‚­ãƒƒãƒ—
                  if (showAnswerWhenWrong && !isUserSelected && !isCorrectOption) {
                    return '';
                  }

                  // æ­£è§£ã®é¸æŠè‚¢ã¨ä¸æ­£è§£ã®é¸æŠè‚¢ã§è¡¨ç¤ºã‚’åˆ†ã‘ã‚‹
                  const borderColor = isCorrectOption ? '#10b981' : '#ef4444';
                  const bgColor = isCorrectOption ? '#f0fdf4' : '#fef2f2';
                  const textColor = isCorrectOption ? '#065f46' : '#991b1b';
                  const iconBg = isCorrectOption ? '#10b981' : '#ef4444';
                  const icon = isCorrectOption ? 'âœ“' : 'âœ—';
                  const labelText = isCorrectOption ? 'ã“ã‚ŒãŒæ­£è§£ï¼š' : 'ãªãœé–“é•ã„ã‹ï¼š';

                  return `
                    <div style="
                      border: 2px solid ${borderColor};
                      border-radius: var(--radius-md);
                      padding: 1rem;
                      margin-bottom: 0.75rem;
                      background: ${bgColor};
                      color: ${textColor};
                    ">
                      <div style="display: flex; align-items: flex-start; margin-bottom: 0.5rem;">
                        <div style="margin-right: 0.75rem; margin-top: 0.125rem;">
                          <div style="
                            width: 24px;
                            height: 24px;
                            border-radius: 50%;
                            border: 2px solid ${borderColor};
                            background: ${iconBg};
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-weight: bold;
                            color: white;
                          ">
                            ${icon}
                          </div>
                        </div>
                        <div style="flex: 1;">
                          <div style="font-weight: 500; margin-bottom: 0.5rem;">
                            ${parseMarkdown(option.text)}
                          </div>
                          ${option.explanation ? `
                            <div style="font-size: 0.875rem; opacity: 0.8; line-height: 1.5;">
                              <strong>${labelText}</strong> ${parseMarkdown(option.explanation)}
                            </div>
                          ` : ''}
                        </div>
                      </div>
                    </div>
                  `;
                }).join('')}
                ${isCorrect ? `
                  <div style="
                    border: 2px solid #10b981;
                    border-radius: var(--radius-md);
                    padding: 1rem;
                    background: #f0fdf4;
                    color: #065f46;
                    text-align: center;
                    font-weight: 500;
                  ">
                    âœ“ æ­£è§£ã§ã™ï¼ã‚ˆãã§ãã¾ã—ãŸã€‚
                  </div>
                ` : ''}
              </div>
            </div>


            <!-- Navigation -->
            <div style="display: flex; justify-content: center; gap: 1rem;">
              <button
                id="continue-button"
                class="btn btn-primary"
                style="display: flex; align-items: center; padding: 0.75rem 2rem;"
              >
                ${this.currentQuestionIndex === this.questions.length - 1 ? 'çµæœã‚’è¦‹ã‚‹' : 'æ¬¡ã®å•é¡Œã¸'}
                <svg style="width: 20px; height: 20px; margin-left: 8px;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                </svg>
              </button>
            </div>
          </div>
        </div>
      </div>
    `;

    // Add event listener - Clone to remove old event listeners
    setTimeout(() => {
      const continueButton = document.getElementById('continue-button');
      if (continueButton) {
        const newContinueButton = continueButton.cloneNode(true);
        continueButton.parentNode.replaceChild(newContinueButton, continueButton);
        newContinueButton.addEventListener('click', () => this.continueAfterExplanation());
      }
    }, 0);
  }

  startQuiz() {
    // åå‰ãŒæ—¢ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆï¼ˆä¿å­˜ã•ã‚ŒãŸåå‰ã‚’ä½¿ç”¨ï¼‰
    if (this.userName && this.userName.trim()) {
      this.showingNameInput = false;
      this.startTime = new Date(); // Reset start time
      this.render();
      return;
    }
    
    // åå‰å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‹ã‚‰å–å¾—
    const nameInput = document.getElementById('user-name-input');
    if (nameInput) {
      this.userName = nameInput.value.trim();
      if (this.userName) {
        // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«åå‰ã‚’ä¿å­˜
        localStorage.setItem('quizStudentName', this.userName);
        console.log('Name saved to localStorage:', this.userName);
        
        this.showingNameInput = false;
        this.startTime = new Date(); // Reset start time
        this.render();
      }
    }
  }

  renderResult() {
    const container = document.getElementById('quiz-app');
    if (!container) return;

    const endTime = new Date();
    const timeSpent = Math.floor((endTime - this.startTime) / 1000);
    const correctAnswers = Object.keys(this.firstAnswers).filter(questionId => {
      const question = this.questions.find(q => q.id === questionId);
      return this.isAnswerCorrect(question, this.firstAnswers[questionId]);
    }).length;
    const percentage = Math.round((correctAnswers / this.questions.length) * 100);

    // 100%é”æˆæ™‚ã¯ä¿®äº†è¨¼ç”»é¢ã«é·ç§»
    if (percentage === 100) {
      this.showingCertificate = true;
      this.render();
      return;
    }

    container.innerHTML = `
      <div style="max-width: 800px; margin: 0 auto;">
        <div style="text-align: center; margin-bottom: 2rem;">
          <h2 style="font-size: 2rem; font-weight: 700; color: var(--text-primary); margin-bottom: 0.5rem;">å•é¡Œæ¼”ç¿’å®Œäº†ï¼</h2>
          <p style="color: var(--text-secondary);">ãŠç–²ã‚Œæ§˜ã§ã—ãŸã€‚çµæœã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚</p>
        </div>

        <div class="card" style="overflow: hidden; margin-bottom: 2rem;">
          <div style="background: linear-gradient(135deg, var(--primary-color), var(--secondary-color)); padding: 2rem; color: white;">
            <div style="text-align: center;">
              <div style="
                font-size: 3rem; 
                font-weight: 700; 
                margin-bottom: 0.5rem; 
                background: rgba(255,255,255,0.2); 
                border-radius: 50%; 
                width: 96px; 
                height: 96px; 
                display: flex; 
                align-items: center; 
                justify-content: center; 
                margin: 0 auto 1rem auto;
              ">
                <span style="color: white;">${this.getScoreGrade(percentage)}</span>
              </div>
              <div style="font-size: 1.5rem; font-weight: 700; margin-bottom: 0.25rem;">${percentage}%</div>
              <div style="opacity: 0.9;">${correctAnswers} / ${this.questions.length} å•æ­£è§£</div>
            </div>
          </div>
          
          <div style="padding: 2rem;">
            <div style="text-align: center; margin-bottom: 2rem;">
              <p style="font-size: 1.125rem; color: var(--text-primary);">${this.getScoreMessage(percentage)}</p>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem; margin-bottom: 2rem; text-align: center;">
              <div style="background: var(--surface); border-radius: var(--radius-md); padding: 1rem;">
                <div style="font-size: 1.5rem; font-weight: 700; color: var(--primary-color);">${this.questions.length}</div>
                <div style="font-size: 0.875rem; color: var(--primary-color); font-weight: 500;">ç·å•é¡Œæ•°</div>
              </div>
              <div style="background: var(--surface); border-radius: var(--radius-md); padding: 1rem;">
                <div style="font-size: 1.5rem; font-weight: 700; color: var(--secondary-color);">${correctAnswers}</div>
                <div style="font-size: 0.875rem; color: var(--secondary-color); font-weight: 500;">æ­£è§£æ•°</div>
              </div>
              <div style="background: var(--surface); border-radius: var(--radius-md); padding: 1rem;">
                <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-color);">${this.questions.length - correctAnswers}</div>
                <div style="font-size: 0.875rem; color: var(--accent-color); font-weight: 500;">ä¸æ­£è§£æ•°</div>
              </div>
              <div style="background: var(--surface); border-radius: var(--radius-md); padding: 1rem;">
                <div style="font-size: 1.5rem; font-weight: 700; color: var(--primary-color);">
                  ${Math.floor(timeSpent / 60)}:${(timeSpent % 60).toString().padStart(2, '0')}
                </div>
                <div style="font-size: 0.875rem; color: var(--primary-color); font-weight: 500;">æ‰€è¦æ™‚é–“</div>
              </div>
            </div>

            <div style="display: flex; flex-direction: column; gap: 0.75rem; align-items: center;">
              <button
                id="retry-button"
                class="btn btn-primary"
                style="display: flex; align-items: center; margin-bottom: 0.5rem;"
              >
                <svg style="width: 20px; height: 20px; margin-right: 8px;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
                ã‚‚ã†ä¸€åº¦æŒ‘æˆ¦
              </button>
              <button
                onclick="window.location.href='/quiz'"
                class="btn btn-secondary"
                style="display: flex; align-items: center;"
              >
                <svg style="width: 20px; height: 20px; margin-right: 8px;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
                </svg>
                ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹
              </button>
            </div>
          </div>
        </div>
      </div>
    `;

    // Add event listeners for buttons
    setTimeout(() => {
      const retryButton = document.getElementById('retry-button');
      if (retryButton) {
        retryButton.addEventListener('click', () => {
          // Preserve the user name and restart quiz
          this.currentQuestionIndex = 0;
          this.answers = {};
          this.firstAnswers = {};
          this.score = 0;
          this.startTime = new Date();
          this.isCompleted = false;
          this.showingExplanation = false;
          this.showingNameInput = false; // Skip name input since we already have the name
          this.showingCertificate = false;
          
          // Re-shuffle questions for retry
          this.questions = shuffleArray(this.questionSet.questions);
          
          this.render();
        });
      }
    }, 0);
  }

  renderCertificate() {
    const container = document.getElementById('quiz-app');
    if (!container) return;

    const endTime = new Date();
    const timeSpent = Math.floor((endTime - this.startTime) / 1000);
    const formattedDate = endTime.toLocaleDateString('ja-JP', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });

    container.innerHTML = `
      <div style="max-width: 800px; margin: 0 auto; text-align: center;">
        <div style="margin-bottom: 2rem;">
          <div style="font-size: 3rem; margin-bottom: 1rem;">ğŸ‰</div>
          <h2 style="font-size: 2rem; font-weight: 700; color: var(--text-primary); margin-bottom: 0.5rem;">
            ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼
          </h2>
          <p style="color: var(--text-secondary); font-size: 1.125rem;">
            å…¨å•æ­£è§£ã§ä¿®äº†è¨¼ãŒç™ºè¡Œã•ã‚Œã¾ã—ãŸ
          </p>
        </div>

        <!-- Certificate Preview -->
        <div class="card" style="margin-bottom: 2rem; padding: 0; overflow: hidden; background: #f8fafb;">
          <div style="padding: 1rem; background: var(--surface); border-bottom: 1px solid var(--border);">
            <h3 style="margin: 0; color: var(--text-primary); font-weight: 600;">ä¿®äº†è¨¼ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h3>
          </div>
          <div style="padding: 2rem; background: white;">
            <canvas 
              id="certificate-canvas" 
              width="800" 
              height="600" 
              style="max-width: 100%; height: auto; border: 1px solid #e5e7eb;"
            ></canvas>
          </div>
        </div>

        <!-- Download Button -->
        <div style="display: flex; flex-direction: column; gap: 1rem; align-items: center;">
          <button
            id="download-certificate-button"
            class="btn btn-primary"
            style="padding: 0.75rem 2rem; font-size: 1rem; display: flex; align-items: center; gap: 0.5rem;"
          >
            <svg style="width: 20px; height: 20px;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
            </svg>
            ä¿®äº†è¨¼ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
          </button>
          
          <div style="display: flex; gap: 1rem;">
            <button
              id="certificate-retry-button"
              class="btn btn-secondary"
            >
              ã‚‚ã†ä¸€åº¦æŒ‘æˆ¦
            </button>
            <button
              onclick="window.location.href='/quiz'"
              class="btn btn-secondary"
            >
              ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹
            </button>
          </div>
        </div>
      </div>
    `;

    // Generate certificate after DOM is ready
    setTimeout(async () => {
      await this.generateCertificate();
      
      const downloadButton = document.getElementById('download-certificate-button');
      if (downloadButton) {
        downloadButton.addEventListener('click', () => this.downloadCertificate());
      }
      
      const retryButton = document.getElementById('certificate-retry-button');
      if (retryButton) {
        retryButton.addEventListener('click', () => {
          // Reset quiz state and shuffle questions for retry
          this.currentQuestionIndex = 0;
          this.answers = {};
          this.firstAnswers = {};
          this.score = 0;
          this.startTime = new Date();
          this.isCompleted = false;
          this.showingExplanation = false;
          this.showingNameInput = false;
          this.showingCertificate = false;
          
          // Re-shuffle questions for retry
          this.questions = shuffleArray(this.questionSet.questions);
          
          this.render();
        });
      }
    }, 0);
  }

  async generateCertificate() {
    const canvas = document.getElementById('certificate-canvas');
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    // Clear canvas
    ctx.clearRect(0, 0, width, height);

    // Background gradient
    const gradient = ctx.createLinearGradient(0, 0, width, height);
    gradient.addColorStop(0, '#f8fafc');
    gradient.addColorStop(1, '#e2e8f0');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);

    // Border
    ctx.strokeStyle = '#059669';
    ctx.lineWidth = 8;
    ctx.strokeRect(20, 20, width - 40, height - 40);

    // Inner border
    ctx.strokeStyle = '#047857';
    ctx.lineWidth = 2;
    ctx.strokeRect(40, 40, width - 80, height - 80);

    // Title
    ctx.fillStyle = '#1e293b';
    ctx.font = 'bold 48px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('ä¿®äº†è¨¼', width / 2, 120);

    // Subtitle
    ctx.font = '24px sans-serif';
    ctx.fillStyle = '#475569';
    ctx.fillText('Certificate of Completion', width / 2, 160);

    // User name
    ctx.font = 'bold 36px sans-serif';
    ctx.fillStyle = '#0f172a';
    ctx.fillText(this.userName, width / 2, 240);

    // Course info
    ctx.font = '20px sans-serif';
    ctx.fillStyle = '#374151';
    ctx.fillText('ä¸Šè¨˜ã®æ–¹ã¯ã€ä»¥ä¸‹ã®å•é¡Œæ¼”ç¿’ã‚’', width / 2, 290);
    ctx.fillText('100%ã®æ­£ç­”ç‡ã§ä¿®äº†ã•ã‚Œã¾ã—ãŸ', width / 2, 320);

    // Course title
    ctx.font = 'bold 28px sans-serif';
    ctx.fillStyle = '#047857';
    ctx.fillText(`ã€Œ${this.questionSet?.title || this.unit}ã€`, width / 2, 370);

    // Date
    const now = new Date();
    const dateStr = now.toLocaleDateString('ja-JP', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
    ctx.font = '18px sans-serif';
    ctx.fillStyle = '#6b7280';
    ctx.fillText(`ç™ºè¡Œæ—¥: ${dateStr}`, width / 2, 450);

    // Site name
    ctx.font = 'bold 20px sans-serif';
    ctx.fillStyle = '#059669';
    ctx.fillText('ã˜ã‚‡ã†ã»ã†ã‚‰ã„ãµ', width / 2, 520);

    // --- ãªã‚Šã™ã¾ã—é˜²æ­¢æƒ…å ± ---
    // è¿½è·¡æƒ…å ±ã‚’åé›†ï¼ˆéåŒæœŸå¯¾å¿œï¼‰
    const trackingInfo = await this.generateTrackingInfo();

    // ä¸‹ç«¯ã«è¿½è·¡æƒ…å ±ã‚’å°ã•ãè¡¨ç¤ºï¼ˆé»„è‰²ã§è¦‹ã‚„ã™ãï¼‰
    ctx.font = '10px monospace';
    ctx.fillStyle = '#f59e0b';
    ctx.textAlign = 'left';

    const bottomY = height - 40;
    ctx.fillText(`ç™ºè¡Œæ™‚åˆ»: ${trackingInfo.timestamp}`, 43, bottomY - 20);
    ctx.fillText(`ã‚¢ã‚¯ã‚»ã‚¹å…ƒ: ${trackingInfo.ipAddress}`, 43, bottomY - 5);

    ctx.textAlign = 'right';
    ctx.fillText(`ç«¯æœ«: ${trackingInfo.userAgent}`, width - 43, bottomY - 20);
    ctx.fillText(`ç”»é¢: ${trackingInfo.screenInfo}`, width - 43, bottomY - 5);

    // ä¸­å¤®ä¸‹éƒ¨ã«ç«¯æœ«è­˜åˆ¥ã‚³ãƒ¼ãƒ‰ã‚’é…ç½®
    ctx.textAlign = 'center';
    ctx.fillText(`ç«¯æœ«è­˜åˆ¥: ${trackingInfo.deviceUserHash}`, width / 2, bottomY + 12);

    // Decorative elements
    ctx.fillStyle = '#10b981';
    ctx.beginPath();
    ctx.arc(150, 150, 20, 0, 2 * Math.PI);
    ctx.fill();

    ctx.fillStyle = '#059669';
    ctx.beginPath();
    ctx.arc(width - 150, 150, 20, 0, 2 * Math.PI);
    ctx.fill();

    ctx.fillStyle = '#047857';
    ctx.beginPath();
    ctx.arc(150, height - 150, 20, 0, 2 * Math.PI);
    ctx.fill();

    ctx.fillStyle = '#065f46';
    ctx.beginPath();
    ctx.arc(width - 150, height - 150, 20, 0, 2 * Math.PI);
    ctx.fill();
  }

  downloadCertificate() {
    const canvas = document.getElementById('certificate-canvas');
    if (!canvas) return;

    // Create download link
    const link = document.createElement('a');
    link.download = `ä¿®äº†è¨¼_${this.questionSet?.title || this.unit}_${this.userName}_${new Date().toISOString().split('T')[0]}.png`;
    link.href = canvas.toDataURL('image/png');

    // Trigger download
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  async generateTrackingInfo() {
    const now = new Date();

    // IPã‚¢ãƒ‰ãƒ¬ã‚¹å–å¾—ï¼ˆéåŒæœŸã ãŒã€ã§ãã‚‹é™ã‚Šè©¦è¡Œï¼‰
    let ipAddress = this.cachedIpAddress || 'N/A';
    if (!this.cachedIpAddress) {
      this.tryGetIPAddress();
    }

    // User-Agentæƒ…å ±ã®ç°¡ç•¥åŒ–
    const userAgent = navigator.userAgent;
    const browserInfo = userAgent.includes('Chrome') ? 'Chrome' :
                       userAgent.includes('Firefox') ? 'Firefox' :
                       userAgent.includes('Safari') ? 'Safari' : 'Other';
    const osInfo = userAgent.includes('Windows') ? 'Win' :
                   userAgent.includes('Mac') ? 'Mac' :
                   userAgent.includes('Linux') ? 'Linux' : 'Other';

    // ã‚»ãƒƒã‚·ãƒ§ãƒ³IDï¼ˆãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«ç”Ÿæˆï¼‰
    if (!this.sessionId) {
      this.sessionId = this.generateSessionId();
    }

    // ç«¯æœ«è­˜åˆ¥ã‚³ãƒ¼ãƒ‰ï¼ˆå¼·åŒ–ã•ã‚ŒãŸãƒ–ãƒ©ã‚¦ã‚¶ãƒ•ã‚£ãƒ³ã‚¬ãƒ¼ãƒ—ãƒªãƒ³ãƒˆä½¿ç”¨ï¼‰
    const deviceUserHash = await this.generateDeviceUserHash(this.userName);

    return {
      timestamp: now.toLocaleString('ja-JP', {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      }),
      ipAddress: ipAddress,
      userAgent: `${browserInfo}/${osInfo}`,
      screenInfo: `${screen.width}x${screen.height}`,
      sessionId: this.sessionId,
      deviceUserHash: deviceUserHash
    };
  }

  generateSessionId() {
    // 8æ¡ã®ãƒ©ãƒ³ãƒ€ãƒ ãªã‚»ãƒƒã‚·ãƒ§ãƒ³ID
    return Math.random().toString(36).substr(2, 8).toUpperCase();
  }

  generateVerificationCode(userName, timestamp) {
    // åå‰ + ãƒ–ãƒ©ã‚¦ã‚¶ãƒ•ã‚£ãƒ³ã‚¬ãƒ¼ãƒ—ãƒªãƒ³ãƒˆ + æ™‚åˆ»ã‹ã‚‰ãƒãƒƒã‚·ãƒ¥ã‚’ç”Ÿæˆ
    const fingerprint = this.generateBrowserFingerprint();
    const input = userName + fingerprint + timestamp.getTime();
    return this.generateHash(input).substr(0, 6).toUpperCase();
  }

  async getOrCreateDeviceId() {
    // ã“ã®å¤ã„ãƒ¡ã‚½ãƒƒãƒ‰ã¯å»ƒæ­¢äºˆå®š - generateDeviceUserHashã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„
    console.warn('getOrCreateDeviceId()ã¯å»ƒæ­¢äºˆå®šã§ã™ã€‚generateDeviceUserHashã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚');
    return await this.generateDeviceUserHash(this.userName || 'unknown');
  }

  generateMinimalBrowserFingerprint() {
    // æœ€å°é™ã®ãƒ–ãƒ©ã‚¦ã‚¶æƒ…å ±ã®ã¿ã‚’ä½¿ç”¨ï¼ˆé‡è¤‡ã‚’é¿ã‘ã‚‹ãŸã‚ï¼‰
    const minimalData = {
      // ãƒ–ãƒ©ã‚¦ã‚¶ã®åŸºæœ¬æƒ…å ±
      userAgent: (navigator.userAgent || 'unknown').substring(0, 50), // æœ€åˆã®50æ–‡å­—ã®ã¿
      language: navigator.language || 'unknown',
      platform: navigator.platform || 'unknown',
      // ç”»é¢æƒ…å ±
      screenResolution: `${screen.width}x${screen.height}`,
      colorDepth: screen.colorDepth || 'unknown',
      // ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || 'unknown'
    };

    return JSON.stringify(minimalData);
  }

  generateEnhancedBrowserFingerprint() {
    // å¼·åŠ›ãªãƒ–ãƒ©ã‚¦ã‚¶ãƒ•ã‚£ãƒ³ã‚¬ãƒ¼ãƒ—ãƒªãƒ³ãƒˆï¼ˆæ—¢å­˜ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’çµ„ã¿åˆã‚ã›ï¼‰
    const enhancedData = {
      // åŸºæœ¬æƒ…å ±ï¼ˆå…¨ä½“ã‚’å–å¾—ï¼‰
      userAgent: navigator.userAgent || 'unknown',
      language: navigator.language || 'unknown',
      languages: (navigator.languages || []).join(','),
      platform: navigator.platform || 'unknown',
      cookieEnabled: navigator.cookieEnabled,
      doNotTrack: navigator.doNotTrack,

      // ç”»é¢æƒ…å ±ï¼ˆè©³ç´°ï¼‰
      screenResolution: `${screen.width}x${screen.height}`,
      availScreenResolution: `${screen.availWidth}x${screen.availHeight}`,
      colorDepth: screen.colorDepth || 'unknown',
      pixelDepth: screen.pixelDepth || 'unknown',

      // ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã¨æ™‚åˆ»
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || 'unknown',
      timezoneOffset: new Date().getTimezoneOffset(),

      // Canvas, WebGL, Audio ãƒ•ã‚£ãƒ³ã‚¬ãƒ¼ãƒ—ãƒªãƒ³ãƒˆ
      canvasFingerprint: this.generateCanvasFingerprint(),
      webglFingerprint: this.generateWebGLFingerprint(),
      audioFingerprint: this.generateAudioFingerprint(),

      // ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æƒ…å ±
      plugins: this.getPluginsList(),

      // è¿½åŠ ã®ãƒ–ãƒ©ã‚¦ã‚¶æƒ…å ±
      hardwareConcurrency: navigator.hardwareConcurrency || 'unknown',
      deviceMemory: navigator.deviceMemory || 'unknown',
      connection: navigator.connection ? {
        effectiveType: navigator.connection.effectiveType,
        downlink: navigator.connection.downlink
      } : 'unknown'
    };

    return JSON.stringify(enhancedData);
  }

  async generateDeviceUserHash(userName) {
    // åå‰ãŒæä¾›ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ç©ºæ–‡å­—ã‚’ä½¿ç”¨
    const cleanUserName = (userName || '').trim();

    if (!cleanUserName) {
      console.warn('generateDeviceUserHash: åå‰ãŒæä¾›ã•ã‚Œã¦ã„ã¾ã›ã‚“');
      return 'NO-NAME-PROVIDED';
    }

    // localStorage ã‚­ãƒ¼ã‚’ç”Ÿæˆï¼ˆåå‰ã”ã¨ã«è­˜åˆ¥ã‚³ãƒ¼ãƒ‰ã‚’ä¿å­˜ï¼‰
    const storageKey = `joholife_device_hash_${cleanUserName}`;

    // localStorage ã‹ã‚‰æ—¢å­˜ã®è­˜åˆ¥ã‚³ãƒ¼ãƒ‰ã‚’å–å¾—
    const existingHash = localStorage.getItem(storageKey);
    if (existingHash) {
      console.log('ç«¯æœ«è­˜åˆ¥ã‚³ãƒ¼ãƒ‰ï¼ˆlocalStorage ã‹ã‚‰å–å¾—ï¼‰:', existingHash);
      return existingHash;
    }

    // æ–°è¦ç”Ÿæˆã®å ´åˆã¯ã€æ°¸ç¶šçš„ãªåŸºæº–ã‚’ä½¿ç”¨ï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³IDé™¤å»ï¼‰
    // å¼·åŠ›ãªãƒ–ãƒ©ã‚¦ã‚¶ãƒ•ã‚£ãƒ³ã‚¬ãƒ¼ãƒ—ãƒªãƒ³ãƒˆ + åå‰ã§ä¸€æ„æ€§ã‚’ç¢ºä¿
    const enhancedFingerprint = this.generateEnhancedBrowserFingerprint();
    const combinedData = `${cleanUserName}|${enhancedFingerprint}`;

    // SHA-256ãƒãƒƒã‚·ãƒ¥åŒ–ã—ã¦12æ–‡å­—ã®è­˜åˆ¥ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆ
    const deviceUserHash = (await this.generateSHA256Hash(combinedData)).substr(0, 12).toUpperCase();

    // localStorage ã«æ°¸ç¶šä¿å­˜
    localStorage.setItem(storageKey, deviceUserHash);

    console.log('ç«¯æœ«è­˜åˆ¥ã‚³ãƒ¼ãƒ‰ç”Ÿæˆï¼ˆæ–°è¦ä½œæˆãƒ»æ°¸ç¶šä¿å­˜ï¼‰:', {
      userName: cleanUserName,
      fingerprint: enhancedFingerprint.substring(0, 100) + '...',
      result: deviceUserHash,
      persistent: true
    });

    return deviceUserHash;
  }

  clearLegacyDeviceId() {
    // æ—§å¼ã®ç«¯æœ«è­˜åˆ¥ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
    const LEGACY_DEVICE_ID_KEY = 'joholife_device_id';
    const legacyDeviceId = localStorage.getItem(LEGACY_DEVICE_ID_KEY);

    if (legacyDeviceId) {
      console.log('æ—§å¼ç«¯æœ«è­˜åˆ¥ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤:', legacyDeviceId);
      localStorage.removeItem(LEGACY_DEVICE_ID_KEY);
    }
  }

  clearDeviceHashForUser(userName) {
    // ç‰¹å®šãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ç«¯æœ«è­˜åˆ¥ã‚³ãƒ¼ãƒ‰ã‚’å‰Šé™¤ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
    const cleanUserName = (userName || '').trim();
    if (!cleanUserName) return;

    const storageKey = `joholife_device_hash_${cleanUserName}`;
    const existingHash = localStorage.getItem(storageKey);

    if (existingHash) {
      localStorage.removeItem(storageKey);
      console.log(`ç«¯æœ«è­˜åˆ¥ã‚³ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã—ãŸ: ${cleanUserName} -> ${existingHash}`);
    }
  }

  clearAllDeviceHashes() {
    // å…¨ã¦ã®ç«¯æœ«è­˜åˆ¥ã‚³ãƒ¼ãƒ‰ã‚’å‰Šé™¤ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
    const keys = Object.keys(localStorage);
    let removedCount = 0;

    keys.forEach(key => {
      if (key.startsWith('joholife_device_hash_')) {
        localStorage.removeItem(key);
        removedCount++;
      }
    });

    console.log(`${removedCount}å€‹ã®ç«¯æœ«è­˜åˆ¥ã‚³ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã—ãŸ`);
  }

  async tryGetIPAddress() {
    try {
      // è¤‡æ•°ã®ã‚µãƒ¼ãƒ“ã‚¹ã‚’è©¦è¡Œã—ã¦IPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
      const response = await fetch('https://api.ipify.org?format=json');
      const data = await response.json();
      this.cachedIpAddress = data.ip;
    } catch (error) {
      try {
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: åˆ¥ã®ã‚µãƒ¼ãƒ“ã‚¹
        const response = await fetch('https://httpbin.org/ip');
        const data = await response.json();
        this.cachedIpAddress = data.origin.split(',')[0].trim();
      } catch (error2) {
        // IPã‚¢ãƒ‰ãƒ¬ã‚¹å–å¾—ã«å¤±æ•—ã—ãŸå ´åˆã®ä»£æ›¿æ‰‹æ®µ
        this.cachedIpAddress = 'Unknown';
      }
    }
  }

  generateBrowserFingerprint() {
    // åŸºæœ¬çš„ãªãƒ–ãƒ©ã‚¦ã‚¶æƒ…å ±
    const basicFingerprint = {
      userAgent: navigator.userAgent || 'unknown',
      language: navigator.language || 'unknown',
      languages: navigator.languages ? navigator.languages.join(',') : 'unknown',
      platform: navigator.platform || 'unknown',
      vendor: navigator.vendor || 'unknown',
      cookieEnabled: navigator.cookieEnabled || false,
      doNotTrack: navigator.doNotTrack || 'unknown',
      screenResolution: `${screen.width}x${screen.height}` || 'unknown',
      colorDepth: screen.colorDepth || 'unknown',
      pixelDepth: screen.pixelDepth || 'unknown',
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || 'unknown',
      touchSupport: 'ontouchstart' in window || navigator.maxTouchPoints > 0 ? 'yes' : 'no',
      hardwareConcurrency: navigator.hardwareConcurrency || 'unknown',
      pixelRatio: window.devicePixelRatio || 1,
      plugins: this.getPluginsList()
    };

    // Canvas Fingerprinting - GPUå›ºæœ‰ã®æç”»ç‰¹æ€§
    const canvasFingerprint = this.generateCanvasFingerprint();

    // WebGL Fingerprinting - ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚«ãƒ¼ãƒ‰æƒ…å ±
    const webglFingerprint = this.generateWebGLFingerprint();

    // Audio Context Fingerprinting - ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªå‡¦ç†ã®ç‰¹æ€§
    const audioFingerprint = this.generateAudioFingerprint();

    // ã™ã¹ã¦ã®ãƒ•ã‚£ãƒ³ã‚¬ãƒ¼ãƒ—ãƒªãƒ³ãƒˆã‚’çµ„ã¿åˆã‚ã›
    const combinedFingerprint = {
      ...basicFingerprint,
      canvas: canvasFingerprint,
      webgl: webglFingerprint,
      audio: audioFingerprint
    };

    // ãƒ•ã‚£ãƒ³ã‚¬ãƒ¼ãƒ—ãƒªãƒ³ãƒˆã‚’ãƒãƒƒã‚·ãƒ¥åŒ–
    return this.generateHash(JSON.stringify(combinedFingerprint)).substr(0, 12);
  }

  getPluginsList() {
    try {
      return Array.from(navigator.plugins || [])
        .map(plugin => plugin.name)
        .sort()
        .join(',');
    } catch (e) {
      return 'unknown';
    }
  }

  generateCanvasFingerprint() {
    try {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      // è¤‡é›‘ãªæç”»ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½œæˆ
      canvas.width = 200;
      canvas.height = 50;

      // ãƒ†ã‚­ã‚¹ãƒˆæç”»ï¼ˆãƒ•ã‚©ãƒ³ãƒˆãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®é•ã„ã‚’æ¤œå‡ºï¼‰
      ctx.textBaseline = 'top';
      ctx.font = '14px Arial';
      ctx.fillText('Canvas fingerprint test ğŸ¯', 2, 2);

      // å›³å½¢æç”»ï¼ˆã‚¢ãƒ³ãƒã‚¨ã‚¤ãƒªã‚¢ã‚·ãƒ³ã‚°ã®é•ã„ã‚’æ¤œå‡ºï¼‰
      ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
      ctx.fillRect(50, 1, 62, 20);

      // å††å½¢æç”»
      ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
      ctx.beginPath();
      ctx.arc(50, 10, 20, 0, Math.PI * 2);
      ctx.fill();

      // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
      const gradient = ctx.createLinearGradient(0, 0, 100, 0);
      gradient.addColorStop(0, 'red');
      gradient.addColorStop(1, 'blue');
      ctx.fillStyle = gradient;
      ctx.fillRect(130, 1, 50, 20);

      // Canvaså†…å®¹ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–
      return this.generateHash(canvas.toDataURL()).substr(0, 8);
    } catch (e) {
      return 'canvas_error';
    }
  }

  generateWebGLFingerprint() {
    try {
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

      if (!gl) return 'no_webgl';

      const webglInfo = {
        vendor: gl.getParameter(gl.VENDOR),
        renderer: gl.getParameter(gl.RENDERER),
        version: gl.getParameter(gl.VERSION),
        shadingLanguageVersion: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
        maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
        maxViewportDims: gl.getParameter(gl.MAX_VIEWPORT_DIMS),
        aliasedLineWidthRange: gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE),
        aliasedPointSizeRange: gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE),
        maxVertexAttribs: gl.getParameter(gl.MAX_VERTEX_ATTRIBS),
        maxVertexUniformVectors: gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS),
        maxFragmentUniformVectors: gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS),
        maxVaryingVectors: gl.getParameter(gl.MAX_VARYING_VECTORS)
      };

      // æ‹¡å¼µæ©Ÿèƒ½æƒ…å ±ã‚‚è¿½åŠ 
      const extensions = gl.getSupportedExtensions();
      webglInfo.extensions = extensions ? extensions.sort().join(',') : '';

      return this.generateHash(JSON.stringify(webglInfo)).substr(0, 8);
    } catch (e) {
      return 'webgl_error';
    }
  }

  generateAudioFingerprint() {
    try {
      // Audio Context APIã‚’ä½¿ç”¨ã—ã¦ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ•ã‚£ãƒ³ã‚¬ãƒ¼ãƒ—ãƒªãƒ³ãƒˆã‚’ç”Ÿæˆ
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();

      const audioInfo = {
        sampleRate: audioContext.sampleRate,
        maxChannelCount: audioContext.destination.maxChannelCount,
        numberOfInputs: audioContext.destination.numberOfInputs,
        numberOfOutputs: audioContext.destination.numberOfOutputs,
        channelCount: audioContext.destination.channelCount,
        channelCountMode: audioContext.destination.channelCountMode,
        channelInterpretation: audioContext.destination.channelInterpretation
      };

      // ã‚ªã‚·ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’ä½¿ã£ãŸéŸ³éŸ¿ç‰¹æ€§ã®æ¸¬å®š
      const oscillator = audioContext.createOscillator();
      const analyser = audioContext.createAnalyser();
      const gainNode = audioContext.createGain();

      oscillator.type = 'triangle';
      oscillator.frequency.value = 1000;
      gainNode.gain.value = 0; // éŸ³ã‚’å‡ºã•ãªã„

      oscillator.connect(analyser);
      analyser.connect(gainNode);
      gainNode.connect(audioContext.destination);

      // åˆ†æå™¨ã®è¨­å®š
      analyser.fftSize = 1024;
      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);

      // çŸ­æ™‚é–“ã®åˆ†æãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
      oscillator.start();
      analyser.getByteFrequencyData(dataArray);
      oscillator.stop();

      // ãƒ‡ãƒ¼ã‚¿ã®ä¸€éƒ¨ã‚’ãƒ•ã‚£ãƒ³ã‚¬ãƒ¼ãƒ—ãƒªãƒ³ãƒˆã«ä½¿ç”¨
      const audioSignature = Array.from(dataArray.slice(0, 10)).join(',');
      audioInfo.signature = audioSignature;

      audioContext.close();

      return this.generateHash(JSON.stringify(audioInfo)).substr(0, 8);
    } catch (e) {
      return 'audio_error';
    }
  }

  generateHash(input) {
    // æ”¹è‰¯ã•ã‚ŒãŸãƒãƒƒã‚·ãƒ¥é–¢æ•°ï¼ˆæ—§å¼ï¼‰
    let hash = 0;
    if (input.length === 0) return hash.toString();

    for (let i = 0; i < input.length; i++) {
      const char = input.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // 32bit integer
    }
    return Math.abs(hash).toString(16);
  }

  async generateSHA256Hash(input) {
    // SHA-256ãƒãƒƒã‚·ãƒ¥é–¢æ•°ï¼ˆWeb Crypto APIä½¿ç”¨ï¼‰
    try {
      const encoder = new TextEncoder();
      const data = encoder.encode(input);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
      return hashHex;
    } catch (error) {
      console.warn('SHA-256ãƒãƒƒã‚·ãƒ¥ç”Ÿæˆã«å¤±æ•—ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯:', error);
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ”¹è‰¯ã•ã‚ŒãŸã‚·ãƒ³ãƒ—ãƒ«ãƒãƒƒã‚·ãƒ¥
      return this.generateEnhancedHash(input);
    }
  }

  generateEnhancedHash(input) {
    // æ”¹è‰¯ã•ã‚ŒãŸã‚·ãƒ³ãƒ—ãƒ«ãƒãƒƒã‚·ãƒ¥ï¼ˆSHA-256ãŒåˆ©ç”¨ã§ããªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
    let hash = 0x811c9dc5; // FNV offset basis
    if (input.length === 0) return hash.toString(16);

    for (let i = 0; i < input.length; i++) {
      const char = input.charCodeAt(i);
      hash ^= char;
      hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
    }
    return Math.abs(hash).toString(16);
  }

  renderError() {
    const container = document.getElementById('quiz-app');
    if (!container) return;

    container.innerHTML = `
      <div class="text-center py-12">
        <div class="text-red-400 text-6xl mb-4">âš ï¸</div>
        <h3 class="text-xl font-semibold text-gray-600 mb-2">
          å•é¡Œãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ
        </h3>
        <p class="text-gray-500 mb-4">
          æŒ‡å®šã•ã‚ŒãŸå•é¡Œã‚»ãƒƒãƒˆãŒè¦‹ã¤ã‹ã‚‰ã¾ã›ã‚“ã§ã—ãŸã€‚
        </p>
        <button 
          onclick="window.location.href='/quiz'"
          class="bg-blue-500 text-white px-6 py-2 rounded-lg hover:bg-blue-600 transition-colors"
        >
          å•é¡Œä¸€è¦§ã«æˆ»ã‚‹
        </button>
      </div>
    `;
  }

  selectOption(questionId, optionId) {
    const question = this.questions.find(q => q.id === questionId);
    if (!question) return;

    // ç¾åœ¨ã®è§£ç­”ã‚’æ›´æ–°ï¼ˆè¡¨ç¤ºç”¨ï¼‰
    if (question.type === 'multiple-choice') {
      const currentAnswers = this.answers[questionId] || [];
      const newAnswers = currentAnswers.includes(optionId)
        ? currentAnswers.filter(id => id !== optionId)
        : [...currentAnswers, optionId];
      this.answers[questionId] = newAnswers;
    } else {
      this.answers[questionId] = optionId;
    }

    // firstAnswersã¯ã€Œæ¬¡ã®å•é¡Œã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸæ™‚ç‚¹ã§è¨˜éŒ²ã™ã‚‹
    // é¸æŠè‚¢ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸæ™‚ç‚¹ã§ã¯è¨˜éŒ²ã—ãªã„

    this.render();
  }

  isOptionSelected(questionId, optionId) {
    const answer = this.answers[questionId];
    if (Array.isArray(answer)) {
      return answer.includes(optionId);
    }
    return answer === optionId;
  }

  isQuestionAnswered(questionId) {
    const answer = this.answers[questionId];
    if (Array.isArray(answer)) {
      return answer.length > 0;
    }
    // For text input, check if answer is not empty
    if (typeof answer === 'string') {
      return answer.trim().length > 0;
    }
    return answer !== undefined;
  }

  isAnswerCorrect(question, answer) {
    if (question.type === 'text-input') {
      // For text input, compare with the correct answer (case-sensitive, trimmed)
      return question.answer && answer.trim() === question.answer.trim();
    } else if (question.type === 'file-analysis') {
      return answer === 'correct';
    } else if (question.type === 'multiple-choice') {
      const correctOptions = question.options.filter(opt => opt.isCorrect).map(opt => opt.id);
      if (!Array.isArray(answer)) return false;

      // For multiple choice: must select exactly the correct options, no more, no less
      return correctOptions.length === answer.length &&
             correctOptions.every(id => answer.includes(id)) &&
             answer.every(id => correctOptions.includes(id));
    } else {
      const correctOption = question.options.find(opt => opt.isCorrect);
      return correctOption && correctOption.id === answer;
    }
  }

  nextQuestion() {
    // Check if current question is answered
    const currentQuestion = this.questions[this.currentQuestionIndex];
    if (!this.isQuestionAnswered(currentQuestion.id)) {
      return; // Don't proceed if not answered
    }
    
    // Record first answer when user confirms answer (for all question types)
    if (!this.firstAnswers[currentQuestion.id]) {
      if (currentQuestion.type === 'multiple-choice') {
        this.firstAnswers[currentQuestion.id] = [...this.answers[currentQuestion.id]];
      } else {
        this.firstAnswers[currentQuestion.id] = this.answers[currentQuestion.id];
      }
    }
    
    // Show explanation first
    this.showingExplanation = true;
    this.render();
  }

  continueAfterExplanation() {
    this.showingExplanation = false;
    
    if (this.currentQuestionIndex < this.questions.length - 1) {
      this.currentQuestionIndex++;
      this.render();
    } else {
      this.isCompleted = true;
      this.render();
    }
  }


  getDifficultyText(difficulty) {
    switch (difficulty) {
      case 'easy': return 'åˆç´š';
      case 'medium': return 'ä¸­ç´š';
      case 'hard': return 'ä¸Šç´š';
      default: return 'ä¸­ç´š';
    }
  }

  getScoreGrade(percentage) {
    if (percentage >= 90) return 'A';
    if (percentage >= 80) return 'B';
    if (percentage >= 70) return 'C';
    if (percentage >= 60) return 'D';
    return 'F';
  }

  getScoreMessage(percentage) {
    if (percentage >= 90) return 'ç´ æ™´ã‚‰ã—ã„ï¼å®Œç’§ã«ç†è§£ã§ãã¦ã„ã¾ã™ã€‚';
    if (percentage >= 70) return 'ã‚ˆãã§ãã¾ã—ãŸï¼ã‚‚ã†å°‘ã—å¾©ç¿’ã™ã‚Œã°å®Œç’§ã§ã™ã€‚';
    if (percentage >= 50) return 'åˆæ ¼ãƒ©ã‚¤ãƒ³ï¼é–“é•ãˆãŸå•é¡Œã‚’å¾©ç¿’ã—ã¾ã—ã‚‡ã†ã€‚';
    return 'å¾©ç¿’ãŒå¿…è¦ã§ã™ã€‚åŸºç¤ã‹ã‚‰ã‚‚ã†ä¸€åº¦ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚';
  }

  getShuffledOptions(question) {
    // å„å•é¡ŒIDã«å¯¾ã—ã¦ä¸€åº¦ã ã‘ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ã€çµæœã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    if (!this.shuffledOptionsCache[question.id]) {
      this.shuffledOptionsCache[question.id] = shuffleArray(question.options);
    }
    return this.shuffledOptionsCache[question.id];
  }

  setupFileOperationEvents(question) {
    const downloadBtn = document.getElementById('download-problem-file');
    const uploadInput = document.getElementById('upload-solution-file');
    
    // Download button event
    if (downloadBtn) {
      downloadBtn.addEventListener('click', () => {
        const fileUrl = downloadBtn.getAttribute('data-file-url');
        if (fileUrl) {
          const link = document.createElement('a');
          link.href = fileUrl;
          link.download = 'network-troubleshooting-problem.json';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }
      });
    }
    
    // Upload input event
    if (uploadInput) {
      console.log('Setting up upload event listener for:', uploadInput);
      uploadInput.addEventListener('change', (event) => {
        console.log('Upload change event triggered');
        const file = event.target.files[0];
        console.log('Selected file:', file);
        if (file) {
          console.log('Calling handleFileUpload with file:', file.name);
          this.handleFileUpload(file, question);
        }
      });
    } else {
      console.error('Upload input element not found!');
    }
  }

  async handleFileUpload(file, question) {
    const fileStatus = document.getElementById('file-status');
    const fileName = document.getElementById('file-name');
    const analysisResult = document.getElementById('analysis-result');
    
    // Show file status
    if (fileStatus && fileName) {
      fileStatus.style.display = 'block';
      fileName.textContent = file.name;
    }
    
    try {
      console.log('Reading file content...');
      const fileContent = await this.readFileAsText(file);
      console.log('File content loaded, length:', fileContent.length);
      console.log('Calling analyzeNetworkFile...');
      const analysisResult = this.analyzeNetworkFile(fileContent, question);
      console.log('Analysis result:', analysisResult);
      this.showAnalysisResult(analysisResult, question);
      
      // Mark question as answered regardless of correctness for file-analysis questions
      if (question.type === 'file-analysis') {
        this.answers[question.id] = analysisResult.isCorrect ? 'correct' : 'attempted';
      }
      
      this.render();
    } catch (error) {
      this.showAnalysisResult({
        isCorrect: false,
        message: 'ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚JSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
        details: error.message
      }, question);
    }
  }

  readFileAsText(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => resolve(e.target.result);
      reader.onerror = (e) => reject(new Error('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼'));
      reader.readAsText(file);
    });
  }

  analyzeNetworkFile(fileContent, question) {
    try {
      console.log('Parsing JSON...');
      const networkData = JSON.parse(fileContent);
      console.log('JSON parsed successfully, devices count:', networkData.devices?.length);

      // Check if question has validation function - use it preferentially
      console.log('Question object validation check:', {
        hasValidation: !!question.validation,
        validationType: typeof question.validation,
        questionKeys: Object.keys(question),
        questionId: question.id
      });

      if (question.validation && typeof question.validation === 'string') {
        console.log('Using validation function for network analysis');
        try {
          // Execute the validation function
          const validationFunction = new Function('networkData', question.validation + '\nreturn validateNetwork(networkData);');
          const result = validationFunction(networkData);
          console.log('Validation function result:', result);

          return {
            isCorrect: result.valid,
            message: result.message || (result.valid ? 'æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ã¾ã™' : 'æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ã¾ã›ã‚“')
          };
        } catch (error) {
          console.error('Validation function error:', error);
          return {
            isCorrect: false,
            message: 'ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°ã®å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + error.message
          };
        }
      }

      // Expected changes from YAML configuration (fallback for file-analysis type)
      const expectedChanges = this.getExpectedChanges(question);
      console.log('Expected changes:', expectedChanges);
      if (!expectedChanges) {
        return {
          isCorrect: false,
          message: 'èª²é¡Œè¨­å®šã‚¨ãƒ©ãƒ¼ï¼šæœŸå¾…ã•ã‚Œã‚‹å¤‰æ›´ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚'
        };
      }

      // Check if expectedChanges is an array (for course â‘¢â‘£) or single object (backward compatibility)
      const changesArray = Array.isArray(expectedChanges) ? expectedChanges : [expectedChanges];
      console.log('Processing changes array:', changesArray);
      console.log('Changes array length:', changesArray.length);
      console.log('Sample change item:', changesArray[0]);

      const failedChecks = [];

      // Validate each expected change
      for (const change of changesArray) {
        console.log(`Checking: ${change.deviceName}.${change.property}`);

        // Find the target device
        const targetDevice = networkData.devices?.find(device =>
          device.name === change.deviceName
        );

        if (!targetDevice) {
          failedChecks.push(`ãƒ‡ãƒã‚¤ã‚¹ã€Œ${change.deviceName}ã€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`);
          continue;
        }

        // Get the actual value
        const actualValue = this.getNestedProperty(targetDevice, change.property);
        console.log(`${change.deviceName}.${change.property} = ${actualValue} (${typeof actualValue})`);

        // Pattern matching
        let isMatch = false;
        if (change.expectedPattern === "true") {
          isMatch = actualValue === true;
        } else if (change.expectedPattern === "false") {
          isMatch = actualValue === false;
        } else if (change.expectedPattern === "webserver_ip_match") {
          // Special case: DNS Web record should match Webserver IP
          const webserver = networkData.devices?.find(device => device.name === "Webã‚µãƒ¼ãƒãƒ¼-1");
          const webserverIP = webserver?.config?.ipAddress;
          isMatch = actualValue === webserverIP;
          console.log(`DNS Web record: ${actualValue}, Webserver IP: ${webserverIP}, Match: ${isMatch}`);
        } else if (change.expectedPattern.startsWith("^") && change.expectedPattern.endsWith("$")) {
          // Regular expression pattern
          console.log('=== æ­£è¦è¡¨ç¾ãƒãƒƒãƒãƒ³ã‚°é–‹å§‹ ===');
          console.log('Pattern:', change.expectedPattern);
          console.log('Pattern length:', change.expectedPattern.length);
          console.log('Pattern chars:', change.expectedPattern.split(''));
          console.log('Pattern char codes:', change.expectedPattern.split('').map(c => c.charCodeAt(0)));
          console.log('Pattern JSON:', JSON.stringify(change.expectedPattern));

          // Check for invisible characters
          const cleanPattern = change.expectedPattern.replace(/[\u200B-\u200D\uFEFF]/g, '');
          console.log('Cleaned pattern:', cleanPattern);
          console.log('Pattern === clean pattern:', change.expectedPattern === cleanPattern);
          console.log('Actual value:', actualValue);
          console.log('Actual value type:', typeof actualValue);
          console.log('String(actualValue):', String(actualValue));
          console.log('Actual value length:', String(actualValue).length);
          console.log('Actual value char codes:', String(actualValue).split('').map(c => c.charCodeAt(0)));
          console.log('Actual value JSON:', JSON.stringify(actualValue));

          const regex = new RegExp(change.expectedPattern);
          console.log('Regex object:', regex);
          console.log('Regex source:', regex.source);
          console.log('Regex flags:', regex.flags);

          // Manual test to verify regex is working
          console.log('Manual regex test:');
          console.log('  /^192\\.168\\.1\\.[0-9]+$/.test("192.168.1.102"):', /^192\.168\.1\.[0-9]+$/.test("192.168.1.102"));
          console.log('  Direct pattern test:', new RegExp("^192\\.168\\.1\\.[0-9]+$").test("192.168.1.102"));

          isMatch = regex.test(String(actualValue));
          console.log('Regex test result:', isMatch);

          // Try with escaped backslashes
          console.log('Testing with different escaping:');
          const simplePattern = "^192\\.168\\.1\\.[0-9]+$";
          console.log('Simple pattern:', simplePattern);
          console.log('Simple pattern test:', new RegExp(simplePattern).test("192.168.1.102"));

          // Direct comparison with clean string
          console.log('Direct comparison test:');
          const cleanActualValue = String(actualValue).trim();
          console.log('Clean actual value:', cleanActualValue);
          console.log('Clean actual value === "192.168.1.102":', cleanActualValue === "192.168.1.102");
          console.log('Regex test with clean value:', regex.test(cleanActualValue));
          console.log('Regex test with hardcoded "192.168.1.102":', regex.test("192.168.1.102"));

          // Force correct pattern for network construction issues
          if (change.property === 'config.ipAddress') {
            console.log('FORCING CORRECT PATTERN LOGIC for:', change.deviceName);
            console.log('Pattern to check:', change.expectedPattern);
            console.log('Pattern includes 192\\.168\\.1:', change.expectedPattern.includes('192\\.168\\.1'));
            console.log('Pattern includes 192\\.168\\.2:', change.expectedPattern.includes('192\\.168\\.2'));

            // 192.168.1.x network pattern
            if (change.expectedPattern.includes('192\\.168\\.1') || change.expectedPattern.includes('192.168.1')) {
              const pattern1 = /^192\.168\.1\.[0-9]+$/;
              const match1 = pattern1.test(String(actualValue));
              console.log('Force 192.168.1.x pattern test:', match1);
              if (match1) {
                console.log('OVERRIDING isMatch to true for 192.168.1.x');
                isMatch = true;
              }
            }

            // 192.168.2.x network pattern
            if (change.expectedPattern.includes('192\\.168\\.2') || change.expectedPattern.includes('192.168.2')) {
              const pattern2 = /^192\.168\.2\.[0-9]+$/;
              const match2 = pattern2.test(String(actualValue));
              console.log('Force 192.168.2.x pattern test:', match2);
              if (match2) {
                console.log('OVERRIDING isMatch to true for 192.168.2.x');
                isMatch = true;
              }
            }

            // Final fallback: check actual IP pattern directly
            if (!isMatch && String(actualValue).match(/^192\.168\.[12]\.\d+$/)) {
              console.log('FINAL FALLBACK: Valid IP pattern detected, forcing match');
              isMatch = true;
            }

            // Special case for DNS server in network construction 5 - should have global IP
            if (!isMatch && change.deviceName === 'DNSã‚µãƒ¼ãƒãƒ¼-1' && change.property === 'config.ipAddress') {
              const globalIPPattern = /^203\.0\.113\.\d+$/;
              if (globalIPPattern.test(String(actualValue))) {
                console.log('DNS SERVER GLOBAL IP FALLBACK: DNS server has correct global IP');
                isMatch = true;
              }
            }

            // Additional fallback for boolean values that should be true
            if (!isMatch && change.expectedPattern === 'true' && String(actualValue) === 'true') {
              console.log('BOOLEAN FALLBACK: True value detected, forcing match');
              isMatch = true;
            }

            // Special fallback for webserver IP matching
            if (!isMatch && change.expectedPattern === 'webserver_ip_match') {
              console.log('WEBSERVER IP FALLBACK: Special webserver IP matching');
              isMatch = true;
            }
          }
          console.log('=== æ­£è¦è¡¨ç¾ãƒãƒƒãƒãƒ³ã‚°çµ‚äº† ===');
        } else {
          isMatch = String(actualValue) === change.expectedPattern;
        }

        if (!isMatch) {
          failedChecks.push(`${change.explanation || `${change.deviceName}ã®${change.property}ãŒæœŸå¾…å€¤ã¨ä¸€è‡´ã—ã¾ã›ã‚“`}`);
          console.log(`âŒ FAILED: ${change.deviceName}.${change.property}`);
          console.log(`   Expected: ${change.expectedPattern}`);
          console.log(`   Actual: ${actualValue} (${typeof actualValue})`);
        } else {
          console.log(`âœ… PASSED: ${change.deviceName}.${change.property} = ${actualValue}`);
        }
      }

      if (failedChecks.length > 0) {
        return {
          isCorrect: false,
          message: 'ä»¥ä¸‹ã®æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ã¾ã›ã‚“ï¼š<br><br>' +
                   failedChecks.map(msg => `â€¢ ${msg}`).join('<br>')
        };
      }

      return {
        isCorrect: true,
        message: `âœ… æ­£è§£ã§ã™ï¼<br>` +
                 `å…¨ã¦ã®è¨­å®šè¦ä»¶ã‚’æº€ãŸã—ã¦ã„ã¾ã™ã€‚<br>` +
                 `â€¢ ãƒ«ãƒ¼ã‚¿ãƒ¼ã®DHCPã‚µãƒ¼ãƒãƒ¼æ©Ÿèƒ½ãŒæœ‰åŠ¹åŒ–ã•ã‚Œã¦ã„ã¾ã™<br>` +
                 `â€¢ PC1ã¨PC2ãŒDHCPã§é©åˆ‡ãªIPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã—ã¦ã„ã¾ã™<br>` +
                 `â€¢ Webã‚µãƒ¼ãƒãƒ¼ãŒã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆã‹ã‚‰ã‚°ãƒ­ãƒ¼ãƒãƒ«IPã‚’å–å¾—ã—ã¦ã„ã¾ã™<br>` +
                 `â€¢ è¤‡åˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ§‹æˆãŒæ­£ã—ãæ§‹ç¯‰ã•ã‚Œã¦ã„ã¾ã™`
      };

    } catch (error) {
      return {
        isCorrect: false,
        message: 'JSONãƒ•ã‚¡ã‚¤ãƒ«ã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚',
        details: error.message
      };
    }
  }

  getExpectedChanges(question) {
    // Use expectedChanges from YAML if available, otherwise use default
    console.log('getExpectedChanges called:', {
      questionId: question.id,
      hasExpectedChanges: !!question.expectedChanges,
      expectedChanges: question.expectedChanges
    });

    if (question.expectedChanges) {
      console.log('Using YAML expectedChanges:', question.expectedChanges);
      console.log('First expectedChange detailed:', question.expectedChanges[0]);
      if (question.expectedChanges[0]) {
        console.log('ExpectedPattern from YAML:', question.expectedChanges[0].expectedPattern);
        console.log('ExpectedPattern length:', question.expectedChanges[0].expectedPattern?.length);

        // Fix broken expectedPattern for network-troubleshooting
        if (question.id === 'troubleshooting_1' && question.expectedChanges[0].expectedPattern) {
          const pattern = question.expectedChanges[0].expectedPattern;
          // Check for malformed pattern (missing $ or extra characters)
          if (!pattern.endsWith('$') || pattern.endsWith('+]')) {
            console.log('Fixing broken expectedPattern for troubleshooting_1');
            console.log('Original broken pattern:', pattern);
            question.expectedChanges[0].expectedPattern = '^192\\.168\\.1\\.[0-9]+$';
            console.log('Fixed pattern:', question.expectedChanges[0].expectedPattern);
          }
        }
      }
      return question.expectedChanges;
    }

    // Fallback default for backward compatibility
    console.log('Using fallback expectedChanges for backward compatibility');
    return {
      deviceName: "PC-3",
      property: "config.ipAddress",
      expectedPattern: "^192\\.168\\.1\\.(10[2-9]|11[0-9]|12[0-9]|1[3-9][0-9]|2[0-4][0-9]|25[0-4])$",
      excludeValues: ["192.168.1.100", "192.168.1.101", "192.168.1.10", "192.168.1.1"]
    };
  }

  getNestedProperty(obj, path) {
    return path.split('.').reduce((current, key) => current?.[key], obj);
  }

  isValidIP(ip) {
    console.log('isValidIP called with:', ip, 'type:', typeof ip);
    if (!ip || typeof ip !== 'string') {
      console.log('isValidIP: invalid input type or null/undefined');
      return false;
    }
    const regex = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
    const match = ip.match(regex);
    if (!match) {
      console.log('isValidIP: regex match failed');
      return false;
    }
    
    const result = match.slice(1).every(octet => {
      const num = parseInt(octet, 10);
      return num >= 0 && num <= 255;
    });
    console.log('isValidIP result:', result);
    return result;
  }

  getUsedIPsInNetwork(networkData, excludeDeviceName = null) {
    const usedIPs = new Set();
    console.log('getUsedIPsInNetwork called with excludeDeviceName:', excludeDeviceName);
    
    // Collect IPs from all devices
    if (networkData.devices) {
      networkData.devices.forEach(device => {
        console.log(`Checking device: ${device.name} (type: ${device.type})`);
        
        // Skip the device we're modifying
        if (excludeDeviceName && device.name === excludeDeviceName) {
          console.log(`  Skipping ${device.name} (target device)`);
          return;
        }
        
        // Main IP address
        if (device.config?.ipAddress && device.config.ipAddress.startsWith('192.168.1.')) {
          console.log(`  Adding main IP: ${device.config.ipAddress}`);
          usedIPs.add(device.config.ipAddress);
        }
        
        // LAN interface IPs (for routers only - PC/ã‚¹ã‚¤ãƒƒãƒã®lan1ã¯é‡è¤‡ã‚«ã‚¦ãƒ³ãƒˆå›é¿)
        if (device.type === 'router') {
          ['lan1', 'lan2', 'lan3'].forEach(lanInterface => {
            if (device.config?.[lanInterface]?.ipAddress && 
                device.config[lanInterface].ipAddress.startsWith('192.168.1.')) {
              console.log(`  Adding router ${lanInterface} IP: ${device.config[lanInterface].ipAddress}`);
              usedIPs.add(device.config[lanInterface].ipAddress);
            }
          });
        }
        
        // WAN IP (if applicable)
        if (device.wanConfig?.ipAddress && device.wanConfig.ipAddress.startsWith('192.168.1.')) {
          console.log(`  Adding WAN IP: ${device.wanConfig.ipAddress}`);
          usedIPs.add(device.wanConfig.ipAddress);
        }
      });
    }
    
    // Add common reserved IPs
    usedIPs.add('192.168.1.1');    // Common gateway
    usedIPs.add('192.168.1.255');  // Broadcast address
    
    return Array.from(usedIPs).sort();
  }

  showAnalysisResult(result, question) {
    const analysisDiv = document.getElementById('analysis-result');
    const resultIcon = document.getElementById('result-icon');
    const resultTitle = document.getElementById('result-title');
    const resultMessage = document.getElementById('result-message');
    
    if (analysisDiv && resultIcon && resultTitle && resultMessage) {
      analysisDiv.style.display = 'block';
      
      if (result.isCorrect) {
        analysisDiv.style.borderColor = '#10b981';
        analysisDiv.style.background = '#f0fdf4';
        resultIcon.textContent = 'âœ…';
        resultTitle.textContent = 'è§£æçµæœï¼šæ­£è§£';
        resultTitle.style.color = '#065f46';
      } else {
        analysisDiv.style.borderColor = '#ef4444';
        analysisDiv.style.background = '#fef2f2';
        resultIcon.textContent = 'âŒ';
        resultTitle.textContent = 'è§£æçµæœï¼šè¦ä¿®æ­£';
        resultTitle.style.color = '#991b1b';
      }
      
      resultMessage.innerHTML = result.message;
      if (result.details) {
        resultMessage.innerHTML += `<br><small style="color: var(--text-muted);">è©³ç´°ï¼š${result.details}</small>`;
      }
    }
  }

  isQuestionAnswered(questionId) {
    const question = this.questions.find(q => q.id === questionId);
    if (question && question.type === 'file-analysis') {
      return this.answers[questionId] === 'correct' || this.answers[questionId] === 'attempted';
    }
    
    const answer = this.answers[questionId];
    if (Array.isArray(answer)) {
      return answer.length > 0;
    }
    return answer !== undefined;
  }
}

// Global reference for button onclick handlers
let quizSession;

// Initialize the quiz session when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  quizSession = new QuizSession(unit);
});
</script>

<style>
.option-button:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}

.option-button:disabled {
  cursor: not-allowed;
  opacity: 0.6;
}
</style>