---
// mobile-circuit-simulator.astro
import Layout from '../layouts/Layout.astro';
---

<Layout title="ã‚¹ãƒãƒ›å¯¾å¿œè«–ç†å›è·¯ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            overflow: hidden;
            height: 100vh;
        }

        /* ãƒ¢ãƒã‚¤ãƒ«ãƒ»ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆæ™‚ã¯Layoutã¨å”èª¿ï¼ˆã‚¿ãƒƒãƒãƒ‡ãƒã‚¤ã‚¹åˆ¤å®šï¼‰ */
        @media (max-width: 1024px) and (hover: none) and (pointer: coarse) {
            html, body {
                margin: 0;
                padding: 0;
                height: 100vh;
                width: 100vw;
                overflow: hidden;
            }
        }

        .app-container {
            display: flex;
            height: 100vh;
            width: 100vw;
            position: relative;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* éƒ¨å“ãƒ‘ãƒ¬ãƒƒãƒˆ */
        .component-palette {
            width: 280px;
            background: white;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
            z-index: 1000;
        }

        .palette-header {
            padding: 12px;
            border-bottom: 1px solid #eee;
            background: #fafafa;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .palette-title {
            font-weight: bold;
            font-size: 14px;
        }


        .palette-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .component-category {
            margin-bottom: 16px;
        }

        .category-title {
            font-size: 12px;
            font-weight: bold;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .component-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .component-item {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .component-item:hover {
            border-color: #2196f3;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2);
        }

        .component-icon {
            font-size: 20px;
            margin-bottom: 4px;
        }

        .component-icon-canvas {
            margin-bottom: 4px;
            background: transparent;
        }

        .component-name {
            font-size: 10px;
            color: #666;
            font-weight: 500;
        }

        /* ãƒ¡ã‚¤ãƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ */
        .main-canvas {
            flex: 1;
            position: relative;
            background: white;
            overflow: hidden;
        }

        .canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
            touch-action: none;
        }

        /* ãƒ¢ãƒã‚¤ãƒ«ãƒ»ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆæ™‚ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚³ãƒ³ãƒ†ãƒŠèª¿æ•´ */
        @media (max-width: 1024px) and (hover: none) and (pointer: coarse) {
            .canvas-container {
                padding: 0 !important;
                margin: 0 !important;
                position: relative;
            }
        }

        #circuit-canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 10px 10px, #ddd 1px, transparent 1px),
                radial-gradient(circle at 30px 30px, #ddd 1px, transparent 1px);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
        }

        /* ãƒ¢ãƒã‚¤ãƒ«ãƒ»ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆæ™‚ã®ã‚­ãƒ£ãƒ³ãƒã‚¹è¦ç´ èª¿æ•´ */
        @media (max-width: 1024px) and (hover: none) and (pointer: coarse) {
            #circuit-canvas {
                margin: 0;
                padding: 0;
                border: none;
                outline: none;
            }
        }

        /* ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ãƒ¼ */
        .file-menu-separator {
            width: 1px;
            height: 20px;
            background: #ddd;
            margin: 0 8px;
            align-self: center;
        }

        /* ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ */
        .file-menu {
            position: fixed;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border-radius: 24px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            display: flex;
            padding: 4px;
            z-index: 1000;
            white-space: nowrap; /* æ”¹è¡Œã‚’é˜²ã */
        }

        .file-button {
            background: none;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            font-weight: 500;
            min-height: 36px;
            display: flex;
            align-items: center;
            gap: 4px;
            flex-shrink: 0; /* ãƒœã‚¿ãƒ³ã®ç¸®å°ã‚’é˜²ã */
        }

        .file-button:hover {
            background: #f5f5f5;
        }

        /* PCãƒ»ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—å¯¾å¿œï¼ˆæ˜ç¤ºçš„ã«æ­£å¸¸ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆä¿è¨¼ï¼‰ */
        @media (min-width: 769px) {
            .component-palette {
                position: relative !important;
                transform: none !important;
                width: 280px !important;
                height: auto !important;
                flex-direction: column !important;
                box-shadow: none !important;
            }
            
            .component-grid {
                grid-template-columns: repeat(3, 1fr) !important;
                display: grid !important;
            }
            
            .palette-content {
                flex-direction: column !important;
                overflow-x: visible !important;
                overflow-y: auto !important;
            }
            
            .palette-overlay {
                display: none !important;
            }
            
            .main-canvas {
                width: calc(100vw - 280px) !important;
            }
            
            .canvas-container {
                width: 100% !important;
                height: 100% !important;
            }
        }

        /* ãƒ¢ãƒã‚¤ãƒ«ãƒ»ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆå¯¾å¿œ - ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ä¸‹ã«é…ç½® */
        @media (max-width: 1024px) and (hover: none) and (pointer: coarse) {
            .component-palette {
                position: fixed;
                left: 0;
                right: 0;
                top: 4rem; /* ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼ã®é«˜ã•åˆ†ä¸‹ã’ã‚‹ */
                bottom: auto;
                height: 120px;
                width: 100%;
                transform: none;
                flex-direction: row;
                overflow-x: auto;
                overflow-y: hidden;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                z-index: 1000;
                background: white;
            }

            .palette-header {
                display: none; /* ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’éè¡¨ç¤º */
            }

            .palette-content {
                display: flex;
                flex-direction: row;
                overflow-x: auto;
                overflow-y: hidden;
                padding: 16px 8px;
                -webkit-overflow-scrolling: touch; /* iOS ã§ã®æ…£æ€§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’æœ‰åŠ¹åŒ– */
                scrollbar-width: thin; /* Firefox ã§ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼å¹… */
                white-space: nowrap;
                align-items: flex-start;
                height: 100%;
                gap: 0;
            }

            .component-category {
                display: inline-flex; /* ã‚«ãƒ†ã‚´ãƒªã‚’æ¨ªä¸¦ã³ã« */
                flex-direction: row;
                align-items: center;
                margin-right: 0;
            }

            .category-title {
                display: none; /* ã‚¹ãƒãƒ›ã§ã¯éè¡¨ç¤º */
            }

            .component-grid {
                display: flex !important; /* ã‚°ãƒªãƒƒãƒ‰ã‚’æ¨ªä¸¦ã³flexåŒ– */
                flex-direction: row !important;
                gap: 8px;
                margin: 0;
                padding: 0;
                grid-template-columns: none !important; /* ã‚°ãƒªãƒƒãƒ‰è¨­å®šã‚’ç„¡åŠ¹åŒ– */
            }

            .component-item {
                display: flex !important;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                flex-shrink: 0;
                width: 70px;
                height: 80px;
                margin-right: 8px;
                padding: 8px 4px;
            }

            .component-item:last-child {
                margin-right: 0;
            }
        }

        /* ã‚¹ãƒãƒ›ãƒ»ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆæ¨ªç”»é¢å¯¾å¿œ */
        @media (max-width: 1024px) and (hover: none) and (pointer: coarse) and (orientation: landscape) {
            .component-palette {
                position: fixed;
                left: 0;
                right: 0;
                top: 4rem; /* ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼ã®é«˜ã•åˆ†ä¸‹ã’ã‚‹ */
                bottom: auto;
                height: 100px;
                width: 100%;
                transform: none;
                flex-direction: row;
                overflow-x: auto;
                overflow-y: hidden;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                z-index: 1000;
            }

            .palette-header {
                display: none; /* ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’éè¡¨ç¤º */
            }

            .palette-content {
                display: flex;
                flex-direction: row;
                overflow-x: auto;
                overflow-y: hidden;
                padding: 16px 8px;
                -webkit-overflow-scrolling: touch; /* iOS ã§ã®æ…£æ€§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’æœ‰åŠ¹åŒ– */
                scrollbar-width: thin; /* Firefox ã§ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼å¹… */
                white-space: nowrap;
                align-items: flex-start;
                height: 100%;
                gap: 0;
            }

            .component-category {
                display: inline-flex; /* ã‚«ãƒ†ã‚´ãƒªã‚’æ¨ªä¸¦ã³ã« */
                flex-direction: row;
                align-items: center;
                margin-right: 0;
            }

            .category-title {
                display: none; /* æ¨ªç”»é¢ã§ã‚‚éè¡¨ç¤º */
            }

            .component-grid {
                display: flex !important; /* ã‚°ãƒªãƒƒãƒ‰ã‚’æ¨ªä¸¦ã³flexåŒ– */
                flex-direction: row !important;
                gap: 6px;
                margin: 0;
                padding: 0;
                grid-template-columns: none !important; /* ã‚°ãƒªãƒƒãƒ‰è¨­å®šã‚’ç„¡åŠ¹åŒ– */
            }

            .component-item {
                display: flex !important;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                flex-shrink: 0;
                width: 60px;
                height: 64px;
                margin-right: 6px;
                padding: 6px 3px;
            }

            .component-item:last-child {
                margin-right: 0;
            }
        }

        /* PCæ¨ªç”»é¢å¯¾å¿œï¼ˆå¤§ç”»é¢ã®ã¿ï¼‰ */
        @media (min-width: 769px) and (orientation: landscape) and (max-height: 600px) {
            .component-palette {
                width: 200px; /* ãƒ‘ãƒ¬ãƒƒãƒˆå¹…ã‚’ç¸®å° */
            }
            
            .component-grid {
                grid-template-columns: repeat(2, 1fr); /* 2åˆ—ã«å¤‰æ›´ */
            }
            
            .canvas-container {
                flex: 1;
                max-width: calc(100vw - 200px); /* æ¨ªç”»é¢æ™‚ã®æœ€é©åŒ– */
            }

            .file-menu {
                bottom: 8px;
                left: 8px;
                flex-direction: row;
                width: auto;
            }

            .file-menu-button {
                min-width: 44px;
                min-height: 44px;
                border-radius: 0;
            }

            .file-menu-button:first-child {
                border-radius: 8px 0 0 8px;
            }

            .file-menu-button:last-child {
                border-radius: 0 8px 8px 0;
            }

            .file-menu-button + .file-menu-button {
                border-top: none;
                border-left: 1px solid #eee;
            }
        }

        /* å¤§ç”»é¢æ¨ªç”»é¢å¯¾å¿œï¼ˆç¸¦å¹…ãŒçŸ­ã„å¤§ç”»é¢ï¼‰ */
        @media (min-width: 844px) and (orientation: landscape) and (max-height: 600px) {
            .component-palette {
                width: 240px; /* å¤§ç”»é¢ã§ã¯å°‘ã—å¹…ã‚’åºƒã */
                position: relative; /* å¤§ç”»é¢ã§ã¯å¸¸æ™‚è¡¨ç¤º */
                transform: none !important;
                box-shadow: none;
            }
            
            .component-grid {
                grid-template-columns: repeat(3, 1fr); /* 3åˆ—ã‚’ç¶­æŒ */
            }

            .main-canvas {
                width: calc(100vw - 240px);
            }


            .palette-overlay {
                display: none; /* ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ä¸è¦ */
            }


            .file-menu {
                position: fixed;
                bottom: 20px;
                left: 260px;
                flex-direction: row;
                width: auto;
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            }

            .file-menu-button {
                border-radius: 0;
            }

            .file-menu-button:first-child {
                border-radius: 12px 0 0 12px;
            }

            .file-menu-button:last-child {
                border-radius: 0 12px 12px 0;
            }

            .file-menu-button + .file-menu-button {
                border-top: none;
                border-left: 1px solid #eee;
            }
        }

        /* SafeAreaå¯¾å¿œ - ãƒ¢ãƒã‚¤ãƒ«æ™‚ã¯å®Œå…¨ç„¡åŠ¹åŒ– */
        @media (min-width: 769px) {
            @supports (padding: max(0px)) {
                .app-container {
                    padding-left: max(12px, env(safe-area-inset-left));
                    padding-right: max(12px, env(safe-area-inset-right));
                    padding-top: 0;
                    padding-bottom: 0;
                }
                
                @media (orientation: landscape) {
                    .app-container {
                        padding-left: max(20px, env(safe-area-inset-left));
                        padding-right: max(20px, env(safe-area-inset-right));
                        padding-top: 0;
                        padding-bottom: 0;
                    }
                }
            }
        }

        /* Layoutã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¨ã®å”èª¿ï¼ˆã‚¿ãƒƒãƒãƒ‡ãƒã‚¤ã‚¹ï¼‰ */
        @media (max-width: 1024px) and (hover: none) and (pointer: coarse) {
            /* main-contentã‚’å›è·¯ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ç”¨ã«èª¿æ•´ */
            .main-content {
                padding: 0 !important;
                margin: 0 !important;
                width: 100vw !important;
                height: calc(100vh - 4rem) !important; /* ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼åˆ†ã‚’å¼•ã */
                max-width: none !important;
            }
            
            /* footerã®ç„¡åŠ¹åŒ–ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰ */
            .footer {
                display: none !important;
            }
            
            /* app-containerã®èª¿æ•´ */
            .app-container {
                margin: 0 !important;
                padding: 0 !important;
                height: calc(100vh - 4rem) !important; /* ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼åˆ†ã‚’å¼•ã */
                width: 100vw !important;
                display: flex !important;
                flex-direction: column !important;
                position: relative !important;
                overflow: hidden !important;
                box-sizing: border-box !important;
            }
        }

            .component-category {
                display: flex;
                flex-direction: column;
                margin-right: 10px;
                margin-bottom: 0;
            }
            
            .component-category .category-title {
                font-size: 10px;
                margin-top: 10px;
                margin-bottom: 4px;
                text-align: center;
            }

            .component-grid {
                display: grid;
                gap: 6px;
                justify-content: center;
                margin: 0 6px;
            }
            
            /* åŸºæœ¬ã‚²ãƒ¼ãƒˆ: 6å€‹ â†’ 2Ã—3 */
            .component-category:nth-child(1) .component-grid {
                grid-template-columns: repeat(2, 60px);
            }
            
            /* å…¥å‡ºåŠ›: 4å€‹ â†’ 2Ã—2 */
            .component-category:nth-child(2) .component-grid {
                grid-template-columns: repeat(2, 60px);
            }
            
            /* ãƒ•ãƒªãƒƒãƒ—ãƒ•ãƒ­ãƒƒãƒ—: 4å€‹ â†’ 2Ã—2 */
            .component-category:nth-child(3) .component-grid {
                grid-template-columns: repeat(2, 60px);
            }

            .component-item {
                min-width: 60px;
                min-height: 50px;
                flex-shrink: 0;
            }


            /* ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚’ä¸­å¤®å³ã«é…ç½® */
            .toolbar {
                top: 50%;
                transform: translateY(-50%);
                right: 12px;
            }

            /* ãƒ¡ã‚¤ãƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ã®é«˜ã•èª¿æ•´ */
            .main-canvas {
                height: calc(100vh - 90px);
            }

            /* ãƒ‘ãƒ¬ãƒƒãƒˆãƒ˜ãƒƒãƒ€ãƒ¼ã‚’æ¨ªå‘ãç”¨ã«èª¿æ•´ */
            .palette-header {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                padding: 5px 10px;
                min-height: 30px;
                border-bottom: 1px solid #eee;
            }

            .palette-title {
                font-size: 16px;
                font-weight: bold;
            }


        .main-canvas {
            width: 100vw;
        }

        /* ãƒ¢ãƒã‚¤ãƒ«ãƒ»ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆæ™‚ã®ã‚­ãƒ£ãƒ³ãƒã‚¹èª¿æ•´ */
        @media (max-width: 1024px) and (hover: none) and (pointer: coarse) {
            .main-canvas {
                margin-top: 120px; /* éƒ¨å“ãƒ‘ãƒ¬ãƒƒãƒˆåˆ†ã®ãƒãƒ¼ã‚¸ãƒ³ */
                height: calc(100vh - 4rem - 120px); /* ãƒŠãƒ“ + ãƒ‘ãƒ¬ãƒƒãƒˆåˆ†ã‚’å¼•ã */
                padding: 0;
                flex: 1;
                width: 100vw;
                position: relative;
            }
        }

        /* ã‚¹ãƒãƒ›ãƒ»ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆæ¨ªç”»é¢æ™‚ã®ã‚­ãƒ£ãƒ³ãƒã‚¹èª¿æ•´ */
        @media (max-width: 1024px) and (hover: none) and (pointer: coarse) and (orientation: landscape) {
            .main-canvas {
                margin-top: 100px;
                height: calc(100vh - 4rem - 100px); /* ãƒŠãƒ“ + ãƒ‘ãƒ¬ãƒƒãƒˆåˆ†ã‚’å¼•ã */
                padding: 0;
            }
            
            .canvas-container {
                margin-top: -8px !important;
                top: -8px !important;
            }
        }


        /* ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®éƒ¨å“ã‚¹ã‚¿ã‚¤ãƒ« */
        .dragging-component {
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            opacity: 0.8;
            transform: scale(1.1);
        }

        /* éš ã—ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ› */
        .hidden-file-input {
            display: none;
        }
    </style>

    <!-- ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ -->
    <div class="app-container">
        
        <!-- éƒ¨å“ãƒ‘ãƒ¬ãƒƒãƒˆ -->
        <div class="component-palette" id="component-palette">
            <div class="palette-header">
                <span class="palette-title">éƒ¨å“ãƒ‘ãƒ¬ãƒƒãƒˆ</span>
            </div>
            <div class="palette-content">
                <!-- åŸºæœ¬ã‚²ãƒ¼ãƒˆ -->
                <div class="component-category">
                    <div class="category-title">åŸºæœ¬ã‚²ãƒ¼ãƒˆ</div>
                    <div class="component-grid">
                        <div class="component-item" data-type="AND">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="AND"></canvas>
                            <div class="component-name">AND</div>
                        </div>
                        <div class="component-item" data-type="OR">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="OR"></canvas>
                            <div class="component-name">OR</div>
                        </div>
                        <div class="component-item" data-type="NOT">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="NOT"></canvas>
                            <div class="component-name">NOT</div>
                        </div>
                        <div class="component-item" data-type="XOR">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="XOR"></canvas>
                            <div class="component-name">XOR</div>
                        </div>
                        <div class="component-item" data-type="NAND">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="NAND"></canvas>
                            <div class="component-name">NAND</div>
                        </div>
                        <div class="component-item" data-type="NOR">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="NOR"></canvas>
                            <div class="component-name">NOR</div>
                        </div>
                    </div>
                </div>

                <!-- å…¥å‡ºåŠ› -->
                <div class="component-category">
                    <div class="category-title">å…¥å‡ºåŠ›</div>
                    <div class="component-grid">
                        <div class="component-item" data-type="INPUT">
                            <div class="component-icon">â—¯</div>
                            <div class="component-name">å…¥åŠ›</div>
                        </div>
                        <div class="component-item" data-type="OUTPUT">
                            <div class="component-icon">â—</div>
                            <div class="component-name">å‡ºåŠ›</div>
                        </div>
                        <div class="component-item" data-type="LED">
                            <div class="component-icon">ğŸ’¡</div>
                            <div class="component-name">LED</div>
                        </div>
                        <div class="component-item" data-type="SWITCH">
                            <div class="component-icon">ğŸ”˜</div>
                            <div class="component-name">ã‚¹ã‚¤ãƒƒãƒ</div>
                        </div>
                    </div>
                </div>

                <!-- ãƒ•ãƒªãƒƒãƒ—ãƒ•ãƒ­ãƒƒãƒ— -->
                <div class="component-category">
                    <div class="category-title">ãƒ•ãƒªãƒƒãƒ—ãƒ•ãƒ­ãƒƒãƒ—</div>
                    <div class="component-grid">
                        <div class="component-item" data-type="DFF">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="DFF"></canvas>
                            <div class="component-name">D-FF</div>
                        </div>
                        <div class="component-item" data-type="JKFF">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="JKFF"></canvas>
                            <div class="component-name">JK-FF</div>
                        </div>
                        <div class="component-item" data-type="TFF">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="TFF"></canvas>
                            <div class="component-name">T-FF</div>
                        </div>
                        <div class="component-item" data-type="RSFF">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="RSFF"></canvas>
                            <div class="component-name">RS-FF</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ãƒ¡ã‚¤ãƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ -->
        <div class="main-canvas">
            <div class="canvas-container">
                <canvas id="circuit-canvas"></canvas>
            </div>
        </div>


        <!-- ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ -->
        <div class="file-menu">
            <button class="file-button" id="save-btn">ğŸ’¾ ä¿å­˜</button>
            <button class="file-button" id="load-btn">ğŸ“ èª­è¾¼</button>
            <button class="file-button" id="export-btn">ğŸ“· ç”»åƒ</button>
            <div class="file-menu-separator"></div>
            <button class="file-button" id="undo-btn" title="å…ƒã«æˆ»ã™">â†¶ æˆ»ã‚‹</button>
            <button class="file-button" id="redo-btn" title="ã‚„ã‚Šç›´ã—">â†· é€²ã‚€</button>
        </div>

        <!-- éš ã—ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ› -->
        <input type="file" class="hidden-file-input" id="file-input" accept=".json">
    </div>

    <script type="module">
        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–
        class MobileCircuitSimulator {
            constructor() {
                this.canvas = document.getElementById('circuit-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.components = new Map();
                this.connections = [];
                this.selectedComponent = null;
                this.isDragging = false;
                this.dragOffset = { x: 0, y: 0 };
                this.scale = 1;
                this.panX = 0;
                // ãƒ¢ãƒã‚¤ãƒ«ãƒ»ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆæ™‚ã¯ä¸Šéƒ¨ã®ä½™ç™½ã‚’è©°ã‚ã‚‹ãŸã‚ã€panYã‚’èª¿æ•´
                if (this.isTouchDevice()) {
                    this.panY = 20; // ä¸Šéƒ¨ã®æç”»ä½ç½®ã‚’20pxä¸‹ã’ã‚‹
                } else {
                    this.panY = 0;
                }
                this.history = [];
                this.historyIndex = -1;
                this.isConnecting = false;
                this.connectionStart = null;
                this.currentMousePos = { x: 0, y: 0 };
                this.isSimulating = true;
                this.simulationInterval = null;
                this.isPanning = false;
                this.lastPanPoint = null;
                this.touches = [];
                this.lastPinchDistance = null;
                this.lastPinchCenter = null;
                this.touchStartTime = 0;
                this.touchStartPos = null;
                this.dragThreshold = 10; // ãƒ”ã‚¯ã‚»ãƒ«å˜ä½ã§ã®ãƒ‰ãƒ©ãƒƒã‚°åˆ¤å®šã—ãã„å€¤
                this.selectedConnection = null;
                this.lastClickTime = 0;
                this.doubleClickDelay = 300; // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯åˆ¤å®šæ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
                this.lastClickPosition = null; // æœ€å¾Œã®ã‚¯ãƒªãƒƒã‚¯ä½ç½®
                this.overlappingComponents = []; // é‡ãªã£ãŸã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ãƒªã‚¹ãƒˆ
                
                // ãƒ‘ãƒ¬ãƒƒãƒˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯¾å¿œ
                this.isPaletteScrolling = false;
                this.paletteScrollStartX = 0;
                this.paletteScrollStartY = 0;
                this.paletteScrollThreshold = 3; // ã‚ˆã‚Šæ•æ„Ÿãªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ¤œå‡º
                this.paletteScrollStartScrollLeft = 0;
                this.pendingComponentDrag = null; // éƒ¨å“ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹å¾…æ©Ÿç”¨
                this.currentOverlapIndex = 0; // ç¾åœ¨é¸æŠä¸­ã®é‡ãªã‚Šã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
                this.nextZIndex = 1; // Z-indexç®¡ç†ç”¨ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
                this.pendingComponent = null; // ãƒ‘ãƒ¬ãƒƒãƒˆã‹ã‚‰ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®éƒ¨å“ï¼ˆã¾ã ãƒãƒƒãƒ—ã«è¿½åŠ ã•ã‚Œã¦ã„ãªã„ï¼‰
                this.dragStarted = false; // å®Ÿéš›ã®ãƒ‰ãƒ©ãƒƒã‚°ç§»å‹•ãŒé–‹å§‹ã•ã‚ŒãŸã‹ã®ãƒ•ãƒ©ã‚°
                
                this.init();
            }
            
            // ãƒ¢ãƒã‚¤ãƒ«æ¨ªç”»é¢ã®åˆ¤å®šï¼ˆiPhone 16 Pro Maxãªã©å¤§ããªç”»é¢ã«ã‚‚å¯¾å¿œï¼‰
            isMobileLandscape() {
                const isLandscape = window.matchMedia('(orientation: landscape)').matches && 
                                   window.innerWidth <= 1024 && // æ¨ªå¹…ä¸Šé™ã‚’æ‹¡å¤§
                                   window.innerHeight <= 600;   // ç¸¦å¹…ä¸Šé™ã‚’æ‹¡å¤§
                console.log('Landscape detection:', {
                    orientation: window.matchMedia('(orientation: landscape)').matches,
                    innerWidth: window.innerWidth,
                    innerHeight: window.innerHeight,
                    isLandscape: isLandscape
                });
                return isLandscape;
            }

            // ã‚¿ãƒƒãƒãƒ‡ãƒã‚¤ã‚¹ã‹ã©ã†ã‹ã‚’åˆ¤å®šï¼ˆiPhone16ProMAXã€iPadç­‰ã«å¯¾å¿œï¼‰
            isTouchDevice() {
                return window.innerWidth <= 1024 && 
                       ('ontouchstart' in window || navigator.maxTouchPoints > 0) &&
                       window.matchMedia('(hover: none) and (pointer: coarse)').matches;
            }

            init() {
                this.setupCanvas();
                this.setupEventListeners();
                this.setupPalette();
                this.setupFileHandling();
                this.drawPaletteIcons();
                this.startSimulation();
                this.render();
            }
            
            startSimulation() {
                this.simulationInterval = setInterval(() => {
                    if (this.isSimulating) {
                        this.updateSimulation();
                    }
                }, 100); // 10Hzã§ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
            }

            setupCanvas() {
                this.resizeCanvas = () => {
                    const container = this.canvas.parentElement;
                    const dpr = window.devicePixelRatio || 1;
                    
                    this.canvas.width = container.clientWidth * dpr;
                    this.canvas.height = container.clientHeight * dpr;
                    this.canvas.style.width = container.clientWidth + 'px';
                    this.canvas.style.height = container.clientHeight + 'px';
                    
                    this.ctx.scale(dpr, dpr);
                    this.render();
                };

                // ç”»é¢å‘ãå¤‰æ›´ã¨ãƒªã‚µã‚¤ã‚ºã‚¤ãƒ™ãƒ³ãƒˆã®å‡¦ç†
                const handleOrientationChange = () => {
                    const isDesktop = window.innerWidth > 768;
                    if (isDesktop) {
                        // PCç’°å¢ƒã§ã¯ã‚¯ãƒ©ã‚¹ç®¡ç†ã®ã¿ã‚¹ã‚­ãƒƒãƒ—ã€ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒªã‚µã‚¤ã‚ºã¯å®Ÿè¡Œ
                        document.body.classList.remove('landscape', 'large-landscape');
                        setTimeout(() => {
                            this.resizeCanvas();
                        }, 100);
                        return;
                    }
                    
                    const isLandscape = window.innerWidth > window.innerHeight;
                    const isShortHeight = window.innerHeight <= 600;
                    const isLargeScreen = window.innerWidth >= 844 && isLandscape && isShortHeight;
                    
                    // CSSã‚¯ãƒ©ã‚¹ã‚’å‹•çš„ã«ç®¡ç†ï¼ˆæ¨ªç”»é¢ã‹ã¤å¤§ç”»é¢ã®ã¿ï¼‰
                    document.body.classList.toggle('landscape', isLandscape && !isLargeScreen);
                    document.body.classList.toggle('large-landscape', isLandscape && isLargeScreen);
                    
                    // æ¨ªç”»é¢ã‹ã¤å¤§ç”»é¢æ™‚ã¯ãƒ‘ãƒ¬ãƒƒãƒˆã‚’å¸¸æ™‚è¡¨ç¤º
                    if (isLandscape && isLargeScreen) {
                        const palette = document.querySelector('.component-palette');
                        const overlay = document.querySelector('.palette-overlay');
                        if (palette) {
                            palette.classList.remove('open');
                            // ãƒ‘ãƒ¬ãƒƒãƒˆã‚’å¸¸æ™‚è¡¨ç¤ºçŠ¶æ…‹ã«ã™ã‚‹
                            palette.style.transform = 'translateX(0)';
                            palette.style.position = 'relative';
                        }
                        if (overlay) {
                            overlay.classList.remove('visible');
                        }
                    }
                    
                    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ãƒªã‚µã‚¤ã‚º
                    setTimeout(() => {
                        this.resizeCanvas();
                    }, 100);
                };

                window.addEventListener('resize', handleOrientationChange);
                window.addEventListener('orientationchange', () => {
                    setTimeout(handleOrientationChange, 100);
                });
                
                // åˆæœŸåŒ–æ™‚ã«å®Ÿè¡Œ
                handleOrientationChange();
            }

            setupEventListeners() {
                // ã‚¿ãƒƒãƒãƒ»ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
                this.canvas.addEventListener('mousedown', this.handlePointerDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handlePointerMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handlePointerUp.bind(this));
                
                // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆã‚­ãƒ£ãƒ³ãƒã‚¹å¤–ã§ã®ãƒ‰ãƒ©ãƒƒã‚°å¯¾å¿œï¼‰
                this.globalMouseMoveHandler = this.handleGlobalMouseMove.bind(this);
                this.globalMouseUpHandler = this.handleGlobalMouseUp.bind(this);
                
                this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });

                // ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ 
                this.canvas.addEventListener('wheel', this.handleWheel.bind(this), { passive: false });

                // ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ãƒœã‚¿ãƒ³ï¼ˆçµ±åˆå¾Œï¼‰
                document.getElementById('undo-btn').addEventListener('click', this.undo.bind(this));
                document.getElementById('redo-btn').addEventListener('click', this.redo.bind(this));
            }

            setupPalette() {
                const palette = document.getElementById('component-palette');
                const items = palette.querySelectorAll('.component-item');

                // ãƒ¢ãƒã‚¤ãƒ«ãƒ»ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆç”»é¢ã§ã¯çµ±ä¸€ã—ã¦ãƒ‘ãƒ¬ãƒƒãƒˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„å…¨ä½“ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å‡¦ç†
                if (this.isTouchDevice()) {
                    const paletteContent = document.querySelector('.palette-content');
                    if (paletteContent) {
                        paletteContent.addEventListener('touchstart', this.handlePaletteScrollStart.bind(this), { passive: false });
                        paletteContent.addEventListener('touchmove', this.handlePaletteScrollMove.bind(this), { passive: false });
                        paletteContent.addEventListener('touchend', this.handlePaletteScrollEnd.bind(this), { passive: false });
                    }
                } else {
                    // PCç”»é¢ã§ã¯å¾“æ¥é€šã‚Š
                    items.forEach(item => {
                        item.addEventListener('mousedown', this.startComponentDrag.bind(this));
                        item.addEventListener('touchstart', this.startComponentDrag.bind(this), { passive: false });
                    });
                }
            }

            setupFileHandling() {
                document.getElementById('save-btn').addEventListener('click', this.saveCircuit.bind(this));
                document.getElementById('load-btn').addEventListener('click', this.loadCircuit.bind(this));
                document.getElementById('export-btn').addEventListener('click', this.exportImage.bind(this));
                document.getElementById('file-input').addEventListener('change', this.handleFileLoad.bind(this));
            }

            getPointerPos(event) {
                const rect = this.canvas.getBoundingClientRect();
                let clientX, clientY;
                
                // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã‹ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆã‹ã‚’åˆ¤å®š
                if (event.touches && event.touches.length > 0) {
                    // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆ
                    clientX = event.touches[0].clientX;
                    clientY = event.touches[0].clientY;
                } else if (event.changedTouches && event.changedTouches.length > 0) {
                    // ã‚¿ãƒƒãƒã‚¨ãƒ³ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆ
                    clientX = event.changedTouches[0].clientX;
                    clientY = event.changedTouches[0].clientY;
                } else {
                    // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆ
                    clientX = event.clientX;
                    clientY = event.clientY;
                }
                
                // ã‚­ãƒ£ãƒ³ãƒã‚¹å¤–ã§ã‚‚ãƒ‰ãƒ©ãƒƒã‚°ã§ãã‚‹ã‚ˆã†ã«åº§æ¨™å¤‰æ›
                return {
                    x: (clientX - rect.left - this.panX) / this.scale,
                    y: (clientY - rect.top - this.panY) / this.scale
                };
            }

            handlePointerDown(event) {
                event.preventDefault();
                console.log('PointerDown triggered, event type:', event.type);
                
                // ãƒãƒ«ãƒã‚¿ãƒƒãƒã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                if (event.touches && event.touches.length > 1) return;
                
                const pos = this.getPointerPos(event);
                this.touchStartTime = Date.now();
                this.touchStartPos = { x: pos.x, y: pos.y };
                
                // ãƒãƒ¼ãƒˆæ¥ç¶šãƒã‚§ãƒƒã‚¯
                const port = this.getPortAt(pos.x, pos.y);
                console.log('Checking for port at', pos.x, pos.y, 'found:', port ? port.type : 'none');
                if (port) {
                    console.log('Starting connection from port:', port.type);
                    // æ¥ç¶šé–‹å§‹æ™‚ã«ãƒã‚¦ã‚¹åº§æ¨™ã‚’æ›´æ–°ï¼ˆç‚¹ç·šãŒæ­£ã—ã„ä½ç½®ã‹ã‚‰å§‹ã¾ã‚‹ã‚ˆã†ã«ï¼‰
                    this.currentMousePos = pos;
                    this.startConnection(port);
                    return;
                }
                
                // éƒ¨å“é¸æŠï¼ˆå¾ªç’°é¸æŠæœ‰åŠ¹ï¼‰- æ¥ç¶šç·šã‚ˆã‚Šå„ªå…ˆ
                const component = this.getComponentAt(pos.x, pos.y, true);
                console.log('Looking for component at', pos.x, pos.y, 'found:', component ? component.type : 'none');
                if (component) {
                    // éƒ¨å“é¸æŠãƒ»ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
                    console.log('Component selected for dragging:', component.type);
                    this.selectedComponent = component;
                    this.selectedConnection = null; // éƒ¨å“é¸æŠæ™‚ã¯æ¥ç¶šç·šé¸æŠã‚’ãƒªã‚»ãƒƒãƒˆ
                    
                    // é¸æŠã•ã‚ŒãŸã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å‰é¢ã«ç§»å‹•
                    component.zIndex = this.nextZIndex++;
                    
                    this.isDragging = true;
                    this.dragOffset = {
                        x: pos.x - component.x,
                        y: pos.y - component.y
                    };
                    this.isPanning = false; // éƒ¨å“é¸æŠæ™‚ã¯ãƒ‘ãƒ³ã‚’ç„¡åŠ¹åŒ–
                    
                    // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ ï¼ˆã‚­ãƒ£ãƒ³ãƒã‚¹å¤–ã§ã®ãƒ‰ãƒ©ãƒƒã‚°å¯¾å¿œï¼‰
                    document.addEventListener('mousemove', this.globalMouseMoveHandler);
                    document.addEventListener('mouseup', this.globalMouseUpHandler);
                    return;
                }
                
                // æ¥ç¶šç·šãƒã‚§ãƒƒã‚¯ï¼ˆéƒ¨å“ãŒãªã„å ´åˆã®ã¿ï¼‰
                const connection = this.getConnectionAt(pos.x, pos.y);
                if (connection) {
                    const currentTime = Date.now();
                    
                    // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯åˆ¤å®š
                    if (this.selectedConnection === connection && 
                        currentTime - this.lastClickTime < this.doubleClickDelay) {
                        // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ï¼šæ¥ç¶šç·šã‚’å‰Šé™¤
                        this.removeConnection(connection.id);
                        this.selectedConnection = null;
                        this.render();
                        this.saveState();
                        this.updateSimulation();
                        // console.log('Connection deleted via double-click');
                        return;
                    }
                    
                    // ã‚·ãƒ³ã‚°ãƒ«ã‚¯ãƒªãƒƒã‚¯ï¼šæ¥ç¶šç·šã‚’é¸æŠ
                    this.selectedConnection = connection;
                    this.selectedComponent = null; // æ¥ç¶šç·šé¸æŠæ™‚ã¯éƒ¨å“é¸æŠã‚’ãƒªã‚»ãƒƒãƒˆ
                    this.lastClickTime = currentTime;
                    this.render();
                    return;
                }
                
                // ä½•ã‚‚é¸æŠã•ã‚Œãªã‹ã£ãŸå ´åˆã¯ãƒ‘ãƒ³é–‹å§‹
                console.log('No component or connection found, starting pan mode');
                this.selectedComponent = null;
                this.selectedConnection = null;
                this.isDragging = false;
                this.isPanning = true;
                
                // ãƒ‘ãƒ³é–‹å§‹æ™‚ã¯ç”Ÿã®åº§æ¨™ã‚’ä½¿ç”¨
                const rect = this.canvas.getBoundingClientRect();
                const rawX = event.clientX || (event.touches && event.touches[0].clientX);
                const rawY = event.clientY || (event.touches && event.touches[0].clientY);
                this.lastPanPoint = {
                    x: rawX - rect.left,
                    y: rawY - rect.top
                };
                
                this.render();
            }

            handlePointerMove(event) {
                event.preventDefault();
                
                // ãƒãƒ«ãƒã‚¿ãƒƒãƒã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                if (event.touches && event.touches.length > 1) return;
                
                const pos = this.getPointerPos(event);
                this.currentMousePos = pos;
                
                if (this.isConnecting) {
                    this.render();
                } else if (this.isDragging && this.selectedComponent) {
                    // ãƒ‘ãƒ¬ãƒƒãƒˆã‹ã‚‰ä½œæˆã•ã‚ŒãŸéƒ¨å“ã§ã€ã¾ã ãƒãƒƒãƒ—ã«è¿½åŠ ã•ã‚Œã¦ã„ãªã„å ´åˆ
                    if (this.pendingComponent && !this.dragStarted) {
                        console.log('First drag movement detected, adding component to map:', this.pendingComponent.type);
                        this.components.set(this.pendingComponent.id, this.pendingComponent);
                        this.dragStarted = true;
                        this.saveState();
                    }
                    
                    this.selectedComponent.x = pos.x - this.dragOffset.x;
                    this.selectedComponent.y = pos.y - this.dragOffset.y;
                    this.render();
                } else if (this.isPanning && this.lastPanPoint) {
                    // ãƒ‘ãƒ³å‡¦ç†ã¯ç”Ÿã®åº§æ¨™ã‚’ä½¿ç”¨
                    const rect = this.canvas.getBoundingClientRect();
                    const rawX = event.clientX || (event.touches && event.touches[0].clientX);
                    const rawY = event.clientY || (event.touches && event.touches[0].clientY);
                    const currentRawPos = {
                        x: rawX - rect.left,
                        y: rawY - rect.top
                    };
                    
                    const deltaX = currentRawPos.x - this.lastPanPoint.x;
                    const deltaY = currentRawPos.y - this.lastPanPoint.y;
                    this.panX += deltaX;
                    this.panY += deltaY;
                    
                    // æ¬¡å›ã®ãŸã‚ã«ç”Ÿã®åº§æ¨™ã‚’ä¿å­˜
                    this.lastPanPoint = currentRawPos;
                    this.render();
                }
            }

            handlePointerUp(event) {
                event.preventDefault();
                
                // ãƒ‘ãƒ¬ãƒƒãƒˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.isPaletteScrolling = false;
                
                if (this.isConnecting && this.connectionStart) {
                    const pos = this.getPointerPos(event);
                    let port = this.getPortAt(pos.x, pos.y);
                    
                    // ç«¯å­ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå†…ã§ã®ã‚¹ãƒãƒ¼ãƒˆæ¥ç¶šã‚’è©¦è¡Œ
                    if (!port) {
                        const component = this.getComponentAt(pos.x, pos.y);
                        if (component) {
                            console.log('handlePointerUp - No direct port hit, trying smart connection to:', component.type);
                            
                            // æ¥ç¶šé–‹å§‹ãŒå‡ºåŠ›ç«¯å­ã®å ´åˆã€å…¥åŠ›ç«¯å­ã‚’æ¢ã™
                            if (this.connectionStart.type === 'output') {
                                port = this.findBestInputPort(component, pos.x, pos.y);
                            }
                            // æ¥ç¶šé–‹å§‹ãŒå…¥åŠ›ç«¯å­ã®å ´åˆã€å‡ºåŠ›ç«¯å­ã‚’æ¢ã™  
                            else if (this.connectionStart.type === 'input') {
                                port = this.findBestOutputPort(component, pos.x, pos.y);
                            }
                        }
                    }
                    
                    console.log('handlePointerUp - Connection mode, found port:', port ? port.type : 'none');
                    if (port && port !== this.connectionStart) {
                        this.completeConnection(this.connectionStart, port);
                    } else {
                        console.log('handlePointerUp - No valid end port found');
                    }
                    this.cancelConnection();
                } else if (this.isDragging && this.selectedComponent) {
                    const pos = this.getPointerPos(event);
                    const touchDuration = Date.now() - this.touchStartTime;
                    const touchDistance = this.touchStartPos ? 
                        Math.sqrt(Math.pow(pos.x - this.touchStartPos.x, 2) + Math.pow(pos.y - this.touchStartPos.y, 2)) : 0;
                    
                    // ãƒ‘ãƒ¬ãƒƒãƒˆã‹ã‚‰ä½œæˆã•ã‚ŒãŸéƒ¨å“ã§ã€å®Ÿéš›ã®ãƒ‰ãƒ©ãƒƒã‚°ãŒé–‹å§‹ã•ã‚Œã¦ã„ãªã„å ´åˆ
                    if (this.pendingComponent && !this.dragStarted) {
                        console.log('Canceling pending component - no drag detected:', this.pendingComponent.type);
                        this.pendingComponent = null;
                        this.selectedComponent = null;
                        this.isDragging = false;
                        return;
                    }
                    
                    // çŸ­ã„ã‚¿ãƒƒãƒ—ã‹ã¤ç§»å‹•è·é›¢ãŒå°ã•ã„å ´åˆã¯çŠ¶æ…‹åˆ‡ã‚Šæ›¿ãˆ
                    if ((this.selectedComponent.type === 'INPUT' || this.selectedComponent.type === 'SWITCH') &&
                        touchDuration < 500 && // 500msä»¥ä¸‹
                        touchDistance < this.dragThreshold) { // 10pxä»¥ä¸‹ã®ç§»å‹•
                        this.toggleInput(this.selectedComponent);
                        // console.log('Toggle input:', this.selectedComponent.type, 'to', this.selectedComponent.state);
                    } else {
                        // ãƒ‰ãƒ©ãƒƒã‚°å®Œäº† - ã‚¨ãƒªã‚¢å¤–å‰Šé™¤åˆ¤å®š
                        const component = this.selectedComponent;
                        
                        // PCç’°å¢ƒã¨ãƒ¢ãƒã‚¤ãƒ«ç’°å¢ƒã§ç•°ãªã‚‹å‰Šé™¤åˆ¤å®šã‚’ä½¿ç”¨
                        const isDesktop = window.innerWidth > 768;
                        let shouldDelete = false;
                        
                        if (isDesktop) {
                            // PCç’°å¢ƒï¼šã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ã§ã‚­ãƒ£ãƒ³ãƒã‚¹é ˜åŸŸå¤–ã‹ã©ã†ã‹ã‚’åˆ¤å®š
                            const rect = this.canvas.getBoundingClientRect();
                            const screenX = component.x * this.scale + this.panX;
                            const screenY = component.y * this.scale + this.panY;
                            const screenWidth = component.width * this.scale;
                            const screenHeight = component.height * this.scale;
                            
                            // PCç’°å¢ƒã§ã¯ã€å·¦å´ã«ãƒ‘ãƒ¬ãƒƒãƒˆï¼ˆãƒ‘ãƒ¬ãƒƒãƒˆãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ã¦ã‚‚ãƒãƒ¼ã‚¸ãƒ³ã‚’è€ƒæ…®ï¼‰
                            const leftMargin = 0; // ã‚­ãƒ£ãƒ³ãƒã‚¹é ˜åŸŸã¯æ—¢ã«ãƒ‘ãƒ¬ãƒƒãƒˆåˆ†ãŒé™¤å¤–ã•ã‚Œã¦ã„ã‚‹
                            const deleteThreshold = 50; // å‰Šé™¤åˆ¤å®šã®ãƒãƒ¼ã‚¸ãƒ³ï¼ˆ50pxï¼‰
                            
                            console.log('PC deletion check:', {
                                componentType: component.type,
                                isNewFromPalette: component.isNewFromPalette,
                                screenPos: { x: screenX, y: screenY },
                                screenSize: { w: screenWidth, h: screenHeight },
                                canvasSize: { w: rect.width, h: rect.height },
                                deleteThreshold
                            });
                            
                            shouldDelete = !component.isNewFromPalette && (
                                screenX + screenWidth < -deleteThreshold || 
                                screenX > rect.width + deleteThreshold || 
                                screenY + screenHeight < -deleteThreshold || 
                                screenY > rect.height + deleteThreshold
                            );
                        } else {
                            // ãƒ¢ãƒã‚¤ãƒ«ç’°å¢ƒï¼šå¾“æ¥ã®ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ç³»ã§ã®åˆ¤å®š
                            const visibleLeft = -this.panX / this.scale;
                            const visibleTop = -this.panY / this.scale;
                            const visibleRight = (this.canvas.clientWidth - this.panX) / this.scale;
                            const visibleBottom = (this.canvas.clientHeight - this.panY) / this.scale;
                            
                            shouldDelete = !component.isNewFromPalette && (
                                component.x + component.width < visibleLeft || 
                                component.x > visibleRight || 
                                component.y + component.height < visibleTop || 
                                component.y > visibleBottom
                            );
                        }
                        
                        // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¨ãƒªã‚¢å¤–ã«å®Œå…¨ã«å‡ºãŸå ´åˆã¯å‰Šé™¤
                        if (shouldDelete) {
                            
                            console.log('Component dragged outside canvas, deleting:', component.type);
                            
                            // å‰Šé™¤ã™ã‚‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«æ¥ç¶šã•ã‚ŒãŸæ¥ç¶šç·šã‚’ã™ã¹ã¦å‰Šé™¤
                            const connectionsToDelete = this.connections.filter(connection => 
                                connection.from.component.id === component.id || 
                                connection.to.component.id === component.id
                            );
                            
                            connectionsToDelete.forEach(connection => {
                                this.removeConnection(connection.id);
                            });
                            
                            // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å‰Šé™¤
                            this.components.delete(component.id);
                            this.selectedComponent = null;
                            this.render();
                            this.saveState();
                            this.updateSimulation();
                        } else {
                            // é€šå¸¸ã®ãƒ‰ãƒ©ãƒƒã‚°å®Œäº†
                            // ãƒ‘ãƒ¬ãƒƒãƒˆã‹ã‚‰ä½œæˆã•ã‚ŒãŸãƒ•ãƒ©ã‚°ã‚’ã‚¯ãƒªã‚¢
                            if (component.isNewFromPalette) {
                                component.isNewFromPalette = false;
                                console.log('Component placed from palette:', component.type);
                                console.log('Component position:', component.x, component.y);
                                console.log('Component added to map, total components:', this.components.size);
                            }
                            this.saveState();
                            // console.log('Drag completed for:', this.selectedComponent.type);
                        }
                    }
                    
                    this.isDragging = false;
                    this.pendingComponent = null;
                    
                    // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
                    if (this.globalMouseMoveHandler) {
                        document.removeEventListener('mousemove', this.globalMouseMoveHandler);
                        document.removeEventListener('mouseup', this.globalMouseUpHandler);
                    }
                } else if (this.isPanning) {
                    this.isPanning = false;
                    this.lastPanPoint = null;
                }
                
                // çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.touchStartTime = 0;
                this.touchStartPos = null;
            }

            handleWheel(event) {
                event.preventDefault();
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                
                const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.max(0.1, Math.min(3, this.scale * zoomFactor));
                
                // ã‚ºãƒ¼ãƒ ä¸­å¿ƒã‚’èª¿æ•´
                this.panX = mouseX - (mouseX - this.panX) * (newScale / this.scale);
                this.panY = mouseY - (mouseY - this.panY) * (newScale / this.scale);
                
                this.scale = newScale;
                this.render();
            }

            startComponentDrag(event) {
                event.preventDefault();
                console.log('startComponentDrag called with type:', event.currentTarget.dataset.type);
                
                // æ¨ªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ã¯ã€å³åº§ã«ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ã›ãšã€ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åˆ¤å®šã‚’å¾…ã¤
                const isLandscape = this.isMobileLandscape();
                console.log('isLandscape:', isLandscape);
                
                if (isLandscape) {
                    // æ¨ªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šéƒ¨å“ãƒ‰ãƒ©ãƒƒã‚°ã‚’ä¿ç•™ã—ã¦ã€ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åˆ¤å®šã«å§”ã­ã‚‹
                    // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                    console.log('startComponentDrag: resetting isPaletteScrolling from', this.isPaletteScrolling, 'to false');
                    this.isPaletteScrolling = false;
                    this.pendingComponentDrag = {
                        type: event.currentTarget.dataset.type,
                        event: event
                    };
                    console.log('pendingComponentDrag set to:', this.pendingComponentDrag);
                    return;
                }
                
                // ç¸¦ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šå¾“æ¥é€šã‚Šã®å‡¦ç†
                this.isPaletteScrolling = false;
                const type = event.currentTarget.dataset.type;
                
                // ãƒ‘ãƒ¬ãƒƒãƒˆã‚¢ã‚¤ãƒ†ãƒ ã®å ´åˆã¯ã€é©åˆ‡ãªã‚­ãƒ£ãƒ³ãƒã‚¹åº§æ¨™ã«éƒ¨å“ã‚’ä½œæˆ
                let x, y;
                const canvasRect = this.canvas.getBoundingClientRect();
                
                if (event.type === 'touchstart' && event.touches && event.touches.length > 0) {
                    // ã‚¿ãƒƒãƒã®å ´åˆ
                    const touch = event.touches[0];
                    console.log('Touch position:', touch.clientX, touch.clientY);
                    console.log('Canvas rect:', canvasRect);
                    
                    // ã‚¿ãƒƒãƒä½ç½®ãŒã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆæ¨ªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ã¯ãƒ‘ãƒ¬ãƒƒãƒˆé ˜åŸŸã‚’é™¤å¤–ï¼‰
                    let isWithinCanvas = false;
                    const isLandscape = this.isMobileLandscape();
                    
                    if (isLandscape) {
                        // æ¨ªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šãƒ‘ãƒ¬ãƒƒãƒˆé ˜åŸŸï¼ˆä¸‹éƒ¨140pxï¼‰ã‚’é™¤å¤–
                        isWithinCanvas = touch.clientX >= canvasRect.left && touch.clientX <= canvasRect.right &&
                                       touch.clientY >= canvasRect.top && touch.clientY <= (canvasRect.bottom - 140);
                    } else {
                        // ç¸¦ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šé€šå¸¸ã®åˆ¤å®š
                        isWithinCanvas = touch.clientX >= canvasRect.left && touch.clientX <= canvasRect.right &&
                                       touch.clientY >= canvasRect.top && touch.clientY <= canvasRect.bottom;
                    }
                    
                    if (isWithinCanvas) {
                        // ã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã®å ´åˆã€ãã®åº§æ¨™ã‚’ä½¿ç”¨
                        x = (touch.clientX - canvasRect.left - this.panX) / this.scale;
                        y = (touch.clientY - canvasRect.top - this.panY) / this.scale;
                        console.log('Touch within canvas, using touch position:', x, y);
                    } else {
                        // ã‚­ãƒ£ãƒ³ãƒã‚¹å¤–ï¼ˆãƒ‘ãƒ¬ãƒƒãƒˆï¼‰ã®å ´åˆã€ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸­å¤®ã«é…ç½®
                        if (isLandscape) {
                            // æ¨ªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šãƒ‘ãƒ¬ãƒƒãƒˆé ˜åŸŸã‚’é™¤ã„ãŸã‚­ãƒ£ãƒ³ãƒã‚¹ä¸­å¤®
                            x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                            y = ((this.canvas.clientHeight - 140) / 2 - this.panY) / this.scale;
                        } else {
                            // ç¸¦ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šé€šå¸¸ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸­å¤®
                            x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                            y = (this.canvas.clientHeight / 2 - this.panY) / this.scale;
                        }
                        console.log('Touch outside canvas (palette), using center:', x, y);
                    }
                } else {
                    // ãƒã‚¦ã‚¹ã®å ´åˆã‚‚åŒæ§˜ã®å‡¦ç†
                    x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                    y = (this.canvas.clientHeight / 2 - this.panY) / this.scale;
                    console.log('Mouse event, using center:', x, y);
                }
                
                const component = this.createComponent(type, x, y);
                component.isNewFromPalette = true; // ãƒ‘ãƒ¬ãƒƒãƒˆã‹ã‚‰ä½œæˆã•ã‚ŒãŸã“ã¨ã‚’è¨˜éŒ²
                
                // é‡è¦ï¼šã¾ã ãƒãƒƒãƒ—ã«ã¯è¿½åŠ ã›ãšã€ä¸€æ™‚çš„ã«ä¿æŒ
                this.pendingComponent = component;
                this.selectedComponent = component;
                this.isDragging = true;
                this.dragOffset = { x: 0, y: 0 };
                this.dragStarted = false; // å®Ÿéš›ã®ãƒ‰ãƒ©ãƒƒã‚°ãŒé–‹å§‹ã•ã‚ŒãŸã‹ã®ãƒ•ãƒ©ã‚°
                
                // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
                if (event.type === 'touchstart') {
                    this.setupGlobalTouchHandlers();
                }
                
                // ã¾ã æç”»ã¯ã—ãªã„ï¼ˆéƒ¨å“ã¯è¡¨ç¤ºã•ã‚Œãªã„ï¼‰
                console.log('Component prepared for drag, not yet visible:', component.type);
            }
            
            setupGlobalTouchHandlers() {
                // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚¿ãƒƒãƒãƒ ãƒ¼ãƒ–ã¨ã‚¿ãƒƒãƒã‚¨ãƒ³ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ 
                const handleGlobalTouchMove = (event) => {
                    if (this.isDragging) {
                        event.preventDefault();
                        this.handlePointerMove(event);
                    }
                };
                
                const handleGlobalTouchEnd = (event) => {
                    if (this.isDragging) {
                        event.preventDefault();
                        this.handlePointerUp(event);
                    }
                    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
                    document.removeEventListener('touchmove', handleGlobalTouchMove);
                    document.removeEventListener('touchend', handleGlobalTouchEnd);
                };
                
                document.addEventListener('touchmove', handleGlobalTouchMove, { passive: false });
                document.addEventListener('touchend', handleGlobalTouchEnd, { passive: false });
            }

            createComponent(type, x, y) {
                const id = 'comp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                
                // åŸºæœ¬ã‚²ãƒ¼ãƒˆã¨ãƒ•ãƒªãƒƒãƒ—ãƒ•ãƒ­ãƒƒãƒ—ã¯ä¸€å›ã‚Šå¤§ãã
                let width = 90;
                let height = 50;
                if (['AND', 'OR', 'XOR', 'NAND', 'NOR', 'NOT'].includes(type)) {
                    width = 110;
                    height = 60;
                } else if (['DFF', 'JKFF', 'TFF', 'RSFF'].includes(type)) {
                    width = 100;
                    height = 70;
                }
                
                const baseComponent = {
                    id,
                    type,
                    x,
                    y,
                    width,
                    height,
                    inputs: [],
                    outputs: [],
                    state: false,
                    zIndex: this.nextZIndex++ // Z-indexè¨­å®š
                };

                // ã‚¿ã‚¤ãƒ—åˆ¥ã®è¨­å®š
                switch (type) {
                    case 'AND':
                    case 'OR':
                    case 'XOR':
                        baseComponent.inputs = [
                            { id: 'in1', x: 0, y: 15, connected: null },
                            { id: 'in2', x: 0, y: 45, connected: null }
                        ];
                        baseComponent.outputs = [
                            { id: 'out', x: 110, y: 30, connected: [] }
                        ];
                        break;
                    case 'NAND':
                    case 'NOR':
                        baseComponent.inputs = [
                            { id: 'in1', x: 0, y: 15, connected: null },
                            { id: 'in2', x: 0, y: 45, connected: null }
                        ];
                        baseComponent.outputs = [
                            { id: 'out', x: 110, y: 30, connected: [] }
                        ];
                        break;
                    case 'NOT':
                        baseComponent.inputs = [
                            { id: 'in', x: 0, y: 30, connected: null }
                        ];
                        baseComponent.outputs = [
                            { id: 'out', x: 110, y: 30, connected: [] }
                        ];
                        break;
                    case 'INPUT':
                    case 'SWITCH':
                        baseComponent.outputs = [
                            { id: 'out', x: 90, y: 25, connected: [] }
                        ];
                        break;
                    case 'OUTPUT':
                    case 'LED':
                        baseComponent.inputs = [
                            { id: 'in', x: 0, y: 25, connected: null }
                        ];
                        break;
                    case 'DFF':
                        baseComponent.inputs = [
                            { id: 'D', x: 0, y: 20, connected: null },
                            { id: 'CLK', x: 0, y: 50, connected: null }
                        ];
                        baseComponent.outputs = [
                            { id: 'Q', x: 100, y: 20, connected: [], state: false },
                            { id: 'Qn', x: 100, y: 50, connected: [], state: true }
                        ];
                        baseComponent.prevClk = false;
                        baseComponent.qState = false;
                        baseComponent.state = false;
                        break;
                    case 'JKFF':
                        baseComponent.inputs = [
                            { id: 'J', x: 0, y: 15, connected: null },
                            { id: 'CLK', x: 0, y: 35, connected: null },
                            { id: 'K', x: 0, y: 55, connected: null }
                        ];
                        baseComponent.outputs = [
                            { id: 'Q', x: 100, y: 20, connected: [], state: false },
                            { id: 'Qn', x: 100, y: 50, connected: [], state: true }
                        ];
                        baseComponent.prevClk = false;
                        baseComponent.qState = false;
                        baseComponent.state = false;
                        break;
                    case 'TFF':
                        baseComponent.inputs = [
                            { id: 'T', x: 0, y: 35, connected: null }
                        ];
                        baseComponent.outputs = [
                            { id: 'Q', x: 100, y: 20, connected: [], state: false },
                            { id: 'Qn', x: 100, y: 50, connected: [], state: true }
                        ];
                        baseComponent.prevT = false;
                        baseComponent.qState = false;
                        baseComponent.state = false;
                        break;
                    case 'RSFF':
                        baseComponent.inputs = [
                            { id: 'R', x: 0, y: 15, connected: null },
                            { id: 'CLK', x: 0, y: 35, connected: null },
                            { id: 'S', x: 0, y: 55, connected: null }
                        ];
                        baseComponent.outputs = [
                            { id: 'Q', x: 100, y: 20, connected: [], state: false },
                            { id: 'Qn', x: 100, y: 50, connected: [], state: true }
                        ];
                        baseComponent.prevClk = false;
                        baseComponent.qState = false;
                        baseComponent.state = false;
                        break;
                }

                return baseComponent;
            }
            
            getPortAt(x, y) {
                const tolerance = 20; // ã‚¿ãƒƒãƒæ“ä½œã«é©ã—ãŸã‚µã‚¤ã‚ºã«æ‹¡å¤§
                
                for (const component of this.components.values()) {
                    // å…¥åŠ›ãƒãƒ¼ãƒˆã‚’ãƒã‚§ãƒƒã‚¯
                    for (const port of component.inputs || []) {
                        const portX = component.x + port.x;
                        const portY = component.y + port.y;
                        if (Math.abs(x - portX) <= tolerance && Math.abs(y - portY) <= tolerance) {
                            console.log('getPortAt - Found input port at', portX, portY);
                            return { component, port, type: 'input' };
                        }
                    }
                    
                    // å‡ºåŠ›ãƒãƒ¼ãƒˆã‚’ãƒã‚§ãƒƒã‚¯
                    for (const port of component.outputs || []) {
                        const portX = component.x + port.x;
                        const portY = component.y + port.y;
                        if (Math.abs(x - portX) <= tolerance && Math.abs(y - portY) <= tolerance) {
                            console.log('getPortAt - Found output port at', portX, portY);
                            return { component, port, type: 'output' };
                        }
                    }
                }
                
                return null;
            }
            
            findBestInputPort(component, x, y) {
                if (!component.inputs || component.inputs.length === 0) return null;
                
                // æœ€ã‚‚è¿‘ã„å…¥åŠ›ç«¯å­ã‚’æ¢ã™
                let bestPort = null;
                let minDistance = Infinity;
                
                for (const port of component.inputs) {
                    const portX = component.x + port.x;
                    const portY = component.y + port.y;
                    const distance = Math.sqrt(Math.pow(x - portX, 2) + Math.pow(y - portY, 2));
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestPort = port;
                    }
                }
                
                return bestPort ? { component, port: bestPort, type: 'input' } : null;
            }
            
            findBestOutputPort(component, x, y) {
                if (!component.outputs || component.outputs.length === 0) return null;
                
                // æœ€ã‚‚è¿‘ã„å‡ºåŠ›ç«¯å­ã‚’æ¢ã™
                let bestPort = null;
                let minDistance = Infinity;
                
                for (const port of component.outputs) {
                    const portX = component.x + port.x;
                    const portY = component.y + port.y;
                    const distance = Math.sqrt(Math.pow(x - portX, 2) + Math.pow(y - portY, 2));
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestPort = port;
                    }
                }
                
                return bestPort ? { component, port: bestPort, type: 'output' } : null;
            }
            
            startConnection(portInfo) {
                this.isConnecting = true;
                this.connectionStart = portInfo;
                console.log('startConnection - Port:', portInfo.type, 'Component:', portInfo.component.type);
            }
            
            completeConnection(startPort, endPort) {
                console.log('completeConnection - Start:', startPort.type, 'End:', endPort.type);
                
                // æ¥ç¶šã®å¦¥å½“æ€§ã‚’ãƒã‚§ãƒƒã‚¯
                if (startPort.type === endPort.type) {
                    console.log('Cannot connect same type ports');
                    return; // åŒã˜ã‚¿ã‚¤ãƒ—ã¯æ¥ç¶šä¸å¯
                }
                if (startPort.component === endPort.component) {
                    console.log('Cannot connect same component');
                    return; // åŒã˜éƒ¨å“å†…ã¯æ¥ç¶šä¸å¯
                }
                
                let outputPort = startPort.type === 'output' ? startPort : endPort;
                let inputPort = startPort.type === 'input' ? startPort : endPort;
                
                // æ—¢å­˜ã®æ¥ç¶šã‚’ãƒã‚§ãƒƒã‚¯
                if (inputPort.port.connected) {
                    this.removeConnection(inputPort.port.connected);
                }
                
                // æ–°ã—ã„æ¥ç¶šã‚’ä½œæˆ
                const connection = {
                    id: 'conn_' + Date.now(),
                    from: { component: outputPort.component, port: outputPort.port },
                    to: { component: inputPort.component, port: inputPort.port }
                };
                
                console.log('Connection created:', connection.id);
                this.connections.push(connection);
                inputPort.port.connected = connection.id;
                outputPort.port.connected = outputPort.port.connected || [];
                outputPort.port.connected.push(connection.id);
                
                this.saveState();
                this.updateSimulation();
            }
            
            handleGlobalMouseMove(event) {
                if (this.isDragging && this.selectedComponent) {
                    // ã‚­ãƒ£ãƒ³ãƒã‚¹å¤–ã§ã‚‚ãƒã‚¦ã‚¹ä½ç½®ã‚’å–å¾—ã—ã¦éƒ¨å“ã‚’ç§»å‹•
                    this.handlePointerMove(event);
                }
            }
            
            handleGlobalMouseUp(event) {
                if (this.isDragging) {
                    // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
                    document.removeEventListener('mousemove', this.globalMouseMoveHandler);
                    document.removeEventListener('mouseup', this.globalMouseUpHandler);
                    
                    // é€šå¸¸ã®ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—å‡¦ç†ã‚’å®Ÿè¡Œ
                    this.handlePointerUp(event);
                }
            }
            
            cancelConnection() {
                console.log('cancelConnection - Was connecting:', this.isConnecting);
                this.isConnecting = false;
                this.connectionStart = null;
            }
            
            removeConnection(connectionId) {
                const connectionIndex = this.connections.findIndex(c => c.id === connectionId);
                if (connectionIndex === -1) return;
                
                const connection = this.connections[connectionIndex];
                
                // ãƒãƒ¼ãƒˆã‹ã‚‰æ¥ç¶šæƒ…å ±ã‚’å‰Šé™¤
                connection.to.port.connected = null;
                if (connection.from.port.connected) {
                    const index = connection.from.port.connected.indexOf(connectionId);
                    if (index > -1) {
                        connection.from.port.connected.splice(index, 1);
                    }
                }
                
                this.connections.splice(connectionIndex, 1);
            }
            
            toggleInput(component) {
                component.state = !component.state;
                // console.log('toggleInput - Component:', component.type, 'ID:', component.id, 'New state:', component.state);
                this.updateSimulation();
                this.render();
                this.saveState();
            }
            
            updateSimulation() {
                if (!this.isSimulating) return;
                
                // è¤‡æ•°å›æ›´æ–°ã—ã¦çŠ¶æ…‹ã®å®‰å®šåŒ–ã‚’å›³ã‚‹ï¼ˆãƒ•ãƒªãƒƒãƒ—ãƒ•ãƒ­ãƒƒãƒ—ã®çŠ¶æ…‹ä¼æ’­ã®ãŸã‚ï¼‰
                for (let iteration = 0; iteration < 3; iteration++) {
                    // å„éƒ¨å“ã®çŠ¶æ…‹ã‚’è¨ˆç®—
                    for (const component of this.components.values()) {
                        this.calculateComponentState(component);
                    }
                }
                
                this.render();
            }
            
            calculateComponentState(component) {
                if (component.type === 'INPUT' || component.type === 'SWITCH') {
                    // å…¥åŠ›éƒ¨å“ã¯æ‰‹å‹•ã§çŠ¶æ…‹ã‚’è¨­å®š
                    return;
                }
                
                // å…¥åŠ›å€¤ã‚’å–å¾—
                const inputs = (component.inputs || []).map(port => {
                    if (!port.connected) return false;
                    
                    const connection = this.connections.find(c => c.id === port.connected);
                    if (!connection) return false;
                    
                    // ãƒ•ãƒªãƒƒãƒ—ãƒ•ãƒ­ãƒƒãƒ—ã®å ´åˆã€ç‰¹å®šã®å‡ºåŠ›ãƒ”ãƒ³ã®çŠ¶æ…‹ã‚’å–å¾—
                    const fromComponent = connection.from.component;
                    if (['DFF', 'JKFF', 'TFF', 'RSFF'].includes(fromComponent.type)) {
                        const fromPort = connection.from.port;
                        if (fromPort.id === 'Q') {
                            return fromComponent.qState;
                        } else if (fromPort.id === 'Qn') {
                            return !fromComponent.qState;
                        }
                    }
                    
                    return connection.from.component.state || false;
                });
                
                // è«–ç†æ¼”ç®—ã‚’å®Ÿè¡Œ
                switch (component.type) {
                    case 'AND':
                        component.state = inputs.length >= 2 && inputs.every(Boolean);
                        break;
                    case 'OR':
                        component.state = inputs.some(Boolean);
                        break;
                    case 'NOT':
                        component.state = inputs.length > 0 && !inputs[0];
                        break;
                    case 'XOR':
                        component.state = inputs.length >= 2 && inputs.filter(Boolean).length === 1;
                        break;
                    case 'NAND':
                        component.state = !(inputs.length >= 2 && inputs.every(Boolean));
                        break;
                    case 'NOR':
                        component.state = !inputs.some(Boolean);
                        break;
                    case 'OUTPUT':
                    case 'LED':
                        component.state = inputs.length > 0 && inputs[0];
                        break;
                    case 'DFF':
                        this.updateDFlipFlop(component);
                        break;
                    case 'JKFF':
                        this.updateJKFlipFlop(component);
                        break;
                    case 'TFF':
                        this.updateTFlipFlop(component);
                        break;
                    case 'RSFF':
                        this.updateRSFlipFlop(component);
                        break;
                    default:
                        component.state = false;
                }
            }

            updateDFlipFlop(component) {
                const dInput = this.getInputValue(component, 'D');
                const clkInput = this.getInputValue(component, 'CLK');
                
                // ã‚¯ãƒ­ãƒƒã‚¯ã®ç«‹ã¡ä¸ŠãŒã‚Šã‚¨ãƒƒã‚¸ã§çŠ¶æ…‹ã‚’æ›´æ–°
                if (clkInput && !component.prevClk) {
                    component.qState = dInput;
                }
                component.prevClk = clkInput;
                
                // å‡ºåŠ›ã‚’è¨­å®š
                this.setOutputValue(component, 'Q', component.qState);
                this.setOutputValue(component, 'Qn', !component.qState);
                component.state = component.qState;
            }

            updateJKFlipFlop(component) {
                const jInput = this.getInputValue(component, 'J');
                const kInput = this.getInputValue(component, 'K');
                const clkInput = this.getInputValue(component, 'CLK');
                
                // ã‚¯ãƒ­ãƒƒã‚¯ã®ç«‹ã¡ä¸ŠãŒã‚Šã‚¨ãƒƒã‚¸ã§çŠ¶æ…‹ã‚’æ›´æ–°
                if (clkInput && !component.prevClk) {
                    if (jInput && kInput) {
                        // J=1, K=1: ãƒˆã‚°ãƒ«
                        component.qState = !component.qState;
                    } else if (jInput) {
                        // J=1, K=0: ã‚»ãƒƒãƒˆ
                        component.qState = true;
                    } else if (kInput) {
                        // J=0, K=1: ãƒªã‚»ãƒƒãƒˆ
                        component.qState = false;
                    }
                    // J=0, K=0: ä¿æŒï¼ˆä½•ã‚‚ã—ãªã„ï¼‰
                }
                component.prevClk = clkInput;
                
                // å‡ºåŠ›ã‚’è¨­å®š
                this.setOutputValue(component, 'Q', component.qState);
                this.setOutputValue(component, 'Qn', !component.qState);
                component.state = component.qState;
            }

            updateTFlipFlop(component) {
                const tInput = this.getInputValue(component, 'T');
                
                // Tå…¥åŠ›ã®ç«‹ã¡ä¸ŠãŒã‚Šã‚¨ãƒƒã‚¸ã§çŠ¶æ…‹ã‚’æ›´æ–°
                if (tInput && !component.prevT) {
                    component.qState = !component.qState;
                }
                component.prevT = tInput;
                
                // å‡ºåŠ›ã‚’è¨­å®š
                this.setOutputValue(component, 'Q', component.qState);
                this.setOutputValue(component, 'Qn', !component.qState);
                component.state = component.qState;
            }

            updateRSFlipFlop(component) {
                const rInput = this.getInputValue(component, 'R');
                const sInput = this.getInputValue(component, 'S');
                const clkInput = this.getInputValue(component, 'CLK');
                
                // åŒæœŸå‹ï¼ˆã‚¯ãƒ­ãƒƒã‚¯ã‚¨ãƒƒã‚¸ï¼‰ã¨éåŒæœŸå‹ï¼ˆå³åº§ï¼‰ã®ä¸¡æ–¹ã‚’ã‚µãƒãƒ¼ãƒˆ
                let shouldUpdate = false;
                
                // ã‚¯ãƒ­ãƒƒã‚¯ä¿¡å·ãŒæ¥ç¶šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯åŒæœŸå‹ã¨ã—ã¦å‹•ä½œ
                const clkConnected = component.inputs.find(i => i.id === 'CLK')?.connected;
                if (clkConnected) {
                    // ã‚¯ãƒ­ãƒƒã‚¯ã®ç«‹ã¡ä¸ŠãŒã‚Šã‚¨ãƒƒã‚¸ã§çŠ¶æ…‹ã‚’æ›´æ–°
                    shouldUpdate = clkInput && !component.prevClk;
                    component.prevClk = clkInput;
                } else {
                    // ã‚¯ãƒ­ãƒƒã‚¯æœªæ¥ç¶šã®å ´åˆã¯éåŒæœŸå‹ã¨ã—ã¦å‹•ä½œï¼ˆå³åº§ã«æ›´æ–°ï¼‰
                    shouldUpdate = true;
                }
                
                if (shouldUpdate) {
                    if (!rInput && sInput) {
                        // R=0, S=1: ã‚»ãƒƒãƒˆ
                        component.qState = true;
                    } else if (rInput && !sInput) {
                        // R=1, S=0: ãƒªã‚»ãƒƒãƒˆ
                        component.qState = false;
                    }
                    // R=0, S=0: ä¿æŒ
                    // R=1, S=1: ä¸å®šï¼ˆé€šå¸¸ã¯ä½¿ç”¨ã—ãªã„ï¼‰
                }
                
                // å‡ºåŠ›ã‚’è¨­å®š
                this.setOutputValue(component, 'Q', component.qState);
                this.setOutputValue(component, 'Qn', !component.qState);
                component.state = component.qState;
            }

            getInputValue(component, inputId) {
                const input = component.inputs?.find(i => i.id === inputId);
                if (!input?.connected) return false;
                
                const connection = this.connections.find(conn => 
                    conn.to.component === component && conn.to.port === input
                );
                
                if (!connection) return false;
                
                // ãƒ•ãƒªãƒƒãƒ—ãƒ•ãƒ­ãƒƒãƒ—ã®å ´åˆã€ç‰¹å®šã®å‡ºåŠ›ãƒ”ãƒ³ã®çŠ¶æ…‹ã‚’å–å¾—
                const fromComponent = connection.from.component;
                if (['DFF', 'JKFF', 'TFF', 'RSFF'].includes(fromComponent.type)) {
                    const fromPort = connection.from.port;
                    if (fromPort.id === 'Q') {
                        return fromComponent.qState;
                    } else if (fromPort.id === 'Qn') {
                        return !fromComponent.qState;
                    }
                }
                
                return connection.from.component.state || false;
            }

            setOutputValue(component, outputId, value) {
                const output = component.outputs?.find(o => o.id === outputId);
                if (output) {
                    output.state = value;
                    // æ¥ç¶šã•ã‚ŒãŸã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«çŠ¶æ…‹ã‚’ä¼æ’­
                    if (output.connected && output.connected.length > 0) {
                        output.connected.forEach(connectedPort => {
                            if (connectedPort.component) {
                                // æ¥ç¶šå…ˆã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®å…¥åŠ›çŠ¶æ…‹ã‚’æ›´æ–°
                                connectedPort.state = value;
                            }
                        });
                    }
                }
            }

            getComponentAt(x, y, cycleSelection = false) {
                // æŒ‡å®šä½ç½®ã®å…¨ã¦ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å–å¾—ï¼ˆZ-indexé™é †ã§ã‚½ãƒ¼ãƒˆï¼‰
                const componentsAtPosition = [];
                for (const component of this.components.values()) {
                    if (x >= component.x && x <= component.x + component.width &&
                        y >= component.y && y <= component.y + component.height) {
                        componentsAtPosition.push(component);
                    }
                }
                
                // Z-indexã§é™é †ã‚½ãƒ¼ãƒˆï¼ˆæœ€å‰é¢ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒæœ€åˆã«æ¥ã‚‹ï¼‰
                componentsAtPosition.sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0));
                
                if (componentsAtPosition.length === 0) {
                    // console.log('No component found at', x, y);
                    this.overlappingComponents = [];
                    this.currentOverlapIndex = 0;
                    this.lastClickPosition = null;
                    return null;
                }
                
                if (componentsAtPosition.length === 1) {
                    // é‡ãªã‚Šãªã—
                    return componentsAtPosition[0];
                }
                
                // é‡ãªã‚Šã‚ã‚Š - å¾ªç’°é¸æŠã®å‡¦ç†
                const clickThreshold = 20; // åŒã˜ä½ç½®åˆ¤å®šã®è¨±å®¹ç¯„å›²
                const isSamePosition = this.lastClickPosition && 
                    Math.abs(x - this.lastClickPosition.x) < clickThreshold &&
                    Math.abs(y - this.lastClickPosition.y) < clickThreshold;
                
                if (cycleSelection && isSamePosition && 
                    JSON.stringify(this.overlappingComponents.map(c => c.id)) === 
                    JSON.stringify(componentsAtPosition.map(c => c.id))) {
                    // åŒã˜ä½ç½®ã§ã®é€£ç¶šã‚¯ãƒªãƒƒã‚¯ - æ¬¡ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’é¸æŠ
                    this.currentOverlapIndex = (this.currentOverlapIndex + 1) % componentsAtPosition.length;
                } else {
                    // æ–°ã—ã„ä½ç½®ã¾ãŸã¯åˆå› - æœ€åˆã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’é¸æŠ
                    this.overlappingComponents = componentsAtPosition;
                    this.currentOverlapIndex = 0;
                }
                
                this.lastClickPosition = { x, y };
                
                const selectedComponent = componentsAtPosition[this.currentOverlapIndex];
                console.log(`Selected component ${this.currentOverlapIndex + 1}/${componentsAtPosition.length}:`, 
                           selectedComponent.type, selectedComponent.id);
                
                return selectedComponent;
            }
            
            getConnectionAt(x, y) {
                const tolerance = 30; // æ¥ç¶šç·šã®å½“ãŸã‚Šåˆ¤å®šã®è¨±å®¹ç¯„å›²ï¼ˆã•ã‚‰ã«ã‚¿ãƒƒãƒã—ã‚„ã™ãæ‹¡å¤§ï¼‰
                let closestConnection = null;
                let closestDistance = Infinity;
                
                for (const connection of this.connections) {
                    const fromX = connection.from.component.x + connection.from.port.x;
                    const fromY = connection.from.component.y + connection.from.port.y;
                    const toX = connection.to.component.x + connection.to.port.x;
                    const toY = connection.to.component.y + connection.to.port.y;
                    
                    // ãƒ™ã‚¸ã‚¨æ›²ç·šã®è©³ç´°ãªå½“ãŸã‚Šåˆ¤å®šï¼ˆã‚ˆã‚Šå¤šãã®ç‚¹ã§åˆ¤å®šï¼‰
                    const midX = (fromX + toX) / 2;
                    
                    // ãƒ™ã‚¸ã‚¨æ›²ç·šã®è¤‡æ•°ç‚¹ã§ã®å½“ãŸã‚Šåˆ¤å®š
                    const points = [];
                    for (let i = 0; i <= 20; i++) {
                        const t = i / 20;
                        // æ­£ç¢ºãªãƒ™ã‚¸ã‚¨æ›²ç·šã®è¨ˆç®—ï¼ˆ3æ¬¡ãƒ™ã‚¸ã‚¨æ›²ç·šï¼‰
                        const bezierX = Math.pow(1-t, 3) * fromX + 
                                       3 * Math.pow(1-t, 2) * t * midX + 
                                       3 * (1-t) * Math.pow(t, 2) * midX + 
                                       Math.pow(t, 3) * toX;
                        const bezierY = Math.pow(1-t, 3) * fromY + 
                                       3 * Math.pow(1-t, 2) * t * fromY + 
                                       3 * (1-t) * Math.pow(t, 2) * toY + 
                                       Math.pow(t, 3) * toY;
                        
                        points.push({ x: bezierX, y: bezierY });
                    }
                    
                    // ã“ã®æ¥ç¶šç·šã®æœ€çŸ­è·é›¢ã‚’è¨ˆç®—
                    let minDistanceForConnection = Infinity;
                    for (const point of points) {
                        const distance = Math.sqrt(Math.pow(x - point.x, 2) + Math.pow(y - point.y, 2));
                        minDistanceForConnection = Math.min(minDistanceForConnection, distance);
                    }
                    
                    // toleranceå†…ã§æœ€ã‚‚è¿‘ã„æ¥ç¶šç·šã‚’è¨˜éŒ²
                    if (minDistanceForConnection <= tolerance && minDistanceForConnection < closestDistance) {
                        closestDistance = minDistanceForConnection;
                        closestConnection = connection;
                    }
                }
                
                return closestConnection;
            }

            deleteSelected() {
                if (this.selectedComponent) {
                    // å‰Šé™¤ã™ã‚‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«æ¥ç¶šã•ã‚ŒãŸæ¥ç¶šç·šã‚’ã™ã¹ã¦å‰Šé™¤
                    const componentToDelete = this.selectedComponent;
                    const connectionsToDelete = this.connections.filter(connection => 
                        connection.from.component.id === componentToDelete.id || 
                        connection.to.component.id === componentToDelete.id
                    );
                    
                    // æ¥ç¶šç·šã‚’å‰Šé™¤
                    connectionsToDelete.forEach(connection => {
                        this.removeConnection(connection.id);
                    });
                    
                    // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å‰Šé™¤
                    this.components.delete(componentToDelete.id);
                    this.selectedComponent = null;
                    this.render();
                    this.saveState();
                    this.updateSimulation();
                } else if (this.selectedConnection) {
                    this.removeConnection(this.selectedConnection.id);
                    this.selectedConnection = null;
                    this.render();
                    this.saveState();
                    this.updateSimulation();
                }
            }

            clearAll() {
                if (confirm('ã™ã¹ã¦ã®éƒ¨å“ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
                    this.components.clear();
                    this.connections = [];
                    this.selectedComponent = null;
                    this.selectedConnection = null;
                    this.render();
                    this.saveState();
                }
            }

            saveState() {
                const state = {
                    components: Array.from(this.components.values()),
                    connections: [...this.connections]
                };
                
                this.history = this.history.slice(0, this.historyIndex + 1);
                this.history.push(JSON.stringify(state));
                this.historyIndex++;
                
                // å±¥æ­´ã®åˆ¶é™
                if (this.history.length > 50) {
                    this.history.shift();
                    this.historyIndex--;
                }
            }

            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.loadState(this.history[this.historyIndex]);
                }
            }

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.loadState(this.history[this.historyIndex]);
                }
            }

            loadState(stateStr) {
                const state = JSON.parse(stateStr);
                this.components.clear();
                
                // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å¾©å…ƒ
                state.components.forEach(comp => {
                    this.components.set(comp.id, comp);
                });
                
                // ã¾ãšå…¨ã¦ã®ãƒãƒ¼ãƒˆã®æ¥ç¶šæƒ…å ±ã‚’ã‚¯ãƒªã‚¢
                for (const component of this.components.values()) {
                    // å…¥åŠ›ãƒãƒ¼ãƒˆã®æ¥ç¶šæƒ…å ±ã‚’ã‚¯ãƒªã‚¢
                    if (component.inputs) {
                        component.inputs.forEach(port => {
                            port.connected = null;
                        });
                    }
                    // å‡ºåŠ›ãƒãƒ¼ãƒˆã®æ¥ç¶šæƒ…å ±ã‚’ã‚¯ãƒªã‚¢
                    if (component.outputs) {
                        component.outputs.forEach(port => {
                            port.connected = [];
                        });
                    }
                }
                
                // æ¥ç¶šç·šã‚’å¾©å…ƒï¼ˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå‚ç…§ã‚’å†æ§‹ç¯‰ï¼‰
                this.connections = state.connections.map(connection => {
                    const fromComponent = this.components.get(connection.from.component.id);
                    const toComponent = this.components.get(connection.to.component.id);
                    
                    if (fromComponent && toComponent) {
                        // æ­£ã—ã„ãƒãƒ¼ãƒˆå‚ç…§ã‚’å–å¾—
                        const fromPort = fromComponent.outputs?.find(p => p.id === connection.from.port.id);
                        const toPort = toComponent.inputs?.find(p => p.id === connection.to.port.id);
                        
                        if (fromPort && toPort) {
                            const restoredConnection = {
                                ...connection,
                                from: {
                                    component: fromComponent,
                                    port: fromPort
                                },
                                to: {
                                    component: toComponent,
                                    port: toPort
                                }
                            };
                            
                            // ãƒãƒ¼ãƒˆã®æ¥ç¶šæƒ…å ±ã‚‚å¾©å…ƒ
                            toPort.connected = connection.id;
                            if (!fromPort.connected) {
                                fromPort.connected = [];
                            }
                            fromPort.connected.push(connection.id);
                            
                            return restoredConnection;
                        }
                    }
                    return null; // ç„¡åŠ¹ãªæ¥ç¶šç·šã¯é™¤å¤–
                }).filter(Boolean); // null ã‚’é™¤å»
                
                this.selectedComponent = null;
                this.selectedConnection = null;
                this.render();
                this.updateSimulation();
            }


            saveCircuit() {
                // æ¥ç¶šæƒ…å ±ã‚’æ˜ç¤ºçš„ã«å«ã‚ãŸãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ä½œæˆ
                const componentsData = Array.from(this.components.values()).map(component => ({
                    ...component,
                    inputs: component.inputs ? component.inputs.map(port => ({
                        id: port.id,
                        x: port.x,
                        y: port.y,
                        connected: port.connected
                    })) : [],
                    outputs: component.outputs ? component.outputs.map(port => ({
                        id: port.id,
                        x: port.x,
                        y: port.y,
                        connected: port.connected
                    })) : []
                }));
                
                const connectionsData = this.connections.map(connection => ({
                    id: connection.id,
                    from: {
                        component: { id: connection.from.component.id },
                        port: { id: connection.from.port.id }
                    },
                    to: {
                        component: { id: connection.to.component.id },
                        port: { id: connection.to.port.id }
                    }
                }));
                
                const data = {
                    version: "1.0",
                    components: componentsData,
                    connections: connectionsData
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'circuit.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            loadCircuit() {
                document.getElementById('file-input').click();
            }

            handleFileLoad(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        this.components.clear();
                        
                        // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å¾©å…ƒ
                        data.components.forEach(comp => {
                            this.components.set(comp.id, comp);
                        });
                        
                        // ã¾ãšå…¨ã¦ã®ãƒãƒ¼ãƒˆã®æ¥ç¶šæƒ…å ±ã‚’ã‚¯ãƒªã‚¢
                        for (const component of this.components.values()) {
                            if (component.inputs) {
                                component.inputs.forEach(port => {
                                    port.connected = null;
                                });
                            }
                            if (component.outputs) {
                                component.outputs.forEach(port => {
                                    port.connected = [];
                                });
                            }
                        }
                        
                        // æ¥ç¶šç·šã‚’å¾©å…ƒï¼ˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå‚ç…§ã‚’å†æ§‹ç¯‰ï¼‰
                        this.connections = (data.connections || []).map(connection => {
                            const fromComponent = this.components.get(connection.from.component.id);
                            const toComponent = this.components.get(connection.to.component.id);
                            
                            if (fromComponent && toComponent) {
                                const fromPort = fromComponent.outputs?.find(p => p.id === connection.from.port.id);
                                const toPort = toComponent.inputs?.find(p => p.id === connection.to.port.id);
                                
                                if (fromPort && toPort) {
                                    const restoredConnection = {
                                        ...connection,
                                        from: {
                                            component: fromComponent,
                                            port: fromPort
                                        },
                                        to: {
                                            component: toComponent,
                                            port: toPort
                                        }
                                    };
                                    
                                    // ãƒãƒ¼ãƒˆã®æ¥ç¶šæƒ…å ±ã‚‚å¾©å…ƒ
                                    toPort.connected = connection.id;
                                    if (!fromPort.connected) {
                                        fromPort.connected = [];
                                    }
                                    fromPort.connected.push(connection.id);
                                    
                                    return restoredConnection;
                                }
                            }
                            return null;
                        }).filter(Boolean);
                        
                        this.selectedComponent = null;
                        this.selectedConnection = null;
                        this.render();
                        this.updateSimulation();
                        this.saveState();
                    } catch (error) {
                        alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    }
                };
                reader.readAsText(file);
            }

            exportImage() {
                const link = document.createElement('a');
                link.download = 'circuit.png';
                link.href = this.canvas.toDataURL();
                link.click();
            }

            render() {
                const ctx = this.ctx;
                const width = this.canvas.clientWidth;
                const height = this.canvas.clientHeight;
                
                // ã‚¯ãƒªã‚¢
                ctx.clearRect(0, 0, width, height);
                
                // åº§æ¨™å¤‰æ›
                ctx.save();
                ctx.translate(this.panX, this.panY);
                ctx.scale(this.scale, this.scale);
                
                // éƒ¨å“æç”»ï¼ˆZ-indexé †ï¼‰
                const sortedComponents = Array.from(this.components.values())
                    .sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0));
                for (const component of sortedComponents) {
                    this.drawComponent(ctx, component);
                }
                
                // æ¥ç¶šç·šæç”»ï¼ˆéƒ¨å“ã®ä¸Šã«è¡¨ç¤ºï¼‰
                this.drawConnections(ctx);
                
                // æ¥ç¶šä¸­ã®ç·šæç”»
                if (this.isConnecting && this.connectionStart) {
                    this.drawConnectionPreview(ctx);
                }
                
                ctx.restore();
            }

            drawComponent(ctx, component) {
                const isSelected = component === this.selectedComponent;
                const isActive = component.state;
                
                // è«–ç†å›è·¯è¨˜å·ã‚’æç”»
                this.drawLogicGateSymbol(ctx, component, isSelected, isActive);
                
                // LEDã¯è±†é›»çƒã¨ã—ã¦æç”»
                if (component.type === 'LED') {
                    const x = component.x;
                    const y = component.y;
                    const w = component.width;
                    const h = component.height;
                    
                    // æ ã®æç”»
                    let bgColor = '#ffffff';
                    if (isActive) {
                        bgColor = '#ffeb3b'; // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå‡ºåŠ›ã¯é»„è‰²
                    } else if (isSelected) {
                        bgColor = '#e3f2fd'; // é¸æŠçŠ¶æ…‹
                    }
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(x, y, w, h);
                    
                    // æ ç·š
                    ctx.strokeStyle = isSelected ? '#2196f3' : '#666666';
                    ctx.lineWidth = isSelected ? 2 : 1;
                    ctx.strokeRect(x, y, w, h);
                    
                    // è±†é›»çƒã®æç”»
                    this.drawLightBulb(ctx, x + 8, y + 8, w - 16, h - 16, isActive);
                    
                    // ãƒ©ãƒ™ãƒ«
                    ctx.fillStyle = '#333333';
                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        'LED',
                        x + w / 2,
                        y + h - 8
                    );
                }
                // OUTPUTã¯1/0è¡¨ç¤ºã€ãã®ä»–ã¯å¾“æ¥é€šã‚Š
                else if (component.type === 'OUTPUT') {
                    // èƒŒæ™¯è‰²ã¯ç™½å›ºå®š
                    let bgColor = '#ffffff';
                    if (isSelected) {
                        bgColor = '#e3f2fd'; // é¸æŠçŠ¶æ…‹
                    }
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(component.x, component.y, component.width, component.height);
                    
                    // æ ç·š
                    ctx.strokeStyle = isSelected ? '#2196f3' : '#666666';
                    ctx.lineWidth = isSelected ? 2 : 1;
                    ctx.strokeRect(component.x, component.y, component.width, component.height);
                    
                    // ä¸Šéƒ¨ã«OUTPUTãƒ©ãƒ™ãƒ«
                    ctx.fillStyle = '#666666';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        'OUTPUT',
                        component.x + component.width / 2,
                        component.y + component.height * 0.25
                    );
                    
                    // ä¸­å¤®ã«å¤§ããª1ã¾ãŸã¯0ã‚’è¡¨ç¤º
                    ctx.fillStyle = isActive ? '#4caf50' : '#f44336'; // 1ã¯ç·‘ã€0ã¯èµ¤
                    ctx.font = 'bold 24px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        isActive ? '1' : '0',
                        component.x + component.width / 2,
                        component.y + component.height * 0.65
                    );
                }
                // INPUTã¯1/0è¡¨ç¤ºã€SWITCHã¯å¾“æ¥é€šã‚Š
                else if (component.type === 'INPUT') {
                    // èƒŒæ™¯è‰²ã¯ç™½å›ºå®š
                    let bgColor = '#ffffff';
                    if (isSelected) {
                        bgColor = '#e3f2fd'; // é¸æŠçŠ¶æ…‹
                    }
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(component.x, component.y, component.width, component.height);
                    
                    // æ ç·š
                    ctx.strokeStyle = isSelected ? '#2196f3' : '#666666';
                    ctx.lineWidth = isSelected ? 2 : 1;
                    ctx.strokeRect(component.x, component.y, component.width, component.height);
                    
                    // ä¸Šéƒ¨ã«INPUTãƒ©ãƒ™ãƒ«
                    ctx.fillStyle = '#666666';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        'INPUT',
                        component.x + component.width / 2,
                        component.y + component.height * 0.25
                    );
                    
                    // ä¸­å¤®ã«å¤§ããª1ã¾ãŸã¯0ã‚’è¡¨ç¤º
                    ctx.fillStyle = isActive ? '#4caf50' : '#f44336'; // 1ã¯ç·‘ã€0ã¯èµ¤
                    ctx.font = 'bold 24px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        isActive ? '1' : '0',
                        component.x + component.width / 2,
                        component.y + component.height * 0.65
                    );
                }
                // ã‚¹ã‚¤ãƒƒãƒã¯å¾“æ¥é€šã‚Šå››è§’å½¢ã§æç”»
                else if (component.type === 'SWITCH') {
                    
                    // èƒŒæ™¯è‰²ã‚’çŠ¶æ…‹ã«å¿œã˜ã¦å¤‰æ›´
                    let bgColor = '#ffffff';
                    if (isActive) {
                        bgColor = '#4caf50'; // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå…¥åŠ›ã¯ç·‘è‰²
                    } else if (isSelected) {
                        bgColor = '#e3f2fd'; // é¸æŠçŠ¶æ…‹ã¯æœ€å¾Œã«åˆ¤å®š
                    }
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(component.x, component.y, component.width, component.height);
                    
                    // æ ç·š
                    ctx.strokeStyle = isSelected ? '#2196f3' : '#666666';
                    ctx.lineWidth = isSelected ? 2 : 1;
                    ctx.strokeRect(component.x, component.y, component.width, component.height);
                    
                    // ãƒ©ãƒ™ãƒ«
                    ctx.fillStyle = '#333333';
                    ctx.font = '14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        component.type,
                        component.x + component.width / 2,
                        component.y + component.height / 2
                    );
                }
                
                // ãƒ”ãƒ³æç”»
                // å…¥åŠ›ãƒ”ãƒ³
                component.inputs?.forEach(pin => {
                    ctx.fillStyle = pin.connected ? '#2196f3' : '#4caf50';
                    ctx.beginPath();
                    ctx.arc(component.x + pin.x, component.y + pin.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
                
                // å‡ºåŠ›ãƒ”ãƒ³
                component.outputs?.forEach(pin => {
                    ctx.fillStyle = (pin.connected && pin.connected.length > 0) ? '#2196f3' : '#ff9800';
                    ctx.beginPath();
                    ctx.arc(component.x + pin.x, component.y + pin.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
            }
            
            drawLogicGateSymbol(ctx, component, isSelected, isActive) {
                const x = component.x;
                const y = component.y;
                const w = component.width;
                const h = component.height;
                
                // è«–ç†ã‚²ãƒ¼ãƒˆã¨ãƒ•ãƒªãƒƒãƒ—ãƒ•ãƒ­ãƒƒãƒ—ä»¥å¤–ã¯ã“ã“ã§ã¯æç”»ã—ãªã„
                if (!['AND', 'OR', 'XOR', 'NAND', 'NOR', 'NOT', 'DFF', 'JKFF', 'TFF', 'RSFF'].includes(component.type)) {
                    return;
                }
                
                // è‰²è¨­å®š
                const fillColor = isSelected ? '#e3f2fd' : '#ffffff';
                const strokeColor = isSelected ? '#2196f3' : '#333333';
                const lineWidth = isSelected ? 2 : 1;
                
                // åŸºæœ¬ã‚²ãƒ¼ãƒˆã®å ´åˆã¯æ ã‚’æç”»
                if (['AND', 'OR', 'XOR', 'NAND', 'NOR', 'NOT'].includes(component.type)) {
                    // æ ã®æç”»
                    ctx.fillStyle = fillColor;
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = lineWidth;
                    ctx.fillRect(x, y, w, h);
                    ctx.strokeRect(x, y, w, h);
                    
                    // å›³å½¢ã®æç”»ï¼ˆæ ã®ä¸­ã«æç”»ï¼‰
                    ctx.fillStyle = '#ffffff'; // å›³å½¢ã¯ç™½è‰²
                    ctx.strokeStyle = '#333333'; // å›³å½¢ã®ç·šã¯æ¿ƒã„ã‚°ãƒ¬ãƒ¼
                    ctx.lineWidth = 1;
                    
                    switch (component.type) {
                        case 'AND':
                            this.drawANDGateInside(ctx, x + 8, y + 8, w - 16, h - 16);
                            this.drawGateLabel(ctx, 'AND', x, y, w, h);
                            break;
                        case 'OR':
                            this.drawORGateInside(ctx, x + 8, y + 8, w - 16, h - 16);
                            this.drawGateLabel(ctx, 'OR', x, y, w, h);
                            break;
                        case 'XOR':
                            this.drawXORGateInside(ctx, x + 8, y + 8, w - 16, h - 16);
                            this.drawGateLabel(ctx, 'XOR', x, y, w, h);
                            break;
                        case 'NAND':
                            this.drawANDGateInside(ctx, x + 8, y + 8, w - 26, h - 16);
                            this.drawNotBubble(ctx, x + w - 29, y + h/2, 4);
                            this.drawGateLabel(ctx, 'NAND', x, y, w, h);
                            break;
                        case 'NOR':
                            this.drawORGateInside(ctx, x + 8, y + 8, w - 26, h - 16);
                            this.drawNotBubble(ctx, x + w - 18, y + h/2, 4);
                            this.drawGateLabel(ctx, 'NOR', x, y, w, h);
                            break;
                        case 'NOT':
                            this.drawNOTGateInside(ctx, x + 8, y + 8, w - 26, h - 16);
                            this.drawNotBubble(ctx, x + w - 18, y + h/2, 4);
                            this.drawGateLabel(ctx, 'NOT', x, y, w, h);
                            break;
                    }
                } 
                // ãƒ•ãƒªãƒƒãƒ—ãƒ•ãƒ­ãƒƒãƒ—ã®å ´åˆ
                else if (['DFF', 'JKFF', 'TFF', 'RSFF'].includes(component.type)) {
                    switch (component.type) {
                        case 'DFF':
                            this.drawFlipFlop(ctx, x, y, w, h, 'D', component);
                            break;
                        case 'JKFF':
                            this.drawFlipFlop(ctx, x, y, w, h, 'JK', component);
                            break;
                        case 'TFF':
                            this.drawFlipFlop(ctx, x, y, w, h, 'T', component);
                            break;
                        case 'RSFF':
                            this.drawFlipFlop(ctx, x, y, w, h, 'RS', component);
                            break;
                    }
                } else {
                    // ä»–ã®éƒ¨å“ï¼ˆINPUTã€OUTPUTç­‰ï¼‰ã¯å¾“æ¥é€šã‚Š
                    ctx.fillStyle = fillColor;
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = lineWidth;
                }
            }
            
            // æ å†…æç”»ç”¨ã®ã‚²ãƒ¼ãƒˆé–¢æ•°ç¾¤
            drawANDGateInside(ctx, x, y, w, h) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + w * 0.6, y);
                ctx.arc(x + w * 0.6, y + h/2, h/2, -Math.PI/2, Math.PI/2);
                ctx.lineTo(x, y + h);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            drawORGateInside(ctx, x, y, w, h) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.quadraticCurveTo(x + w * 0.6, y, x + w, y + h/2);
                ctx.quadraticCurveTo(x + w * 0.6, y + h, x, y + h);
                ctx.quadraticCurveTo(x + w * 0.2, y + h/2, x, y);
                ctx.fill();
                ctx.stroke();
            }
            
            drawXORGateInside(ctx, x, y, w, h) {
                // å¤–å´ã®æ›²ç·š
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.quadraticCurveTo(x + w * 0.6, y, x + w, y + h/2);
                ctx.quadraticCurveTo(x + w * 0.6, y + h, x, y + h);
                ctx.quadraticCurveTo(x + w * 0.2, y + h/2, x, y);
                ctx.fill();
                ctx.stroke();
                
                // å†…å´ã®è¿½åŠ ç·š
                ctx.beginPath();
                ctx.moveTo(x - 4, y);
                ctx.quadraticCurveTo(x + w * 0.2 - 4, y + h/2, x - 4, y + h);
                ctx.stroke();
            }
            
            drawNOTGateInside(ctx, x, y, w, h) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y + h);
                ctx.lineTo(x + w, y + h/2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            drawLightBulb(ctx, x, y, w, h, isActive) {
                ctx.save();
                
                const centerX = x + w / 2;
                const centerY = y + h / 2;
                const bulbWidth = w * 0.7;
                const bulbHeight = h * 0.8;
                
                // ã‚¨ãƒ¬ã‚¬ãƒ³ãƒˆãªè±†é›»çƒã®å½¢ï¼ˆæ¶™æ»´å½¢ï¼‰
                ctx.beginPath();
                
                // ä¸Šéƒ¨ã®ä¸¸ã„éƒ¨åˆ†
                const topRadius = bulbWidth * 0.35;
                const topCenterY = centerY - bulbHeight * 0.15;
                ctx.arc(centerX, topCenterY, topRadius, 0, Math.PI, true);
                
                // ä¸‹éƒ¨ã®ã¨ãŒã£ãŸéƒ¨åˆ†ï¼ˆãƒ™ã‚¸ã‚§æ›²ç·šã§æ»‘ã‚‰ã‹ã«ï¼‰
                ctx.bezierCurveTo(
                    centerX - topRadius, topCenterY,
                    centerX - bulbWidth * 0.2, centerY + bulbHeight * 0.3,
                    centerX, centerY + bulbHeight * 0.4
                );
                ctx.bezierCurveTo(
                    centerX + bulbWidth * 0.2, centerY + bulbHeight * 0.3,
                    centerX + topRadius, topCenterY,
                    centerX + topRadius, topCenterY
                );
                
                ctx.closePath();
                
                // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœ
                if (isActive) {
                    // ç‚¹ç¯æ™‚ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                    const gradient = ctx.createRadialGradient(
                        centerX - topRadius * 0.3, topCenterY - topRadius * 0.3, 0,
                        centerX, centerY, topRadius
                    );
                    gradient.addColorStop(0, '#fffacd');
                    gradient.addColorStop(0.6, '#ffff00');
                    gradient.addColorStop(1, '#ffa500');
                    ctx.fillStyle = gradient;
                } else {
                    // æ¶ˆç¯æ™‚ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                    const gradient = ctx.createRadialGradient(
                        centerX - topRadius * 0.3, topCenterY - topRadius * 0.3, 0,
                        centerX, centerY, topRadius
                    );
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.6, '#f0f0f0');
                    gradient.addColorStop(1, '#d0d0d0');
                    ctx.fillStyle = gradient;
                }
                
                ctx.fill();
                
                // å¤–æ 
                ctx.strokeStyle = isActive ? '#cc8800' : '#999999';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // ã‚½ã‚±ãƒƒãƒˆéƒ¨åˆ†ï¼ˆä¸‹éƒ¨ã®é‡‘å±ã‚­ãƒ£ãƒƒãƒ—ï¼‰
                const socketY = centerY + bulbHeight * 0.35;
                const socketHeight = h * 0.15;
                
                ctx.fillStyle = '#b8860b';
                ctx.fillRect(centerX - bulbWidth * 0.2, socketY, bulbWidth * 0.4, socketHeight);
                
                // ã‚½ã‚±ãƒƒãƒˆã®èºæ—‹æ¨¡æ§˜
                ctx.strokeStyle = '#8b7355';
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    const lineY = socketY + (socketHeight / 4) * (i + 1);
                    ctx.beginPath();
                    ctx.moveTo(centerX - bulbWidth * 0.18, lineY);
                    ctx.lineTo(centerX + bulbWidth * 0.18, lineY);
                    ctx.stroke();
                }
                
                // ãƒ•ã‚£ãƒ©ãƒ¡ãƒ³ãƒˆï¼ˆã‚¨ãƒ¬ã‚¬ãƒ³ãƒˆãªæ›²ç·šï¼‰
                if (isActive) {
                    ctx.strokeStyle = '#ff4500';
                    ctx.lineWidth = 1.5;
                } else {
                    ctx.strokeStyle = '#aaaaaa';
                    ctx.lineWidth = 1;
                }
                
                ctx.beginPath();
                // ä¸­å¤®ã®æ”¯æŸ±
                ctx.moveTo(centerX, centerY + bulbHeight * 0.2);
                ctx.lineTo(centerX, topCenterY);
                
                // ç¾ã—ã„æ›²ç·šã®ãƒ•ã‚£ãƒ©ãƒ¡ãƒ³ãƒˆ
                ctx.moveTo(centerX - topRadius * 0.4, topCenterY - topRadius * 0.2);
                ctx.quadraticCurveTo(centerX, topCenterY - topRadius * 0.4, centerX + topRadius * 0.4, topCenterY - topRadius * 0.2);
                ctx.moveTo(centerX - topRadius * 0.3, topCenterY);
                ctx.quadraticCurveTo(centerX, topCenterY + topRadius * 0.3, centerX + topRadius * 0.3, topCenterY);
                
                ctx.stroke();
                
                // ç‚¹ç¯æ™‚ã®å…‰ã®ã‚ªãƒ¼ãƒ©
                if (isActive) {
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.15)';
                    ctx.beginPath();
                    ctx.arc(centerX, topCenterY, topRadius * 1.8, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // å…‰ã®ç·š
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI * 2) / 8;
                        const x1 = centerX + Math.cos(angle) * topRadius * 1.2;
                        const y1 = topCenterY + Math.sin(angle) * topRadius * 1.2;
                        const x2 = centerX + Math.cos(angle) * topRadius * 1.6;
                        const y2 = topCenterY + Math.sin(angle) * topRadius * 1.6;
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
            }
            
            // å¾“æ¥ã®ã‚²ãƒ¼ãƒˆé–¢æ•°ï¼ˆå¾Œæ–¹äº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰
            drawANDGate(ctx, x, y, w, h) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + w - h/2, y);
                ctx.arc(x + w - h/2, y + h/2, h/2, -Math.PI/2, Math.PI/2);
                ctx.lineTo(x, y + h);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            drawORGate(ctx, x, y, w, h) {
                ctx.beginPath();
                // å·¦å´ã®æ›²ç·š
                ctx.moveTo(x, y);
                ctx.quadraticCurveTo(x + w * 0.3, y + h/2, x, y + h);
                // å³å´ã®æ›²ç·š
                ctx.quadraticCurveTo(x + w * 0.7, y + h * 0.8, x + w, y + h/2);
                ctx.quadraticCurveTo(x + w * 0.7, y + h * 0.2, x, y);
                ctx.fill();
                ctx.stroke();
            }
            
            drawXORGate(ctx, x, y, w, h) {
                // ORã‚²ãƒ¼ãƒˆã‚’æç”»
                this.drawORGate(ctx, x + 8, y, w - 8, h);
                
                // å·¦å´ã®è¿½åŠ ç·š
                ctx.beginPath();
                ctx.moveTo(x, y + h * 0.2);
                ctx.quadraticCurveTo(x + w * 0.2, y + h/2, x, y + h * 0.8);
                ctx.stroke();
            }
            
            drawNOTGate(ctx, x, y, w, h) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y + h);
                ctx.lineTo(x + w - 10, y + h/2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // NOTãƒãƒ–ãƒ« (å³ç«¯è¿‘ãã«é…ç½®)
                this.drawNotBubble(ctx, x + w - 8, y + h/2, 3);
            }
            
            drawNOTTriangle(ctx, x, y, w, h) {
                // NOT gate triangle only (without bubble)
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y + h);
                ctx.lineTo(x + w, y + h/2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            drawNotBubble(ctx, x, y, radius = 5) {
                ctx.beginPath();
                ctx.arc(x + radius, y, radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
            }
            
            drawGateLabel(ctx, label, x, y, w, h) {
                // ãƒ†ã‚­ã‚¹ãƒˆã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š
                ctx.save();
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // ã‚²ãƒ¼ãƒˆã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦ä½ç½®ã‚’å¾®èª¿æ•´
                let centerX = x + w / 2;
                const centerY = y + h / 2 + 1; // å…¨ã¦ã®ãƒ©ãƒ™ãƒ«ã‚’1pxä¸‹ã«ç§»å‹•
                
                switch (label) {
                    case 'AND':
                        centerX = x + w / 2 - 5; // å·¦ã«5pxç§»å‹•
                        break;
                    case 'NOT':
                        centerX = x + w / 2 - 8; // å·¦ã«8pxç§»å‹•ï¼ˆã•ã‚‰ã«3pxå·¦ã¸ï¼‰
                        break;
                    case 'NAND':
                        centerX = x + w / 2 - 2; // å·¦ã«2pxç§»å‹•
                        break;
                    case 'NOR':
                        centerX = x + w / 2 - 2; // å·¦ã«2pxç§»å‹•
                        break;
                    case 'OR':
                    case 'XOR':
                        // ORã¨XORã¯ãã®ã¾ã¾ä¸­å¤®
                        break;
                }
                
                ctx.fillText(label, centerX, centerY);
                ctx.restore();
            }
            
            drawFlipFlopIcon(ctx, x, y, w, h, type) {
                // ãƒ•ãƒªãƒƒãƒ—ãƒ•ãƒ­ãƒƒãƒ—ã®åŸºæœ¬å››è§’å½¢
                ctx.fillRect(x, y, w, h);
                ctx.strokeRect(x, y, w, h);
                
                // ã‚¿ã‚¤ãƒ—ãƒ©ãƒ™ãƒ«ã‚’æç”»
                ctx.save();
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 8px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                if (type === 'JK') {
                    // JK-FFã®å ´åˆã€Jã¨Kã‚’ä¸Šä¸‹ã«åˆ†ã‘ã¦è¡¨ç¤º
                    ctx.fillText('J', x + w/2, y + h/3);
                    ctx.fillText('K', x + w/2, y + 2*h/3);
                } else if (type === 'RS') {
                    // RS-FFã®å ´åˆã€Rã¨Sã‚’ä¸Šä¸‹ã«åˆ†ã‘ã¦è¡¨ç¤º
                    ctx.fillText('R', x + w/2, y + h/3);
                    ctx.fillText('S', x + w/2, y + 2*h/3);
                } else {
                    // D-FFã€T-FFã®å ´åˆã¯ä¸­å¤®ã«è¡¨ç¤º
                    ctx.fillText(type, x + w/2, y + h/2);
                }
                
                // ã‚¯ãƒ­ãƒƒã‚¯å…¥åŠ›ã‚’ç¤ºã™å°ã•ãªä¸‰è§’å½¢ï¼ˆTFFã‚’é™¤ãï¼‰
                if (type !== 'T') {
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x - 1, y + h/2 + 2);
                    ctx.lineTo(x + 2, y + h/2);
                    ctx.lineTo(x - 1, y + h/2 - 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            drawFlipFlop(ctx, x, y, w, h, type, component) {
                // ãƒ•ãƒªãƒƒãƒ—ãƒ•ãƒ­ãƒƒãƒ—ã®åŸºæœ¬å››è§’å½¢
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(x, y, w, h);
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);
                
                // ã‚¿ã‚¤ãƒ—ãƒ©ãƒ™ãƒ«ã‚’æç”»
                ctx.save();
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                if (type === 'JK') {
                    // JK-FFã®å ´åˆã€Jã¨Kã‚’åˆ†ã‘ã¦è¡¨ç¤º
                    ctx.fillText('JK-FF', x + w/2, y + 15);
                    // å…¥åŠ›ãƒ©ãƒ™ãƒ«
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText('J', x + 5, y + 15);
                    ctx.fillText('>', x + 5, y + 35); // ã‚¯ãƒ­ãƒƒã‚¯
                    ctx.fillText('K', x + 5, y + 55);
                } else if (type === 'RS') {
                    // RS-FFã®å ´åˆã€Rã¨Sã‚’åˆ†ã‘ã¦è¡¨ç¤º
                    ctx.fillText('RS-FF', x + w/2, y + 15);
                    // å…¥åŠ›ãƒ©ãƒ™ãƒ«
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText('R', x + 5, y + 15);
                    ctx.fillText('>', x + 5, y + 35); // ã‚¯ãƒ­ãƒƒã‚¯
                    ctx.fillText('S', x + 5, y + 55);
                } else if (type === 'T') {
                    // T-FFã®å ´åˆï¼ˆã‚¯ãƒ­ãƒƒã‚¯å…¥åŠ›ãªã—ï¼‰
                    ctx.fillText(type + '-FF', x + w/2, y + 15);
                    // å…¥åŠ›ãƒ©ãƒ™ãƒ«
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(type, x + 5, y + 35);
                } else {
                    // D-FFã®å ´åˆ
                    ctx.fillText(type + '-FF', x + w/2, y + 15);
                    // å…¥åŠ›ãƒ©ãƒ™ãƒ«
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(type, x + 5, y + 20);
                    ctx.fillText('>', x + 5, y + 50); // ã‚¯ãƒ­ãƒƒã‚¯
                }
                
                // å‡ºåŠ›ãƒ©ãƒ™ãƒ«
                ctx.font = '10px Arial';
                ctx.textAlign = 'right';
                ctx.fillText('Q', x + w - 5, y + 20);
                ctx.fillText('QÌ„', x + w - 5, y + 50);
                
                // çŠ¶æ…‹è¡¨ç¤ºï¼ˆQå‡ºåŠ›ã®ç¾åœ¨å€¤ï¼‰
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = component.qState ? '#4caf50' : '#f44336';
                ctx.fillText(component.qState ? '1' : '0', x + w/2, y + h - 15);
                
                ctx.restore();
            }
            
            drawPaletteIcons() {
                const canvases = document.querySelectorAll('.component-icon-canvas');
                canvases.forEach(canvas => {
                    const ctx = canvas.getContext('2d');
                    const gateType = canvas.dataset.gate;
                    const w = canvas.width;
                    const h = canvas.height;
                    
                    // èƒŒæ™¯ã‚’ã‚¯ãƒªã‚¢
                    ctx.clearRect(0, 0, w, h);
                    
                    // ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š
                    ctx.fillStyle = '#ffffff';
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 1;
                    
                    // å°ã•ãªã‚µã‚¤ã‚ºã§æç”»
                    switch (gateType) {
                        case 'AND':
                            this.drawANDGate(ctx, 2, 2, w - 4, h - 4);
                            break;
                        case 'OR':
                            this.drawORGate(ctx, 2, 2, w - 4, h - 4);
                            break;
                        case 'XOR':
                            this.drawXORGate(ctx, 2, 2, w - 4, h - 4);
                            break;
                        case 'NAND':
                            // AND gate with space for bubble
                            this.drawANDGate(ctx, 2, 2, w - 12, h - 4);
                            // Position bubble with proper clearance
                            this.drawNotBubble(ctx, w - 9, h/2, 2.5);
                            break;
                        case 'NOR':
                            // OR gate with space for bubble  
                            this.drawORGate(ctx, 2, 2, w - 12, h - 4);
                            // Position bubble with proper clearance
                            this.drawNotBubble(ctx, w - 9, h/2, 2.5);
                            break;
                        case 'NOT':
                            // NOT triangle with space for bubble
                            this.drawNOTTriangle(ctx, 2, 2, w - 12, h - 4);
                            // Position bubble with proper clearance
                            this.drawNotBubble(ctx, w - 9, h/2, 2.5);
                            break;
                        case 'DFF':
                            this.drawFlipFlopIcon(ctx, 2, 2, w - 4, h - 4, 'D');
                            break;
                        case 'JKFF':
                            this.drawFlipFlopIcon(ctx, 2, 2, w - 4, h - 4, 'JK');
                            break;
                        case 'TFF':
                            this.drawFlipFlopIcon(ctx, 2, 2, w - 4, h - 4, 'T');
                            break;
                        case 'RSFF':
                            this.drawFlipFlopIcon(ctx, 2, 2, w - 4, h - 4, 'RS');
                            break;
                    }
                });
            }
            
            drawConnections(ctx) {
                for (const connection of this.connections) {
                    const fromX = connection.from.component.x + connection.from.port.x;
                    const fromY = connection.from.component.y + connection.from.port.y;
                    const toX = connection.to.component.x + connection.to.port.x;
                    const toY = connection.to.component.y + connection.to.port.y;
                    
                    // é¸æŠã•ã‚ŒãŸæ¥ç¶šç·šã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
                    const isSelected = this.selectedConnection === connection;
                    
                    // ç·šã®è‰²ã‚’ä¿¡å·çŠ¶æ…‹ã«å¿œã˜ã¦å¤‰æ›´
                    if (isSelected) {
                        ctx.strokeStyle = '#ff5722'; // é¸æŠæ™‚ã¯èµ¤è‰²
                        ctx.lineWidth = 6;
                    } else {
                        ctx.strokeStyle = connection.from.component.state ? '#4caf50' : '#9e9e9e';
                        ctx.lineWidth = 4;
                    }
                    
                    ctx.beginPath();
                    ctx.moveTo(fromX, fromY);
                    
                    // æ›²ç·šã§æ¥ç¶šã‚’æç”»
                    const midX = (fromX + toX) / 2;
                    ctx.bezierCurveTo(midX, fromY, midX, toY, toX, toY);
                    ctx.stroke();
                }
            }
            
            drawConnectionPreview(ctx) {
                if (!this.connectionStart) return;
                
                const startX = this.connectionStart.component.x + this.connectionStart.port.x;
                const startY = this.connectionStart.component.y + this.connectionStart.port.y;
                const endX = this.currentMousePos.x;
                const endY = this.currentMousePos.y;
                
                ctx.strokeStyle = '#ff5722';
                ctx.lineWidth = 4;
                ctx.setLineDash([8, 8]);
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                
                const midX = (startX + endX) / 2;
                ctx.bezierCurveTo(midX, startY, midX, endY, endX, endY);
                ctx.stroke();
                
                ctx.setLineDash([]);
            }
            
            handleTouchStart(event) {
                event.preventDefault();
                this.touches = Array.from(event.touches);
                
                if (this.touches.length === 1) {
                    // ã‚·ãƒ³ã‚°ãƒ«ã‚¿ãƒƒãƒã¯é€šå¸¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã¨ã—ã¦å‡¦ç†
                    this.handlePointerDown(event);
                } else if (this.touches.length === 2) {
                    // ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ é–‹å§‹
                    this.isPanning = false;
                    this.isDragging = false;
                    this.isConnecting = false;
                    this.selectedComponent = null;
                    this.selectedConnection = null;
                    this.cancelConnection();
                }
            }
            
            handleTouchMove(event) {
                event.preventDefault();
                this.touches = Array.from(event.touches);
                
                if (this.touches.length === 1) {
                    // ã‚·ãƒ³ã‚°ãƒ«ã‚¿ãƒƒãƒã¯é€šå¸¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã¨ã—ã¦å‡¦ç†
                    this.handlePointerMove(event);
                } else if (this.touches.length === 2) {
                    // ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ å‡¦ç†
                    this.handlePinchZoom(event);
                    
                    // ãƒ”ãƒ³ãƒä¸­ã¯ä»–ã®æ“ä½œã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                    this.isDragging = false;
                    this.isPanning = false;
                    this.isConnecting = false;
                    this.cancelConnection();
                }
            }
            
            handleTouchEnd(event) {
                event.preventDefault();
                this.touches = Array.from(event.touches);
                
                if (this.touches.length === 0) {
                    // ã™ã¹ã¦ã®ã‚¿ãƒƒãƒãŒçµ‚äº†
                    this.handlePointerUp(event);
                    this.lastPinchDistance = null;
                    this.lastPinchCenter = null;
                    this.isPaletteScrolling = false;
                } else if (this.touches.length === 1) {
                    // ãƒ”ãƒ³ãƒã‹ã‚‰ã‚·ãƒ³ã‚°ãƒ«ã‚¿ãƒƒãƒã«å¤‰æ›´
                    this.lastPinchDistance = null;
                    this.lastPinchCenter = null;
                }
            }
            
            handlePinchZoom(event) {
                const touch1 = this.touches[0];
                const touch2 = this.touches[1];
                
                const rect = this.canvas.getBoundingClientRect();
                const x1 = touch1.clientX - rect.left;
                const y1 = touch1.clientY - rect.top;
                const x2 = touch2.clientX - rect.left;
                const y2 = touch2.clientY - rect.top;
                
                const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const centerX = (x1 + x2) / 2;
                const centerY = (y1 + y2) / 2;
                
                if (this.lastPinchDistance && this.lastPinchCenter) {
                    // ã‚ºãƒ¼ãƒ å‡¦ç†
                    const scale = distance / this.lastPinchDistance;
                    const newScale = Math.max(0.1, Math.min(5, this.scale * scale));
                    
                    // ã‚ºãƒ¼ãƒ ä¸­å¿ƒã‚’ã‚¿ãƒƒãƒãƒã‚¤ãƒ³ãƒˆã®ä¸­ç‚¹ã«è¨­å®š
                    this.panX = centerX - (centerX - this.panX) * (newScale / this.scale);
                    this.panY = centerY - (centerY - this.panY) * (newScale / this.scale);
                    
                    this.scale = newScale;
                    
                    // ãƒ‘ãƒ³å‡¦ç†ï¼ˆãƒ”ãƒ³ãƒä¸­å¿ƒç‚¹ã®ç§»å‹•ã‚’è¿½è·¡ï¼‰
                    const centerDeltaX = centerX - this.lastPinchCenter.x;
                    const centerDeltaY = centerY - this.lastPinchCenter.y;
                    this.panX += centerDeltaX;
                    this.panY += centerDeltaY;
                    
                    this.render();
                }
                
                this.lastPinchDistance = distance;
                this.lastPinchCenter = { x: centerX, y: centerY };
            }
            
            // ãƒ‘ãƒ¬ãƒƒãƒˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å‡¦ç†
            handlePaletteScrollStart(event) {
                // ãƒ¢ãƒã‚¤ãƒ«ãƒ»ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆç”»é¢ã§ãƒ‘ãƒ¬ãƒƒãƒˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’æœ‰åŠ¹åŒ–
                if (!this.isTouchDevice()) {
                    return;
                }
                
                const touch = event.touches[0];
                this.paletteScrollStartX = touch.clientX;
                this.paletteScrollStartY = touch.clientY;
                
                // ãƒ‘ãƒ¬ãƒƒãƒˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ç¾åœ¨ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã‚’è¨˜éŒ²
                const paletteContent = document.querySelector('.palette-content');
                this.paletteScrollStartScrollLeft = paletteContent ? paletteContent.scrollLeft : 0;
                
                // å¸¸ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆéƒ¨å“ã‚¢ã‚¤ãƒ†ãƒ ã‚¿ãƒƒãƒã§ã‚‚èƒŒæ™¯ã‚¿ãƒƒãƒã§ã‚‚ï¼‰
                console.log('handlePaletteScrollStart: resetting isPaletteScrolling from', this.isPaletteScrolling, 'to false');
                this.isPaletteScrolling = false;
                
                // component-itemã§ã®ã‚¿ãƒƒãƒé–‹å§‹ã®å ´åˆã¯ã€éƒ¨å“ãƒ‰ãƒ©ãƒƒã‚°å‡¦ç†ã‚’è¨­å®š
                const componentItem = event.target.closest('.component-item');
                if (componentItem) {
                    console.log('ğŸ¯ Touch on component item:', componentItem.dataset.type);
                    this.isPaletteScrolling = false;
                    this.pendingComponentDrag = {
                        type: componentItem.dataset.type,
                        event: event
                    };
                    console.log('pendingComponentDrag set to:', this.pendingComponentDrag);
                    return;
                } else {
                    console.log('ğŸ“‹ Touch on palette background, ready for scroll');
                }
                
                event.preventDefault();
            }
            
            handlePaletteScrollMove(event) {
                // ãƒ¢ãƒã‚¤ãƒ«ãƒ»ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆç”»é¢ã§ãƒ‘ãƒ¬ãƒƒãƒˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’æœ‰åŠ¹åŒ–
                if (!this.isTouchDevice()) {
                    return;
                }
                
                // æ—¢ã«ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                if (this.isDragging) {
                    console.log('handlePaletteScrollMove: skipping because already dragging');
                    return;
                }
                
                const touch = event.touches[0];
                const deltaX = Math.abs(touch.clientX - this.paletteScrollStartX);
                const deltaY = Math.abs(touch.clientY - this.paletteScrollStartY);
                
                // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ­ã‚°
                console.log('Palette scroll move:', {
                    deltaX,
                    deltaY,
                    threshold: this.paletteScrollThreshold,
                    isScrolling: this.isPaletteScrolling,
                    targetClass: event.target.className,
                    closestItem: event.target.closest('.component-item') ? 'found' : 'none',
                    pendingComponentDrag: this.pendingComponentDrag ? 'exists' : 'null'
                });
                
                // ç§»å‹•åˆ¤å®šã®æ”¹å–„ï¼šç¸¦æ–¹å‘ã®ç§»å‹•ãŒå¤§ãã„å ´åˆã¯éƒ¨å“ãƒ‰ãƒ©ãƒƒã‚°ã‚’å„ªå…ˆ
                if (deltaX > this.paletteScrollThreshold || deltaY > this.paletteScrollThreshold) {
                    // éƒ¨å“ãƒ‰ãƒ©ãƒƒã‚°å¾…æ©Ÿä¸­ã®å ´åˆ
                    if (this.pendingComponentDrag) {
                        console.log('Evaluating movement: deltaY:', deltaY, 'deltaX:', deltaX, 'deltaY > deltaX:', deltaY > deltaX);
                        // ç¸¦æ–¹å‘ã®ç§»å‹•ãŒæ¨ªæ–¹å‘ã‚ˆã‚Šå¤§ãã„å ´åˆã¯éƒ¨å“ãƒ‰ãƒ©ãƒƒã‚°ã¨ã—ã¦åˆ¤å®š
                        if (deltaY > deltaX) {
                            console.log('ğŸ”½ Starting component drag (vertical movement), deltaY:', deltaY, 'deltaX:', deltaX);
                            this.startActualComponentDrag(this.pendingComponentDrag.type, event);
                            this.pendingComponentDrag = null;
                            return; // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å‡¦ç†ã¯å®Ÿè¡Œã—ãªã„
                        }
                        // æ¨ªæ–¹å‘ã®ç§»å‹•ãŒå¤§ããã€ç§»å‹•è·é›¢ãŒçŸ­ã„å ´åˆã¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                        else if (deltaX <= 30) { // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ¤œå‡ºç¯„å›²ã‚’æ‹¡å¤§
                            this.isPaletteScrolling = true;
                            console.log('â—€ï¸â–¶ï¸ Palette scroll activated (horizontal movement)! deltaX:', deltaX);
                            this.pendingComponentDrag = null;
                        }
                        // æ¨ªæ–¹å‘ã®ç§»å‹•ãŒå¤§ããã€ç§»å‹•è·é›¢ãŒé•·ã„å ´åˆã¯ãƒ‰ãƒ©ãƒƒã‚°
                        else {
                            console.log('ğŸ”½ Starting component drag (long horizontal movement), deltaX:', deltaX);
                            this.startActualComponentDrag(this.pendingComponentDrag.type, event);
                            this.pendingComponentDrag = null;
                            return; // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å‡¦ç†ã¯å®Ÿè¡Œã—ãªã„
                        }
                    } else {
                        console.log('No pending component drag, deltaX:', deltaX, 'deltaY:', deltaY);
                        // éƒ¨å“ãƒ‰ãƒ©ãƒƒã‚°å¾…æ©Ÿä¸­ã§ãªã„å ´åˆã§ã€æ¨ªæ–¹å‘ã®ç§»å‹•ãŒå¤§ãã„å ´åˆã¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                        if (deltaX > deltaY) {
                            this.isPaletteScrolling = true;
                            console.log('Palette scroll activated!');
                        }
                    }
                }
                
                // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä¸­ã¯å®Ÿéš›ã«ãƒ‘ãƒ¬ãƒƒãƒˆã‚’ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã•ã›ã‚‹
                if (this.isPaletteScrolling) {
                    const paletteContent = document.querySelector('.palette-content');
                    if (paletteContent) {
                        const deltaX = touch.clientX - this.paletteScrollStartX;
                        const newScrollLeft = this.paletteScrollStartScrollLeft - deltaX;
                        paletteContent.scrollLeft = Math.max(0, Math.min(newScrollLeft, paletteContent.scrollWidth - paletteContent.clientWidth));
                    }
                    event.preventDefault();
                    return;
                }
            }
            
            handlePaletteScrollEnd(event) {
                // ãƒ¢ãƒã‚¤ãƒ«ãƒ»ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆç”»é¢ã§ãƒ‘ãƒ¬ãƒƒãƒˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’æœ‰åŠ¹åŒ–
                if (!this.isTouchDevice()) {
                    return;
                }
                
                // å¾…æ©Ÿä¸­ã®éƒ¨å“ãƒ‰ãƒ©ãƒƒã‚°ã‚’ã‚¯ãƒªã‚¢
                console.log('handlePaletteScrollEnd: clearing pendingComponentDrag from', this.pendingComponentDrag ? 'exists' : 'null');
                this.isPaletteScrolling = false;
                this.pendingComponentDrag = null;
                
                event.preventDefault();
            }
            
            // éƒ¨å“ãƒ‰ãƒ©ãƒƒã‚°ã‚’å®Ÿè¡Œã™ã‚‹é–¢æ•°ï¼ˆå…ƒã®startComponentDragã®å‡¦ç†ã‚’æŠ½å‡ºï¼‰
            executeComponentDrag(type, event) {
                // ãƒ‘ãƒ¬ãƒƒãƒˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.isPaletteScrolling = false;
                
                // ãƒ‘ãƒ¬ãƒƒãƒˆã‚¢ã‚¤ãƒ†ãƒ ã®å ´åˆã¯ã€é©åˆ‡ãªã‚­ãƒ£ãƒ³ãƒã‚¹åº§æ¨™ã«éƒ¨å“ã‚’ä½œæˆ
                let x, y;
                const canvasRect = this.canvas.getBoundingClientRect();
                
                if (event.type === 'touchstart' && event.touches && event.touches.length > 0) {
                    // ã‚¿ãƒƒãƒã®å ´åˆ
                    const touch = event.touches[0];
                    console.log('Touch position:', touch.clientX, touch.clientY);
                    console.log('Canvas rect:', canvasRect);
                    
                    // ã‚¿ãƒƒãƒä½ç½®ãŒã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆæ¨ªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ã¯ãƒ‘ãƒ¬ãƒƒãƒˆé ˜åŸŸã‚’é™¤å¤–ï¼‰
                    let isWithinCanvas = false;
                    const isLandscape = this.isMobileLandscape();
                    
                    if (isLandscape) {
                        // æ¨ªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šãƒ‘ãƒ¬ãƒƒãƒˆé ˜åŸŸï¼ˆä¸‹éƒ¨140pxï¼‰ã‚’é™¤å¤–
                        isWithinCanvas = touch.clientX >= canvasRect.left && touch.clientX <= canvasRect.right &&
                                       touch.clientY >= canvasRect.top && touch.clientY <= (canvasRect.bottom - 140);
                    } else {
                        // ç¸¦ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šé€šå¸¸ã®åˆ¤å®š
                        isWithinCanvas = touch.clientX >= canvasRect.left && touch.clientX <= canvasRect.right &&
                                       touch.clientY >= canvasRect.top && touch.clientY <= canvasRect.bottom;
                    }
                    
                    if (isWithinCanvas) {
                        // ã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã®å ´åˆã€ãã®åº§æ¨™ã‚’ä½¿ç”¨
                        x = (touch.clientX - canvasRect.left - this.panX) / this.scale;
                        y = (touch.clientY - canvasRect.top - this.panY) / this.scale;
                        console.log('Touch within canvas, using touch position:', x, y);
                    } else {
                        // ã‚­ãƒ£ãƒ³ãƒã‚¹å¤–ï¼ˆãƒ‘ãƒ¬ãƒƒãƒˆï¼‰ã®å ´åˆã€ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸­å¤®ã«é…ç½®
                        if (isLandscape) {
                            // æ¨ªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šãƒ‘ãƒ¬ãƒƒãƒˆé ˜åŸŸã‚’é™¤ã„ãŸã‚­ãƒ£ãƒ³ãƒã‚¹ä¸­å¤®
                            x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                            y = ((this.canvas.clientHeight - 140) / 2 - this.panY) / this.scale;
                        } else {
                            // ç¸¦ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šé€šå¸¸ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸­å¤®
                            x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                            y = (this.canvas.clientHeight / 2 - this.panY) / this.scale;
                        }
                        console.log('Touch outside canvas (palette), using center:', x, y);
                    }
                } else {
                    // ãƒã‚¦ã‚¹ã®å ´åˆã‚‚åŒæ§˜ã®å‡¦ç†
                    x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                    y = (this.canvas.clientHeight / 2 - this.panY) / this.scale;
                    console.log('Mouse event, using center:', x, y);
                }
                
                const component = this.createComponent(type, x, y);
                component.isNewFromPalette = true; // ãƒ‘ãƒ¬ãƒƒãƒˆã‹ã‚‰ä½œæˆã•ã‚ŒãŸã“ã¨ã‚’è¨˜éŒ²
                
                // é‡è¦ï¼šã¾ã ãƒãƒƒãƒ—ã«ã¯è¿½åŠ ã›ãšã€ä¸€æ™‚çš„ã«ä¿æŒ
                this.pendingComponent = component;
                this.selectedComponent = component;
                this.isDragging = true;
                this.dragOffset = { x: 0, y: 0 };
                this.dragStarted = false; // å®Ÿéš›ã®ãƒ‰ãƒ©ãƒƒã‚°ãŒé–‹å§‹ã•ã‚ŒãŸã‹ã®ãƒ•ãƒ©ã‚°
                
                // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
                if (event.type === 'touchstart') {
                    this.setupGlobalTouchHandlers();
                }
                
                // å®Ÿéš›ã®ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
                this.dragStarted = true;
                
                this.render();
            }
            
            // å®Ÿéš›ã®ãƒ‰ãƒ©ãƒƒã‚°ã‚’é–‹å§‹ã™ã‚‹é–¢æ•°ï¼ˆç¾åœ¨ã®ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½¿ç”¨ï¼‰
            startActualComponentDrag(type, currentEvent) {
                console.log('startActualComponentDrag called with type:', type);
                
                // ãƒ‘ãƒ¬ãƒƒãƒˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.isPaletteScrolling = false;
                
                // ç¾åœ¨ã®ã‚¿ãƒƒãƒä½ç½®ã‚’å–å¾—
                const touch = currentEvent.touches[0];
                const canvasRect = this.canvas.getBoundingClientRect();
                
                // æ¨ªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®å ´åˆã€ãƒ‘ãƒ¬ãƒƒãƒˆé ˜åŸŸã‚’é™¤ã„ãŸä¸­å¤®ã«é…ç½®
                const isLandscape = this.isMobileLandscape();
                let x, y;
                
                if (isLandscape) {
                    // æ¨ªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šãƒ‘ãƒ¬ãƒƒãƒˆé ˜åŸŸã‚’é™¤ã„ãŸã‚­ãƒ£ãƒ³ãƒã‚¹ä¸­å¤®
                    x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                    y = ((this.canvas.clientHeight - 140) / 2 - this.panY) / this.scale;
                } else {
                    // ç¸¦ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šé€šå¸¸ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸­å¤®
                    x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                    y = (this.canvas.clientHeight / 2 - this.panY) / this.scale;
                }
                
                console.log('Creating component at position:', x, y);
                
                const component = this.createComponent(type, x, y);
                component.isNewFromPalette = true;
                
                // é‡è¦ï¼šã¾ã ãƒãƒƒãƒ—ã«ã¯è¿½åŠ ã›ãšã€ä¸€æ™‚çš„ã«ä¿æŒ
                this.pendingComponent = component;
                this.selectedComponent = component;
                this.isDragging = true;
                this.dragOffset = { x: 0, y: 0 };
                this.dragStarted = true;
                
                // å®Ÿéš›ã«ãƒãƒƒãƒ—ã«è¿½åŠ 
                this.components.set(component.id, component);
                console.log('Component added to map with ID:', component.id, 'Total components:', this.components.size);
                
                // ç¾åœ¨ã®ã‚¿ãƒƒãƒä½ç½®ã‚’è¨˜éŒ²
                this.currentMousePos = {
                    x: (touch.clientX - canvasRect.left - this.panX) / this.scale,
                    y: (touch.clientY - canvasRect.top - this.panY) / this.scale
                };
                
                console.log('Component drag started, isDragging:', this.isDragging, 'selectedComponent:', this.selectedComponent);
                
                // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
                if (currentEvent.type === 'touchstart' || currentEvent.type === 'touchmove') {
                    console.log('Setting up global touch handlers');
                    this.setupGlobalTouchHandlers();
                }
                
                this.render();
                
                // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šé…ç½®å¾Œã®çŠ¶æ…‹ã‚’ç¢ºèª
                console.log('After render - components.size:', this.components.size);
                console.log('After render - pendingComponent:', this.pendingComponent);
                console.log('After render - canvas dimensions:', this.canvas.width, 'x', this.canvas.height);
                console.log('After render - scale:', this.scale, 'panX:', this.panX, 'panY:', this.panY);
            }
        }

        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
        window.addEventListener('DOMContentLoaded', () => {
            // å¼·åˆ¶çš„ã«app-containerã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¨­å®š
            const appContainer = document.querySelector('.app-container');
            if (appContainer && window.innerWidth <= 768) {
                appContainer.style.margin = '0';
                appContainer.style.padding = '0';
                appContainer.style.height = '100vh';
                appContainer.style.width = '100vw';
                appContainer.style.maxHeight = '100vh';
                appContainer.style.minHeight = '100vh';
                appContainer.style.display = 'flex';
                appContainer.style.flexDirection = 'column';
                appContainer.style.overflow = 'hidden';
                appContainer.style.boxSizing = 'border-box';
                console.log('Forced app-container styles applied');
            }
            
            new MobileCircuitSimulator();
        });
    </script>
</Layout>