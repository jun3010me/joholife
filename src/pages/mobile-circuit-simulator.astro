---
// スマホ対応論理回路シミュレータ
import Layout from '../layouts/Layout.astro';
---

<Layout title="スマホ対応論理回路シミュレータ">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            overflow: hidden;
            height: 100vh;
        }

        /* モバイル・タブレット時はLayoutと協調（タッチデバイス判定） */
        @media (max-width: 1024px) and (hover: none) and (pointer: coarse) {
            html, body {
                margin: 0;
                padding: 0;
                height: 100vh;
                width: 100vw;
                overflow: hidden;
            }
        }

        .app-container {
            display: flex;
            height: 100vh;
            width: 100vw;
            position: relative;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* 部品パレット（新標準：画面上部固定、PC・モバイル共通） */
        .component-palette {
            position: fixed;
            left: 0;
            right: 0;
            top: calc(env(safe-area-inset-top, 0px) + 4rem); /* シンプルにナビ高さ + Safe Area */
            height: 110px; /* アイコンが切れないよう少し高くする */
            background: white;
            border-bottom: 1px solid #ddd;
            display: flex;
            flex-direction: row;
            padding: 8px;
            overflow-x: auto;
            overflow-y: hidden;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding-left: max(8px, env(safe-area-inset-left, 8px)); /* 左Safe Area */
            padding-right: max(8px, env(safe-area-inset-right, 8px)); /* 右Safe Area */
        }

        .palette-header {
            display: none; /* タイトル表示を完全に無効化 */
        }

        .palette-title {
            display: none;
        }


        .palette-content {
            display: flex !important;
            flex-direction: row !important;
            align-items: flex-start !important;
            gap: 8px !important; /* アイテム間の間隔を狭く */
            padding: 4px 8px 4px 8px; /* 上下パディングを縮小 */
            overflow-x: auto !important;
            overflow-y: hidden !important;
            width: 100% !important;
            height: 100% !important;
            box-sizing: border-box !important;
            flex-wrap: nowrap !important; /* 絶対に折り返さない */
            touch-action: pan-x !important; /* 横方向のタッチスクロールのみ許可 */
            
            /* スクロールバーを非表示にする */
            scrollbar-width: none !important; /* Firefox */
            -ms-overflow-style: none !important; /* IE・Edge */
        }

        /* WebKit系ブラウザ（Chrome、Safari）でスクロールバーを非表示 */
        .palette-content::-webkit-scrollbar {
            display: none !important;
        }

        .component-category {
            display: flex !important; /* 横並びに戻す */
            flex-direction: row !important;
            align-items: flex-start !important;
            flex-wrap: nowrap !important;
        }

        .category-title {
            display: none; /* 完全に非表示 */
        }

        /* 全てのレイアウトで1行横スクロール表示に統一 */
        .component-grid {
            display: flex !important;
            flex-direction: row !important;
            gap: 8px !important;
            flex-wrap: nowrap !important;
        }

        .component-item {
            flex-shrink: 0;
            width: 80px; /* 幅を広げてより多くの部品を表示 */
            height: 86px; /* パレット高さ(110px) - 全体パディング(16px) - 余裕(8px) */
            min-height: 86px;
            font-size: 0.8rem; /* 固定フォントサイズ */
            margin-right: 4px; /* アイテム間の間隔 */
        }

        .category-title {
            display: none; /* 全てのサイズで非表示 */
        }

        .component-item {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 6px 4px; /* 固定パディングで確実に収める */
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            user-select: none;
            box-sizing: border-box;
        }

        .component-item:hover {
            border-color: #2196f3;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2);
        }

        .component-icon {
            font-size: 20px;
            margin-bottom: 4px;
        }

        .component-icon-canvas {
            margin-bottom: 4px;
            background: transparent;
        }

        .component-name {
            font-size: 10px;
            color: #666;
            font-weight: 500;
        }

        /* メインキャンバス（上部パレット対応） */
        .main-canvas {
            position: fixed;
            top: calc(env(safe-area-inset-top, 0px) + 4rem + 110px); /* Safe Area + ナビ + パレット */
            left: env(safe-area-inset-left, 0px);
            right: env(safe-area-inset-right, 0px);
            bottom: calc(env(safe-area-inset-bottom, 0px) + 60px); /* 制御ボタン用のスペースを確保 */
            background: white;
            overflow: hidden;
        }

        /* 削除：モバイル用のパレット高さ調整（デフォルトで統一済み） */

        .canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
            touch-action: none;
        }

        /* 古いキャンバスコンテナ調整は削除済み */

        #circuit-canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 10px 10px, #ddd 1px, transparent 1px),
                radial-gradient(circle at 30px 30px, #ddd 1px, transparent 1px);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
        }

        /* 古いキャンバス要素調整は削除済み */

        /* ファイルメニューのセパレーター */
        .file-menu-separator {
            width: 1px;
            height: 20px;
            background: #ddd;
            margin: 0 8px;
            align-self: center;
        }

        /* ファイルメニュー */
        .file-menu {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 0px) + 12px);
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border-radius: 24px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            display: flex;
            padding: 4px;
            z-index: 1000;
            white-space: nowrap; /* 改行を防ぐ */
        }

        .file-button {
            background: none;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            font-weight: 500;
            min-height: 36px;
            display: flex;
            align-items: center;
            gap: 4px;
            flex-shrink: 0; /* ボタンの縮小を防ぐ */
        }

        .file-button:hover {
            background: #f5f5f5;
        }

        /* 古いPC用サイドバーレイアウトを削除 - 新しい上部固定レイアウトを使用 */

        /* 古い複雑なメディアクエリは削除 - シンプルな横幅ベース判定を使用 */
        /* 古いCSSブロック削除済み */






        /* モバイル横画面時の1行表示対応 */
        @media (max-width: 1024px) and (hover: none) and (pointer: coarse) and (orientation: landscape) {
            .palette-header {
                display: none; /* ヘッダーを非表示 */
            }

            .palette-content {
                display: flex;
                flex-direction: row;
                overflow-x: auto;
                overflow-y: hidden;
                padding: 8px;
            }

            .category-title {
                display: none; /* 横画面では非表示 */
            }

            .component-grid {
                display: flex !important; /* グリッドを横並びflex化 */
                flex-direction: row !important;
                gap: 6px;
                margin: 0;
                padding: 0;
                grid-template-columns: none !important; /* グリッド設定を無効化 */
            }

            /* component-item設定は統合済み - 動的調整を使用 */

            .component-item:last-child {
                margin-right: 0;
            }
        }

        /* PC横画面対応（大画面のみ） */
        @media (min-width: 769px) and (orientation: landscape) and (max-height: 600px) {
            /* 部品パレットは統一されたfixed位置を維持 */
            .component-palette {
                /* width設定を削除 - 統一設定を使用 */
            }
            
            /* component-gridは統一されたflex設定を使用 */
            
            .canvas-container {
                flex: 1;
                /* max-width制限を削除 - 全画面幅を使用 */
            }

            .file-menu {
                bottom: calc(env(safe-area-inset-bottom, 0px) + 8px);
                left: 50%; /* 中央配置に修正 */
                transform: translateX(-50%); /* 中央配置のため */
                flex-direction: row;
                width: auto;
            }

            .file-menu-button {
                min-width: 44px;
                min-height: 44px;
                border-radius: 0;
            }

            .file-menu-button:first-child {
                border-radius: 8px 0 0 8px;
            }

            .file-menu-button:last-child {
                border-radius: 0 8px 8px 0;
            }

            .file-menu-button + .file-menu-button {
                border-top: none;
                border-left: 1px solid #eee;
            }
        }

        /* 大画面横画面対応（縦幅が短い大画面） */
        @media (min-width: 844px) and (orientation: landscape) and (max-height: 600px) {
            /* 部品パレットは統一されたfixed位置を維持 */
            .component-palette {
                /* 統一設定を使用 - position: relativeを削除 */
            }
            
            /* component-gridは統一されたflex設定を使用 */

            .main-canvas {
                /* width制限を削除 - 全画面幅を使用 */
            }


            .palette-overlay {
                display: none; /* オーバーレイ不要 */
            }


            .file-menu {
                position: fixed;
                bottom: calc(env(safe-area-inset-bottom, 0px) + 8px);
                left: 50%; /* 中央配置に修正 */
                transform: translateX(-50%); /* 中央配置のため */
                flex-direction: row;
                width: auto;
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            }

            .file-menu-button {
                border-radius: 0;
            }

            .file-menu-button:first-child {
                border-radius: 12px 0 0 12px;
            }

            .file-menu-button:last-child {
                border-radius: 0 12px 12px 0;
            }

            .file-menu-button + .file-menu-button {
                border-top: none;
                border-left: 1px solid #eee;
            }
        }

        /* SafeArea対応 - モバイル時は完全無効化 */
        @media (min-width: 769px) {
            @supports (padding: max(0px)) {
                .app-container {
                    padding-left: max(12px, env(safe-area-inset-left));
                    padding-right: max(12px, env(safe-area-inset-right));
                    padding-top: 0;
                    padding-bottom: 0;
                }
                
                @media (orientation: landscape) {
                    .app-container {
                        padding-left: max(20px, env(safe-area-inset-left));
                        padding-right: max(20px, env(safe-area-inset-right));
                        padding-top: 0;
                        padding-bottom: 0;
                    }
                }
            }
        }

        /* Layoutコンポーネントとの協調（タッチデバイス） */
        @media (max-width: 1024px) and (hover: none) and (pointer: coarse) {
            /* main-contentを回路シミュレータ用に調整 */
            .main-content {
                padding: 0 !important;
                margin: 0 !important;
                width: 100vw !important;
                height: calc(100vh - 4rem) !important; /* ナビゲーションバー分を引く */
                max-width: none !important;
            }
            
            /* footerの無効化（必要に応じて） */
            .footer {
                display: none !important;
            }
            
            /* app-containerの調整 */
            .app-container {
                margin: 0 !important;
                padding: 0 !important;
                height: calc(100vh - 4rem) !important; /* ナビゲーションバー分を引く */
                width: 100vw !important;
                display: flex !important;
                flex-direction: column !important;
                position: relative !important;
                overflow: hidden !important;
                box-sizing: border-box !important;
            }
        }

            .component-category {
                display: flex;
                flex-direction: column;
                margin-right: 10px;
                margin-bottom: 0;
            }
            
            .component-category .category-title {
                font-size: 10px;
                margin-top: 10px;
                margin-bottom: 4px;
                text-align: center;
            }

            .component-grid {
                display: grid;
                gap: 6px;
                justify-content: center;
                margin: 0 6px;
            }
            
            /* component-gridは統一されたflex設定を使用 */

            /* component-itemは統一設定を使用 */


            /* ツールバーを中央右に配置 */
            .toolbar {
                top: 50%;
                transform: translateY(-50%);
                right: 12px;
            }

            /* メインキャンバスの高さ調整は統合済み - 動的計算を使用 */

            /* パレットヘッダーを横向き用に調整 */
            .palette-header {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                padding: 5px 10px;
                min-height: 30px;
                border-bottom: 1px solid #eee;
            }

            .palette-title {
                font-size: 16px;
                font-weight: bold;
            }


        .main-canvas {
            width: 100vw;
        }

        /* 古いモバイル・タブレット時のキャンバス調整（無効化） */
        /* @media (max-width: 1024px) and (hover: none) and (pointer: coarse) {
            .main-canvas {
                margin-top: 120px;
                height: calc(100vh - 4rem - 120px);
                padding: 0;
                flex: 1;
                width: 100vw;
                position: relative;
            }
        } */

        /* 古いスマホ・タブレット横画面時のキャンバス調整（無効化） */
        /* @media (max-width: 1024px) and (hover: none) and (pointer: coarse) and (orientation: landscape) {
            .main-canvas {
                margin-top: 100px;
                height: calc(100vh - 4rem - 100px);
                padding: 0;
            }
            
            .canvas-container {
                margin-top: -8px !important;
                top: -8px !important;
            }
        } */


        /* ドラッグ中の部品スタイル */
        .dragging-component {
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            opacity: 0.8;
            transform: scale(1.1);
        }

        /* 隠しファイル入力 */
        .hidden-file-input {
            display: none;
        }
    </style>

    <!-- メインアプリケーション -->
    <div class="app-container">
        
        <!-- 部品パレット -->
        <div class="component-palette" id="component-palette">
            <div class="palette-header">
                <span class="palette-title">部品パレット</span>
            </div>
            <div class="palette-content">
                <!-- 基本ゲート -->
                <div class="component-category">
                    <div class="category-title">基本ゲート</div>
                    <div class="component-grid">
                        <div class="component-item" data-type="AND">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="AND"></canvas>
                            <div class="component-name">AND</div>
                        </div>
                        <div class="component-item" data-type="OR">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="OR"></canvas>
                            <div class="component-name">OR</div>
                        </div>
                        <div class="component-item" data-type="NOT">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="NOT"></canvas>
                            <div class="component-name">NOT</div>
                        </div>
                        <div class="component-item" data-type="XOR">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="XOR"></canvas>
                            <div class="component-name">XOR</div>
                        </div>
                        <div class="component-item" data-type="NAND">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="NAND"></canvas>
                            <div class="component-name">NAND</div>
                        </div>
                        <div class="component-item" data-type="NOR">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="NOR"></canvas>
                            <div class="component-name">NOR</div>
                        </div>
                    </div>
                </div>

                <!-- 入出力 -->
                <div class="component-category">
                    <div class="category-title">入出力</div>
                    <div class="component-grid">
                        <div class="component-item" data-type="INPUT">
                            <div class="component-icon">◯</div>
                            <div class="component-name">入力</div>
                        </div>
                        <div class="component-item" data-type="OUTPUT">
                            <div class="component-icon">●</div>
                            <div class="component-name">出力</div>
                        </div>
                        <div class="component-item" data-type="LED">
                            <div class="component-icon">💡</div>
                            <div class="component-name">LED</div>
                        </div>
                        <div class="component-item" data-type="SWITCH">
                            <div class="component-icon">🔘</div>
                            <div class="component-name">スイッチ</div>
                        </div>
                        <div class="component-item" data-type="VCC">
                            <div class="component-icon">⚡</div>
                            <div class="component-name">電源</div>
                        </div>
                        <div class="component-item" data-type="OSC">
                            <div class="component-icon">⏰</div>
                            <div class="component-name">クロック</div>
                        </div>
                    </div>
                </div>

                <!-- フリップフロップ -->
                <div class="component-category">
                    <div class="category-title">フリップフロップ</div>
                    <div class="component-grid">
                        <div class="component-item" data-type="DFF">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="DFF"></canvas>
                            <div class="component-name">D-FF</div>
                        </div>
                        <div class="component-item" data-type="JKFF">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="JKFF"></canvas>
                            <div class="component-name">JK-FF</div>
                        </div>
                        <div class="component-item" data-type="TFF">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="TFF"></canvas>
                            <div class="component-name">T-FF</div>
                        </div>
                        <div class="component-item" data-type="RSFF">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="RSFF"></canvas>
                            <div class="component-name">RS-FF</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- メインキャンバス -->
        <div class="main-canvas">
            <div class="canvas-container">
                <canvas id="circuit-canvas"></canvas>
            </div>
        </div>


        <!-- ファイルメニュー -->
        <div class="file-menu">
            <button class="file-button" id="save-btn">💾 保存</button>
            <button class="file-button" id="load-btn">📁 読込</button>
            <button class="file-button" id="export-btn">📷 画像</button>
            <div class="file-menu-separator"></div>
            <button class="file-button" id="undo-btn" title="元に戻す">↶ 戻る</button>
            <button class="file-button" id="redo-btn" title="やり直し">↷ 進む</button>
        </div>

        <!-- 隠しファイル入力 -->
        <input type="file" class="hidden-file-input" id="file-input" accept=".json">
    </div>

    <script type="module">
        // アプリケーションの初期化
        class MobileCircuitSimulator {
            constructor() {
                this.canvas = document.getElementById('circuit-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.components = new Map();
                this.connections = [];
                this.selectedComponent = null;
                this.isDragging = false;
                this.dragOffset = { x: 0, y: 0 };
                this.scale = 1;
                this.panX = 0;
                // モバイル・タブレット時は上部の余白を詰めるため、panYを調整
                if (this.isTouchDevice()) {
                    this.panY = 20; // 上部の描画位置を20px下げる
                } else {
                    this.panY = 0;
                }
                this.history = [];
                this.historyIndex = -1;
                this.isConnecting = false;
                this.connectionStart = null;
                this.currentMousePos = { x: 0, y: 0 };
                this.isSimulating = true;
                this.simulationInterval = null;
                this.isPanning = false;
                this.lastPanPoint = null;
                this.touches = [];
                this.lastPinchDistance = null;
                this.lastPinchCenter = null;
                this.touchStartTime = 0;
                this.touchStartPos = null;
                this.dragThreshold = 10; // ピクセル単位でのドラッグ判定しきい値
                this.selectedConnection = null;
                this.lastClickTime = 0;
                this.doubleClickDelay = 300; // ダブルクリック判定時間（ミリ秒）
                this.lastClickPosition = null; // 最後のクリック位置
                this.overlappingComponents = []; // 重なったコンポーネントのリスト
                
                // パレットスクロール対応
                this.isPaletteScrolling = false;
                this.paletteScrollStartX = 0;
                this.paletteScrollStartY = 0;
                this.paletteScrollThreshold = 10; // スクロール判定を緩く（横スクロール優先）
                this.paletteScrollStartScrollLeft = 0;
                this.pendingComponentDrag = null; // 部品ドラッグ開始待機用
                this.currentOverlapIndex = 0; // 現在選択中の重なりインデックス
                this.nextZIndex = 1; // Z-index管理用カウンター
                this.pendingComponent = null; // パレットからドラッグ中の部品（まだマップに追加されていない）
                this.dragStarted = false; // 実際のドラッグ移動が開始されたかのフラグ
                
                this.init();
            }
            
            // モバイル横画面の判定（CSSメディアクエリと完全統一）
            isMobileLandscape() {
                // CSSと同じ条件：(max-width: 1024px) and (hover: none) and (pointer: coarse) and (orientation: landscape)
                const isLandscape = window.matchMedia('(max-width: 1024px) and (hover: none) and (pointer: coarse) and (orientation: landscape)').matches;
                
                console.log('Landscape detection:', {
                    mediaQuery: window.matchMedia('(max-width: 1024px) and (hover: none) and (pointer: coarse) and (orientation: landscape)').matches,
                    orientation: window.matchMedia('(orientation: landscape)').matches,
                    maxWidth: window.matchMedia('(max-width: 1024px)').matches,
                    hoverNone: window.matchMedia('(hover: none)').matches,
                    pointerCoarse: window.matchMedia('(pointer: coarse)').matches,
                    innerWidth: window.innerWidth,
                    innerHeight: window.innerHeight,
                    isLandscape: isLandscape
                });
                return isLandscape;
            }

            // タッチデバイスかどうかを判定（iPhone16ProMAX、iPad等に対応）
            isTouchDevice() {
                // PCのタッチスクリーンと真のモバイルデバイスを区別
                const isMobileWidth = window.innerWidth <= 1024;
                const hasTouch = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
                const isPrimaryTouch = window.matchMedia('(hover: none) and (pointer: coarse)').matches;
                
                // 幅が1024以下で、かつプライマリ入力デバイスがタッチの場合のみtrue
                return isMobileWidth && hasTouch && isPrimaryTouch;
            }

            init() {
                this.setupCanvas();
                this.setupEventListeners();
                this.setupPalette();
                this.setupFileHandling();
                this.drawPaletteIcons();
                this.startSimulation();
                
                // 初回アクセス時の表示問題対策：確実にキャンバスが初期化されてからレンダリング
                setTimeout(() => {
                    this.resizeCanvas(); // 再度リサイズして確実にサイズ設定
                    this.render();
                }, 50);
            }
            
            startSimulation() {
                this.simulationInterval = setInterval(() => {
                    if (this.isSimulating) {
                        this.updateSimulation();
                    }
                }, 100); // 10Hzでシミュレーション更新
            }

            setupCanvas() {
                this.resizeCanvas = () => {
                    const container = this.canvas.parentElement;
                    const dpr = window.devicePixelRatio || 1;
                    
                    // 初回アクセス時の表示問題対策：コンテナサイズが0の場合は少し待つ
                    if (container.clientWidth === 0 || container.clientHeight === 0) {
                        console.log('Container size not ready, retrying resize...', {
                            width: container.clientWidth,
                            height: container.clientHeight
                        });
                        setTimeout(this.resizeCanvas, 50);
                        return;
                    }
                    
                    this.canvas.width = container.clientWidth * dpr;
                    this.canvas.height = container.clientHeight * dpr;
                    this.canvas.style.width = container.clientWidth + 'px';
                    this.canvas.style.height = container.clientHeight + 'px';
                    
                    this.ctx.scale(dpr, dpr);
                    this.render();
                };

                // 画面向き変更とリサイズイベントの処理
                const handleOrientationChange = () => {
                    const isDesktop = window.innerWidth > 768;
                    if (isDesktop) {
                        // PC環境ではクラス管理のみスキップ、キャンバスリサイズは実行
                        document.body.classList.remove('landscape', 'large-landscape');
                        setTimeout(() => {
                            this.resizeCanvas();
                        }, 100);
                        return;
                    }
                    
                    const isLandscape = window.innerWidth > window.innerHeight;
                    const isShortHeight = window.innerHeight <= 600;
                    const isLargeScreen = window.innerWidth >= 844 && isLandscape && isShortHeight;
                    
                    // CSSクラスを動的に管理（横画面かつ大画面のみ）
                    document.body.classList.toggle('landscape', isLandscape && !isLargeScreen);
                    document.body.classList.toggle('large-landscape', isLandscape && isLargeScreen);
                    
                    // 横画面かつ大画面時はパレットを常時表示
                    if (isLandscape && isLargeScreen) {
                        const palette = document.querySelector('.component-palette');
                        const overlay = document.querySelector('.palette-overlay');
                        if (palette) {
                            palette.classList.remove('open');
                            // パレットを常時表示状態にする
                            palette.style.transform = 'translateX(0)';
                            palette.style.position = 'relative';
                        }
                        if (overlay) {
                            overlay.classList.remove('visible');
                        }
                    }
                    
                    // キャンバスのリサイズ
                    setTimeout(() => {
                        this.resizeCanvas();
                    }, 100);
                };

                window.addEventListener('resize', handleOrientationChange);
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => {
                        handleOrientationChange();
                        // 部品パレットの再構築を実行
                        this.rebuildComponentPalette();
                    }, 100);
                });
                
                // 初期化時に実行
                handleOrientationChange();
                
                // メディアクエリの変更を監視
                const landscapeQuery = window.matchMedia('(max-width: 1024px) and (hover: none) and (pointer: coarse) and (orientation: landscape)');
                landscapeQuery.addEventListener('change', () => {
                    console.log('Media query changed, rebuilding palette');
                    setTimeout(() => {
                        this.rebuildComponentPalette();
                    }, 100);
                });
            }

            // 画面回転時の部品パレット再構築
            rebuildComponentPalette() {
                console.log('Rebuilding component palette for orientation change');
                
                const isLandscape = this.isMobileLandscape();
                const palette = document.querySelector('.component-palette');
                
                if (!palette) return;
                
                // 現在の画面方向に応じてパレットを再構築
                if (isLandscape) {
                    // 横画面用の再構築
                    console.log('Rebuilding for landscape mode');
                    
                    // パレットのスクロール状態をリセット
                    this.isPaletteScrolling = false;
                    
                    // 部品グリッドを横スクロール用に再配置
                    const componentGrids = palette.querySelectorAll('.component-grid');
                    componentGrids.forEach(grid => {
                        // グリッドをフレックスボックスに変更
                        grid.style.display = 'flex';
                        grid.style.flexDirection = 'row';
                        grid.style.flexWrap = 'nowrap';
                        grid.style.overflowX = 'visible';
                        grid.style.gap = '4px';
                        
                        // 部品アイテムのサイズを調整（CSSで統一された80pxを維持）
                        const items = grid.querySelectorAll('.component-item');
                        items.forEach(item => {
                            // CSS設定を優先して動的変更は行わない
                            item.style.flexShrink = '0';
                        });
                    });
                    
                    // パレットコンテンツを横スクロール用に調整
                    const paletteContent = palette.querySelector('.palette-content');
                    if (paletteContent) {
                        paletteContent.style.overflowX = 'auto';
                        paletteContent.style.overflowY = 'hidden';
                        paletteContent.style.display = 'flex';
                        paletteContent.style.flexDirection = 'row';
                        paletteContent.style.alignItems = 'center';
                    }
                } else {
                    // 縦画面用の再構築
                    console.log('Rebuilding for portrait mode');
                    
                    // パレットのスクロール状態をリセット
                    this.isPaletteScrolling = false;
                    
                    // 部品グリッドを縦画面用に再配置
                    const componentGrids = palette.querySelectorAll('.component-grid');
                    componentGrids.forEach(grid => {
                        // グリッドをグリッドレイアウトに戻す
                        grid.style.display = 'grid';
                        grid.style.gridTemplateColumns = 'repeat(3, 1fr)';
                        grid.style.flexDirection = '';
                        grid.style.flexWrap = '';
                        grid.style.overflowX = '';
                        grid.style.gap = '8px';
                        
                        // 部品アイテムのサイズを元に戻す（CSS設定を維持）
                        const items = grid.querySelectorAll('.component-item');
                        items.forEach(item => {
                            // CSS設定を維持して動的変更をリセット
                            item.style.flexShrink = '';
                        });
                    });
                    
                    // パレットコンテンツを縦画面用に調整
                    const paletteContent = palette.querySelector('.palette-content');
                    if (paletteContent) {
                        paletteContent.style.overflowX = '';
                        paletteContent.style.overflowY = 'auto';
                        paletteContent.style.display = '';
                        paletteContent.style.flexDirection = '';
                        paletteContent.style.alignItems = '';
                    }
                }
                
                // レンダリングを更新
                setTimeout(() => {
                    this.render();
                }, 50);
            }

            setupEventListeners() {
                // タッチ・マウスイベント
                this.canvas.addEventListener('mousedown', this.handlePointerDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handlePointerMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handlePointerUp.bind(this));
                
                // グローバルマウスイベント（キャンバス外でのドラッグ対応）
                this.globalMouseMoveHandler = this.handleGlobalMouseMove.bind(this);
                this.globalMouseUpHandler = this.handleGlobalMouseUp.bind(this);
                
                this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });

                // ピンチズーム
                this.canvas.addEventListener('wheel', this.handleWheel.bind(this), { passive: false });

                // ツールバーボタン（統合後）
                document.getElementById('undo-btn').addEventListener('click', this.undo.bind(this));
                document.getElementById('redo-btn').addEventListener('click', this.redo.bind(this));
            }

            setupPalette() {
                const palette = document.getElementById('component-palette');
                const items = palette.querySelectorAll('.component-item');

                const isTouch = this.isTouchDevice();
                const isNarrowScreen = window.innerWidth <= 1024; // 狭い画面かどうか
                
                console.log('Device detection:', {
                    isTouchDevice: isTouch,
                    isNarrowScreen: isNarrowScreen,
                    width: window.innerWidth,
                    hasTouch: ('ontouchstart' in window || navigator.maxTouchPoints > 0),
                    primaryTouch: window.matchMedia('(hover: none) and (pointer: coarse)').matches
                });

                // 狭い画面（1024px以下）では常にタッチスクロールを有効化
                if (isNarrowScreen) {
                    console.log('Setting up touch event handlers (narrow screen)');
                    const paletteContent = document.querySelector('.palette-content');
                    if (paletteContent) {
                        // パレット全体でのスクロール処理（passive: falseで制御可能に）
                        paletteContent.addEventListener('touchstart', this.handlePaletteScrollStart.bind(this), { passive: false });
                        paletteContent.addEventListener('touchmove', this.handlePaletteScrollMove.bind(this), { passive: false });
                        paletteContent.addEventListener('touchend', this.handlePaletteScrollEnd.bind(this), { passive: false });
                    }
                    
                    // 狭い画面でもマウスイベントは併用（PCとタッチ両対応）
                    items.forEach(item => {
                        item.addEventListener('mousedown', this.startComponentDrag.bind(this));
                        // 個別アイテムのタッチイベントは削除（パレット全体で処理）
                    });
                } else {
                    console.log('Setting up mouse event handlers (wide screen)');
                    // 広い画面ではマウス操作のみ
                    items.forEach(item => {
                        item.addEventListener('mousedown', this.startComponentDrag.bind(this));
                        item.addEventListener('touchstart', this.startComponentDrag.bind(this), { passive: false });
                    });
                }
            }

            setupFileHandling() {
                document.getElementById('save-btn').addEventListener('click', this.saveCircuit.bind(this));
                document.getElementById('load-btn').addEventListener('click', this.loadCircuit.bind(this));
                document.getElementById('export-btn').addEventListener('click', this.exportImage.bind(this));
                document.getElementById('file-input').addEventListener('change', this.handleFileLoad.bind(this));
            }

            getPointerPos(event) {
                const rect = this.canvas.getBoundingClientRect();
                let clientX, clientY;
                
                // タッチイベントかマウスイベントかを判定
                if (event.touches && event.touches.length > 0) {
                    // タッチイベントの場合
                    clientX = event.touches[0].clientX;
                    clientY = event.touches[0].clientY;
                } else if (event.changedTouches && event.changedTouches.length > 0) {
                    // タッチエンドイベントの場合
                    clientX = event.changedTouches[0].clientX;
                    clientY = event.changedTouches[0].clientY;
                } else {
                    // マウスイベントの場合
                    clientX = event.clientX;
                    clientY = event.clientY;
                }
                
                // キャンバス外でもドラッグできるように座標変換
                return {
                    x: (clientX - rect.left - this.panX) / this.scale,
                    y: (clientY - rect.top - this.panY) / this.scale
                };
            }

            handlePointerDown(event) {
                event.preventDefault();
                console.log('PointerDown triggered, event type:', event.type);
                
                // マルチタッチの場合はスキップ
                if (event.touches && event.touches.length > 1) return;
                
                const pos = this.getPointerPos(event);
                this.touchStartTime = Date.now();
                this.touchStartPos = { x: pos.x, y: pos.y };
                
                // コンテキスト認識型タッチ判定システム
                // 1. まず端子を優先チェック（接続開始の意図を尊重）
                const port = this.getPortAt(pos.x, pos.y);
                console.log('Checking for any port at', pos.x, pos.y, 'found:', port ? `${port.type} on ${port.component.type} (zIndex: ${port.component.zIndex})` : 'none');
                
                // 2. 部品の中心部分かどうかを判定
                const component = this.getComponentAt(pos.x, pos.y, false);
                const isComponentCenter = component ? this.isInComponentCenter(component, pos.x, pos.y) : false;
                
                // 3. 接続線をチェック
                const connection = this.getConnectionAt(pos.x, pos.y);
                console.log('Checking for connection at', pos.x, pos.y, 'found:', connection ? connection.id : 'none');
                
                // 判定の優先順位を決定
                if (port && (!connection || !isComponentCenter)) {
                    // 端子が見つかり、かつ（接続線がないか、部品中心部でない）場合は端子を優先
                    const componentAtPosition = this.getComponentAt(pos.x, pos.y, false);
                    console.log('Component at same position:', componentAtPosition ? `${componentAtPosition.type} (zIndex: ${componentAtPosition.zIndex})` : 'none');
                    
                    if (!componentAtPosition || port.component.zIndex >= componentAtPosition.zIndex) {
                        // 端子の部品が最前面または同等の場合、端子から接続線開始
                        console.log('Starting connection from port:', port.type, 'on', port.component.type);
                        this.currentMousePos = pos;
                        this.startConnection(port);
                        return;
                    }
                } else if (connection && !isComponentCenter) {
                    // 接続線が見つかり、部品中心部でない場合は接続線を優先
                    const currentTime = Date.now();
                    
                    if (this.selectedConnection === connection && 
                        currentTime - this.lastClickTime < this.doubleClickDelay) {
                        // ダブルクリック：接続線を削除
                        this.removeConnection(connection.id);
                        this.selectedConnection = null;
                        this.render();
                        this.saveState();
                        this.updateSimulation();
                        console.log('Connection deleted via double-click');
                        return;
                    }
                    
                    // シングルクリック：接続線を選択
                    this.selectedConnection = connection;
                    this.selectedComponent = null;
                    this.lastClickTime = currentTime;
                    this.render();
                    console.log('Selected connection:', connection.id);
                    return;
                }
                
                // 最後に部品をチェック（既に上でcomponentは取得済み）
                if (component) {
                    // 部品をドラッグ
                    console.log('Component selected for dragging:', component.type);
                    this.selectedComponent = component;
                    this.selectedConnection = null;
                    
                    // 選択されたコンポーネントを前面に移動
                    component.zIndex = this.nextZIndex++;
                    
                    this.isDragging = true;
                    this.dragOffset = {
                        x: pos.x - component.x,
                        y: pos.y - component.y
                    };
                    this.isPanning = false;
                    
                    // グローバルマウスイベントを追加（キャンバス外でのドラッグ対応）
                    document.addEventListener('mousemove', this.globalMouseMoveHandler);
                    document.addEventListener('mouseup', this.globalMouseUpHandler);
                    return;
                }
                
                // 接続線は既に上でチェック済み
                
                // 何も選択されなかった場合はパン開始
                console.log('No component or connection found, starting pan mode');
                this.selectedComponent = null;
                this.selectedConnection = null;
                this.isDragging = false;
                this.isPanning = true;
                
                // パン開始時は生の座標を使用
                const rect = this.canvas.getBoundingClientRect();
                const rawX = event.clientX || (event.touches && event.touches[0].clientX);
                const rawY = event.clientY || (event.touches && event.touches[0].clientY);
                this.lastPanPoint = {
                    x: rawX - rect.left,
                    y: rawY - rect.top
                };
                
                this.render();
            }

            handlePointerMove(event) {
                event.preventDefault();
                
                // マルチタッチの場合はスキップ
                if (event.touches && event.touches.length > 1) return;
                
                const pos = this.getPointerPos(event);
                this.currentMousePos = pos;
                
                if (this.isConnecting) {
                    this.render();
                } else if (this.isDragging && this.selectedComponent) {
                    // パレットから作成された部品で、まだマップに追加されていない場合
                    if (this.pendingComponent && !this.dragStarted) {
                        console.log('First drag movement detected, adding component to map:', this.pendingComponent.type);
                        this.components.set(this.pendingComponent.id, this.pendingComponent);
                        this.dragStarted = true;
                        this.saveState();
                    }
                    
                    this.selectedComponent.x = pos.x - this.dragOffset.x;
                    this.selectedComponent.y = pos.y - this.dragOffset.y;
                    this.render();
                } else if (this.isPanning && this.lastPanPoint) {
                    // パン処理は生の座標を使用
                    const rect = this.canvas.getBoundingClientRect();
                    const rawX = event.clientX || (event.touches && event.touches[0].clientX);
                    const rawY = event.clientY || (event.touches && event.touches[0].clientY);
                    const currentRawPos = {
                        x: rawX - rect.left,
                        y: rawY - rect.top
                    };
                    
                    const deltaX = currentRawPos.x - this.lastPanPoint.x;
                    const deltaY = currentRawPos.y - this.lastPanPoint.y;
                    this.panX += deltaX;
                    this.panY += deltaY;
                    
                    // 次回のために生の座標を保存
                    this.lastPanPoint = currentRawPos;
                    this.render();
                }
            }

            handlePointerUp(event) {
                event.preventDefault();
                
                // パレットスクロール状態をリセット
                this.isPaletteScrolling = false;
                
                if (this.isConnecting && this.connectionStart) {
                    const pos = this.getPointerPos(event);
                    let port = this.getPortAt(pos.x, pos.y);
                    
                    // 端子が見つからない場合、コンポーネント内でのスマート接続を試行
                    if (!port) {
                        const component = this.getComponentAt(pos.x, pos.y);
                        if (component) {
                            console.log('handlePointerUp - No direct port hit, trying smart connection to:', component.type);
                            
                            // 接続開始が出力端子の場合、入力端子を探す
                            if (this.connectionStart.type === 'output') {
                                port = this.findBestInputPort(component, pos.x, pos.y);
                            }
                            // 接続開始が入力端子の場合、出力端子を探す  
                            else if (this.connectionStart.type === 'input') {
                                port = this.findBestOutputPort(component, pos.x, pos.y);
                            }
                        }
                    }
                    
                    console.log('handlePointerUp - Connection mode, found port:', port ? port.type : 'none');
                    if (port && port !== this.connectionStart) {
                        this.completeConnection(this.connectionStart, port);
                    } else {
                        console.log('handlePointerUp - No valid end port found');
                    }
                    this.cancelConnection();
                } else if (this.isDragging && this.selectedComponent) {
                    const pos = this.getPointerPos(event);
                    const touchDuration = Date.now() - this.touchStartTime;
                    const touchDistance = this.touchStartPos ? 
                        Math.sqrt(Math.pow(pos.x - this.touchStartPos.x, 2) + Math.pow(pos.y - this.touchStartPos.y, 2)) : 0;
                    
                    // パレットから作成された部品で、実際のドラッグが開始されていない場合
                    if (this.pendingComponent && !this.dragStarted) {
                        console.log('Canceling pending component - no drag detected:', this.pendingComponent.type);
                        this.pendingComponent = null;
                        this.selectedComponent = null;
                        this.isDragging = false;
                        return;
                    }
                    
                    // 短いタップかつ移動距離が小さい場合は状態切り替えまたは設定変更
                    if ((this.selectedComponent.type === 'INPUT' || this.selectedComponent.type === 'SWITCH') &&
                        touchDuration < 500 && // 500ms以下
                        touchDistance < this.dragThreshold) { // 10px以下の移動
                        this.toggleInput(this.selectedComponent);
                        // console.log('Toggle input:', this.selectedComponent.type, 'to', this.selectedComponent.state);
                    } else if (this.selectedComponent.type === 'OSC' &&
                        touchDuration < 500 && // 500ms以下
                        touchDistance < this.dragThreshold) { // 10px以下の移動
                        this.adjustOscillatorFrequency(this.selectedComponent);
                    } else {
                        // ドラッグ完了 - エリア外削除判定
                        const component = this.selectedComponent;
                        
                        // PC環境とモバイル環境で異なる削除判定を使用
                        const isDesktop = window.innerWidth > 768;
                        let shouldDelete = false;
                        
                        if (isDesktop) {
                            // PC環境：スクリーン座標でキャンバス領域外かどうかを判定
                            const rect = this.canvas.getBoundingClientRect();
                            const screenX = component.x * this.scale + this.panX;
                            const screenY = component.y * this.scale + this.panY;
                            const screenWidth = component.width * this.scale;
                            const screenHeight = component.height * this.scale;
                            
                            // PC環境では、左側にパレット（パレットが閉じられていてもマージンを考慮）
                            const leftMargin = 0; // キャンバス領域は既にパレット分が除外されている
                            const deleteThreshold = 50; // 削除判定のマージン（50px）
                            
                            console.log('PC deletion check:', {
                                componentType: component.type,
                                isNewFromPalette: component.isNewFromPalette,
                                screenPos: { x: screenX, y: screenY },
                                screenSize: { w: screenWidth, h: screenHeight },
                                canvasSize: { w: rect.width, h: rect.height },
                                deleteThreshold
                            });
                            
                            shouldDelete = !component.isNewFromPalette && (
                                screenX + screenWidth < -deleteThreshold || 
                                screenX > rect.width + deleteThreshold || 
                                screenY + screenHeight < -deleteThreshold || 
                                screenY > rect.height + deleteThreshold
                            );
                        } else {
                            // モバイル環境：従来のワールド座標系での判定
                            const visibleLeft = -this.panX / this.scale;
                            const visibleTop = -this.panY / this.scale;
                            const visibleRight = (this.canvas.clientWidth - this.panX) / this.scale;
                            const visibleBottom = (this.canvas.clientHeight - this.panY) / this.scale;
                            
                            shouldDelete = !component.isNewFromPalette && (
                                component.x + component.width < visibleLeft || 
                                component.x > visibleRight || 
                                component.y + component.height < visibleTop || 
                                component.y > visibleBottom
                            );
                        }
                        
                        // コンポーネントがキャンバスエリア外に完全に出た場合は削除
                        if (shouldDelete) {
                            
                            console.log('Component dragged outside canvas, deleting:', component.type);
                            
                            // 削除するコンポーネントに接続された接続線をすべて削除
                            const connectionsToDelete = this.connections.filter(connection => 
                                connection.from.component.id === component.id || 
                                connection.to.component.id === component.id
                            );
                            
                            connectionsToDelete.forEach(connection => {
                                this.removeConnection(connection.id);
                            });
                            
                            // コンポーネントを削除
                            this.components.delete(component.id);
                            this.selectedComponent = null;
                            this.render();
                            this.saveState();
                            this.updateSimulation();
                        } else {
                            // 通常のドラッグ完了
                            // パレットから作成されたフラグをクリア
                            if (component.isNewFromPalette) {
                                component.isNewFromPalette = false;
                                console.log('Component placed from palette:', component.type);
                                console.log('Component position:', component.x, component.y);
                                console.log('Component added to map, total components:', this.components.size);
                            }
                            this.saveState();
                            // console.log('Drag completed for:', this.selectedComponent.type);
                        }
                    }
                    
                    this.isDragging = false;
                    this.pendingComponent = null;
                    
                    // グローバルイベントリスナーを削除
                    if (this.globalMouseMoveHandler) {
                        document.removeEventListener('mousemove', this.globalMouseMoveHandler);
                        document.removeEventListener('mouseup', this.globalMouseUpHandler);
                    }
                } else if (this.isPanning) {
                    this.isPanning = false;
                    this.lastPanPoint = null;
                }
                
                // 状態をリセット
                this.touchStartTime = 0;
                this.touchStartPos = null;
            }

            handleWheel(event) {
                event.preventDefault();
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                
                const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.max(0.1, Math.min(3, this.scale * zoomFactor));
                
                // ズーム中心を調整
                this.panX = mouseX - (mouseX - this.panX) * (newScale / this.scale);
                this.panY = mouseY - (mouseY - this.panY) * (newScale / this.scale);
                
                this.scale = newScale;
                this.render();
            }

            startComponentDrag(event) {
                event.preventDefault();
                console.log('startComponentDrag called with type:', event.currentTarget.dataset.type);
                
                // 横レイアウト時は、即座にドラッグ開始せず、スクロール判定を待つ
                const isLandscape = this.isMobileLandscape();
                console.log('isLandscape:', isLandscape);
                
                if (isLandscape) {
                    // 横レイアウト時：部品ドラッグを保留して、スクロール判定に委ねる
                    // スクロール状態をリセット
                    console.log('startComponentDrag: resetting isPaletteScrolling from', this.isPaletteScrolling, 'to false');
                    this.isPaletteScrolling = false;
                    this.pendingComponentDrag = {
                        type: event.currentTarget.dataset.type,
                        event: event
                    };
                    console.log('pendingComponentDrag set to:', this.pendingComponentDrag);
                    return;
                }
                
                // 縦レイアウト時：従来通りの処理
                this.isPaletteScrolling = false;
                const type = event.currentTarget.dataset.type;
                
                // パレットアイテムの場合は、適切なキャンバス座標に部品を作成
                let x, y;
                const canvasRect = this.canvas.getBoundingClientRect();
                
                if (event.type === 'touchstart' && event.touches && event.touches.length > 0) {
                    // タッチの場合
                    const touch = event.touches[0];
                    console.log('Touch position:', touch.clientX, touch.clientY);
                    console.log('Canvas rect:', canvasRect);
                    
                    // タッチ位置がキャンバス内かチェック（横レイアウト時はパレット領域を除外）
                    let isWithinCanvas = false;
                    const isLandscape = this.isMobileLandscape();
                    
                    if (isLandscape) {
                        // 横レイアウト時：パレット領域（下部140px）を除外
                        isWithinCanvas = touch.clientX >= canvasRect.left && touch.clientX <= canvasRect.right &&
                                       touch.clientY >= canvasRect.top && touch.clientY <= (canvasRect.bottom - 140);
                    } else {
                        // 縦レイアウト時：通常の判定
                        isWithinCanvas = touch.clientX >= canvasRect.left && touch.clientX <= canvasRect.right &&
                                       touch.clientY >= canvasRect.top && touch.clientY <= canvasRect.bottom;
                    }
                    
                    if (isWithinCanvas) {
                        // キャンバス内の場合、その座標を使用
                        x = (touch.clientX - canvasRect.left - this.panX) / this.scale;
                        y = (touch.clientY - canvasRect.top - this.panY) / this.scale;
                        console.log('Touch within canvas, using touch position:', x, y);
                    } else {
                        // キャンバス外（パレット）の場合、キャンバス中央に配置
                        if (isLandscape) {
                            // 横レイアウト時：パレット領域を除いたキャンバス中央
                            x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                            y = ((this.canvas.clientHeight - 140) / 2 - this.panY) / this.scale;
                        } else {
                            // 縦レイアウト時：通常のキャンバス中央
                            x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                            y = (this.canvas.clientHeight / 2 - this.panY) / this.scale;
                        }
                        console.log('Touch outside canvas (palette), using center:', x, y);
                    }
                } else {
                    // マウスの場合も同様の処理
                    x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                    y = (this.canvas.clientHeight / 2 - this.panY) / this.scale;
                    console.log('Mouse event, using center:', x, y);
                }
                
                const component = this.createComponent(type, x, y);
                component.isNewFromPalette = true; // パレットから作成されたことを記録
                
                // 重要：まだマップには追加せず、一時的に保持
                this.pendingComponent = component;
                this.selectedComponent = component;
                this.isDragging = true;
                this.dragOffset = { x: 0, y: 0 };
                this.dragStarted = false; // 実際のドラッグが開始されたかのフラグ
                
                // タッチイベントの場合、グローバルなイベントリスナーを追加
                if (event.type === 'touchstart') {
                    this.setupGlobalTouchHandlers();
                }
                
                // まだ描画はしない（部品は表示されない）
                console.log('Component prepared for drag, not yet visible:', component.type);
            }
            
            setupGlobalTouchHandlers() {
                // グローバルなタッチムーブとタッチエンドイベントを追加
                const handleGlobalTouchMove = (event) => {
                    if (this.isDragging) {
                        event.preventDefault();
                        this.handlePointerMove(event);
                    }
                };
                
                const handleGlobalTouchEnd = (event) => {
                    if (this.isDragging) {
                        event.preventDefault();
                        this.handlePointerUp(event);
                    }
                    // イベントリスナーを削除
                    document.removeEventListener('touchmove', handleGlobalTouchMove);
                    document.removeEventListener('touchend', handleGlobalTouchEnd);
                };
                
                document.addEventListener('touchmove', handleGlobalTouchMove, { passive: false });
                document.addEventListener('touchend', handleGlobalTouchEnd, { passive: false });
            }

            createComponent(type, x, y) {
                const id = 'comp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                
                // 基本ゲートとフリップフロップは一回り大きく
                let width = 90;
                let height = 50;
                if (['AND', 'OR', 'XOR', 'NAND', 'NOR', 'NOT'].includes(type)) {
                    width = 110;
                    height = 60;
                } else if (['DFF', 'JKFF', 'TFF', 'RSFF'].includes(type)) {
                    width = 100;
                    height = 70;
                }
                
                const baseComponent = {
                    id,
                    type,
                    x,
                    y,
                    width,
                    height,
                    inputs: [],
                    outputs: [],
                    state: false,
                    zIndex: this.nextZIndex++ // Z-index設定
                };

                // タイプ別の設定
                switch (type) {
                    case 'AND':
                    case 'OR':
                    case 'XOR':
                        baseComponent.inputs = [
                            { id: 'in1', x: 0, y: 15, connected: null },
                            { id: 'in2', x: 0, y: 45, connected: null }
                        ];
                        baseComponent.outputs = [
                            { id: 'out', x: 110, y: 30, connected: [] }
                        ];
                        break;
                    case 'NAND':
                    case 'NOR':
                        baseComponent.inputs = [
                            { id: 'in1', x: 0, y: 15, connected: null },
                            { id: 'in2', x: 0, y: 45, connected: null }
                        ];
                        baseComponent.outputs = [
                            { id: 'out', x: 110, y: 30, connected: [] }
                        ];
                        break;
                    case 'NOT':
                        baseComponent.inputs = [
                            { id: 'in', x: 0, y: 30, connected: null }
                        ];
                        baseComponent.outputs = [
                            { id: 'out', x: 110, y: 30, connected: [] }
                        ];
                        break;
                    case 'INPUT':
                    case 'SWITCH':
                        baseComponent.inputs = [
                            { id: 'power', x: 0, y: 25, connected: null }
                        ];
                        baseComponent.outputs = [
                            { id: 'out', x: 90, y: 25, connected: [] }
                        ];
                        break;
                    case 'OUTPUT':
                    case 'LED':
                        baseComponent.inputs = [
                            { id: 'in', x: 0, y: 25, connected: null }
                        ];
                        break;
                    case 'DFF':
                        baseComponent.inputs = [
                            { id: 'D', x: 0, y: 20, connected: null },
                            { id: 'CLK', x: 0, y: 50, connected: null }
                        ];
                        baseComponent.outputs = [
                            { id: 'Q', x: 100, y: 20, connected: [], state: false },
                            { id: 'Qn', x: 100, y: 50, connected: [], state: true }
                        ];
                        baseComponent.prevClk = false;
                        baseComponent.qState = false;
                        baseComponent.state = false;
                        break;
                    case 'JKFF':
                        baseComponent.inputs = [
                            { id: 'J', x: 0, y: 15, connected: null },
                            { id: 'CLK', x: 0, y: 35, connected: null },
                            { id: 'K', x: 0, y: 55, connected: null }
                        ];
                        baseComponent.outputs = [
                            { id: 'Q', x: 100, y: 20, connected: [], state: false },
                            { id: 'Qn', x: 100, y: 50, connected: [], state: true }
                        ];
                        baseComponent.prevClk = false;
                        baseComponent.qState = false;
                        baseComponent.state = false;
                        break;
                    case 'TFF':
                        baseComponent.inputs = [
                            { id: 'T', x: 0, y: 35, connected: null }
                        ];
                        baseComponent.outputs = [
                            { id: 'Q', x: 100, y: 20, connected: [], state: false },
                            { id: 'Qn', x: 100, y: 50, connected: [], state: true }
                        ];
                        baseComponent.prevT = false;
                        baseComponent.qState = false;
                        baseComponent.state = false;
                        break;
                    case 'RSFF':
                        baseComponent.inputs = [
                            { id: 'R', x: 0, y: 15, connected: null },
                            { id: 'CLK', x: 0, y: 35, connected: null },
                            { id: 'S', x: 0, y: 55, connected: null }
                        ];
                        baseComponent.outputs = [
                            { id: 'Q', x: 100, y: 20, connected: [], state: false },
                            { id: 'Qn', x: 100, y: 50, connected: [], state: true }
                        ];
                        baseComponent.prevClk = false;
                        baseComponent.qState = false;
                        baseComponent.state = false;
                        break;
                    case 'VCC':
                        baseComponent.outputs = [
                            { id: 'out', x: 90, y: 25, connected: [] }
                        ];
                        baseComponent.state = true; // 常に高レベル
                        break;
                    case 'OSC':
                        baseComponent.outputs = [
                            { id: 'out', x: 90, y: 25, connected: [] }
                        ];
                        baseComponent.frequency = 1; // デフォルト1Hz
                        baseComponent.lastToggleTime = Date.now();
                        baseComponent.state = false;
                        break;
                }

                return baseComponent;
            }
            
            getPortAt(x, y, nearbyConnection = null) {
                // 基本tolerance（複数接続可能にするため調整）
                const tolerance = 25;
                
                // Z-index順（最前面から背面）でコンポーネントを取得
                const sortedComponents = Array.from(this.components.values())
                    .sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0));
                
                // tolerance内の全ポートを収集
                const portsWithinTolerance = [];
                
                for (const component of sortedComponents) {
                    // 入力ポートをチェック
                    for (const port of component.inputs || []) {
                        const portX = component.x + port.x;
                        const portY = component.y + port.y;
                        const distance = Math.sqrt(Math.pow(x - portX, 2) + Math.pow(y - portY, 2));
                        if (distance <= tolerance) {
                            portsWithinTolerance.push({
                                component, port, type: 'input', 
                                distance: distance,
                                portX: portX, portY: portY
                            });
                        }
                    }
                    
                    // 出力ポートをチェック
                    for (const port of component.outputs || []) {
                        const portX = component.x + port.x;
                        const portY = component.y + port.y;
                        const distance = Math.sqrt(Math.pow(x - portX, 2) + Math.pow(y - portY, 2));
                        if (distance <= tolerance) {
                            portsWithinTolerance.push({
                                component, port, type: 'output',
                                distance: distance,
                                portX: portX, portY: portY
                            });
                        }
                    }
                }
                
                if (portsWithinTolerance.length === 0) {
                    return null;
                }
                
                if (portsWithinTolerance.length === 1) {
                    const result = portsWithinTolerance[0];
                    console.log('getPortAt - Found single port at', result.portX, result.portY, 'on component with zIndex:', result.component.zIndex);
                    return { component: result.component, port: result.port, type: result.type };
                }
                
                // 複数のポートが範囲内にある場合の改善された選択ロジック
                console.log('getPortAt - Multiple ports found:', portsWithinTolerance.length);
                
                // 1. 出力端子を優先（複数接続可能にするため）
                const outputPorts = portsWithinTolerance.filter(p => p.type === 'output');
                const inputPorts = portsWithinTolerance.filter(p => p.type === 'input');
                
                // 出力端子がある場合は出力端子を優先
                const priorityPorts = outputPorts.length > 0 ? outputPorts : inputPorts.length > 0 ? inputPorts : portsWithinTolerance;
                
                // 2. 最前面のコンポーネント（最高Z-index）のポートを優先
                const maxZIndex = Math.max(...priorityPorts.map(p => p.component.zIndex || 0));
                const topMostPorts = priorityPorts.filter(p => (p.component.zIndex || 0) === maxZIndex);
                
                if (topMostPorts.length === 1) {
                    const result = topMostPorts[0];
                    console.log('getPortAt - Selected priority port at', result.portX, result.portY, 'type:', result.type, 'zIndex:', maxZIndex);
                    return { component: result.component, port: result.port, type: result.type };
                }
                
                // 3. 同じZ-indexのポートが複数ある場合、タッチ位置に最も近いものを選択
                // ただし、極端に近い場合（5px以内）は縦方向の位置を重視
                const veryClosePorts = topMostPorts.filter(p => p.distance <= 5);
                
                if (veryClosePorts.length > 1) {
                    // 非常に近い場合は、縦方向の距離を重視
                    let bestPort = veryClosePorts[0];
                    let minVerticalDistance = Math.abs(y - bestPort.portY);
                    
                    for (const portInfo of veryClosePorts.slice(1)) {
                        const verticalDistance = Math.abs(y - portInfo.portY);
                        if (verticalDistance < minVerticalDistance) {
                            minVerticalDistance = verticalDistance;
                            bestPort = portInfo;
                        }
                    }
                    
                    console.log('getPortAt - Selected port by vertical proximity at', bestPort.portX, bestPort.portY, 'type:', bestPort.type);
                    return { component: bestPort.component, port: bestPort.port, type: bestPort.type };
                } else {
                    // 一般的なケース：単純に距離で選択
                    const bestPort = topMostPorts.reduce((best, current) => 
                        current.distance < best.distance ? current : best
                    );
                    
                    console.log('getPortAt - Selected closest port at', bestPort.portX, bestPort.portY, 'type:', bestPort.type, 'distance:', bestPort.distance.toFixed(2));
                    return { component: bestPort.component, port: bestPort.port, type: bestPort.type };
                }
            }
            
            // 特定の部品の端子のみをチェックする関数
            getPortAtComponent(component, x, y) {
                const tolerance = 25; // タッチ操作に適したサイズに拡大（20→25）
                
                // tolerance内の全ポートを収集
                const portsWithinTolerance = [];
                
                // 入力ポートをチェック
                for (const port of component.inputs || []) {
                    const portX = component.x + port.x;
                    const portY = component.y + port.y;
                    const distance = Math.sqrt(Math.pow(x - portX, 2) + Math.pow(y - portY, 2));
                    if (distance <= tolerance) {
                        portsWithinTolerance.push({
                            port, type: 'input', distance: distance,
                            portX: portX, portY: portY,
                            verticalDistance: Math.abs(y - portY)
                        });
                    }
                }
                
                // 出力ポートをチェック
                for (const port of component.outputs || []) {
                    const portX = component.x + port.x;
                    const portY = component.y + port.y;
                    const distance = Math.sqrt(Math.pow(x - portX, 2) + Math.pow(y - portY, 2));
                    if (distance <= tolerance) {
                        portsWithinTolerance.push({
                            port, type: 'output', distance: distance,
                            portX: portX, portY: portY,
                            verticalDistance: Math.abs(y - portY)
                        });
                    }
                }
                
                if (portsWithinTolerance.length === 0) {
                    return null;
                }
                
                if (portsWithinTolerance.length === 1) {
                    const result = portsWithinTolerance[0];
                    console.log('getPortAtComponent - Found single port at', result.portX, result.portY, 'on component:', component.type);
                    return { component, port: result.port, type: result.type };
                }
                
                // 複数ポートの場合の改善された選択
                const veryClosePorts = portsWithinTolerance.filter(p => p.distance <= 5);
                
                if (veryClosePorts.length > 1) {
                    // 非常に近い場合は縦方向の距離を重視
                    const bestPort = veryClosePorts.reduce((best, current) => 
                        current.verticalDistance < best.verticalDistance ? current : best
                    );
                    console.log('getPortAtComponent - Selected port by vertical proximity at', bestPort.portX, bestPort.portY);
                    return { component, port: bestPort.port, type: bestPort.type };
                } else {
                    // 通常の場合は距離で選択
                    const bestPort = portsWithinTolerance.reduce((best, current) => 
                        current.distance < best.distance ? current : best
                    );
                    console.log('getPortAtComponent - Selected closest port at', bestPort.portX, bestPort.portY, 'distance:', bestPort.distance.toFixed(2));
                    return { component, port: bestPort.port, type: bestPort.type };
                }
            }
            
            findBestInputPort(component, x, y) {
                if (!component.inputs || component.inputs.length === 0) return null;
                
                // 入力端子候補を評価
                const portCandidates = [];
                
                for (const port of component.inputs) {
                    const portX = component.x + port.x;
                    const portY = component.y + port.y;
                    const distance = Math.sqrt(Math.pow(x - portX, 2) + Math.pow(y - portY, 2));
                    const verticalDistance = Math.abs(y - portY);
                    const horizontalDistance = Math.abs(x - portX);
                    
                    portCandidates.push({
                        port, portX, portY, distance, verticalDistance, horizontalDistance
                    });
                }
                
                // 近接性による優先順位付き選択
                portCandidates.sort((a, b) => {
                    // 非常に近い場合（10px以内）は縦方向の距離を重視
                    if (a.distance <= 10 && b.distance <= 10) {
                        const verticalDiff = a.verticalDistance - b.verticalDistance;
                        if (Math.abs(verticalDiff) > 2) { // 縦方向に2px以上差がある場合
                            return verticalDiff;
                        }
                        // 縦方向がほぼ同じ場合は全体距離で決定
                        return a.distance - b.distance;
                    }
                    
                    // 一般的なケース：全体距離で選択
                    return a.distance - b.distance;
                });
                
                const bestCandidate = portCandidates[0];
                console.log(`findBestInputPort - Selected input port at (${bestCandidate.portX}, ${bestCandidate.portY}) with distance ${bestCandidate.distance.toFixed(2)}`);
                
                return { component, port: bestCandidate.port, type: 'input' };
            }
            
            findBestOutputPort(component, x, y) {
                if (!component.outputs || component.outputs.length === 0) return null;
                
                // 出力端子候補を評価
                const portCandidates = [];
                
                for (const port of component.outputs) {
                    const portX = component.x + port.x;
                    const portY = component.y + port.y;
                    const distance = Math.sqrt(Math.pow(x - portX, 2) + Math.pow(y - portY, 2));
                    const verticalDistance = Math.abs(y - portY);
                    const horizontalDistance = Math.abs(x - portX);
                    
                    portCandidates.push({
                        port, portX, portY, distance, verticalDistance, horizontalDistance
                    });
                }
                
                // 近接性による優先順位付き選択
                portCandidates.sort((a, b) => {
                    // 非常に近い場合（10px以内）は縦方向の距離を重視
                    if (a.distance <= 10 && b.distance <= 10) {
                        const verticalDiff = a.verticalDistance - b.verticalDistance;
                        if (Math.abs(verticalDiff) > 2) { // 縦方向に2px以上差がある場合
                            return verticalDiff;
                        }
                        // 縦方向がほぼ同じ場合は全体距離で決定
                        return a.distance - b.distance;
                    }
                    
                    // 一般的なケース：全体距離で選択
                    return a.distance - b.distance;
                });
                
                const bestCandidate = portCandidates[0];
                console.log(`findBestOutputPort - Selected output port at (${bestCandidate.portX}, ${bestCandidate.portY}) with distance ${bestCandidate.distance.toFixed(2)}`);
                
                return { component, port: bestCandidate.port, type: 'output' };
            }
            
            startConnection(portInfo) {
                this.isConnecting = true;
                this.connectionStart = portInfo;
                console.log('startConnection - Port:', portInfo.type, 'Component:', portInfo.component.type);
            }
            
            completeConnection(startPort, endPort) {
                console.log('completeConnection - Start:', startPort.type, 'End:', endPort.type);
                
                // 接続の妥当性をチェック
                if (startPort.type === endPort.type) {
                    console.log('Cannot connect same type ports');
                    return; // 同じタイプは接続不可
                }
                if (startPort.component === endPort.component) {
                    console.log('Cannot connect same component');
                    return; // 同じ部品内は接続不可
                }
                
                let outputPort = startPort.type === 'output' ? startPort : endPort;
                let inputPort = startPort.type === 'input' ? startPort : endPort;
                
                // 既存の接続をチェック
                if (inputPort.port.connected) {
                    this.removeConnection(inputPort.port.connected);
                }
                
                // 新しい接続を作成
                const connection = {
                    id: 'conn_' + Date.now(),
                    from: { component: outputPort.component, port: outputPort.port },
                    to: { component: inputPort.component, port: inputPort.port }
                };
                
                console.log('Connection created:', connection.id);
                this.connections.push(connection);
                inputPort.port.connected = connection.id;
                outputPort.port.connected = outputPort.port.connected || [];
                outputPort.port.connected.push(connection.id);
                
                this.saveState();
                this.updateSimulation();
            }
            
            handleGlobalMouseMove(event) {
                if (this.isDragging && this.selectedComponent) {
                    // キャンバス外でもマウス位置を取得して部品を移動
                    this.handlePointerMove(event);
                }
            }
            
            handleGlobalMouseUp(event) {
                if (this.isDragging) {
                    // グローバルイベントリスナーを削除
                    document.removeEventListener('mousemove', this.globalMouseMoveHandler);
                    document.removeEventListener('mouseup', this.globalMouseUpHandler);
                    
                    // 通常のマウスアップ処理を実行
                    this.handlePointerUp(event);
                }
            }
            
            cancelConnection() {
                console.log('cancelConnection - Was connecting:', this.isConnecting);
                this.isConnecting = false;
                this.connectionStart = null;
            }
            
            removeConnection(connectionId) {
                const connectionIndex = this.connections.findIndex(c => c.id === connectionId);
                if (connectionIndex === -1) return;
                
                const connection = this.connections[connectionIndex];
                
                // ポートから接続情報を削除
                connection.to.port.connected = null;
                if (connection.from.port.connected) {
                    const index = connection.from.port.connected.indexOf(connectionId);
                    if (index > -1) {
                        connection.from.port.connected.splice(index, 1);
                    }
                }
                
                this.connections.splice(connectionIndex, 1);
            }
            
            toggleInput(component) {
                if (component.userState === undefined) {
                    component.userState = component.state; // 初期化
                }
                component.userState = !component.userState;
                // console.log('toggleInput - Component:', component.type, 'ID:', component.id, 'New userState:', component.userState);
                this.updateSimulation();
                this.render();
                this.saveState();
            }
            
            adjustOscillatorFrequency(component) {
                const currentFrequency = component.frequency || 1;
                const newFrequency = prompt(`クロック周波数を設定してください (0.1〜100Hz)\n現在: ${currentFrequency}Hz`, currentFrequency);
                
                if (newFrequency !== null) {
                    const frequency = parseFloat(newFrequency);
                    if (!isNaN(frequency) && frequency >= 0.1 && frequency <= 100) {
                        component.frequency = frequency;
                        component.lastToggleTime = Date.now(); // リセット
                        this.render();
                        this.saveState();
                    } else {
                        alert('周波数は0.1〜100Hzの範囲で入力してください。');
                    }
                }
            }
            
            updateSimulation() {
                if (!this.isSimulating) return;
                
                // 複数回更新して状態の安定化を図る（フリップフロップの状態伝播のため）
                for (let iteration = 0; iteration < 3; iteration++) {
                    // 各部品の状態を計算
                    for (const component of this.components.values()) {
                        this.calculateComponentState(component);
                    }
                }
                
                this.render();
            }
            
            calculateComponentState(component) {
                if (component.type === 'INPUT' || component.type === 'SWITCH') {
                    // 入力部品の出力は手動状態とパワー入力の AND 演算
                    const powerInput = this.getInputValue(component, 'power');
                    // パワー接続がない場合は常にON（従来の動作を保持）
                    const hasPower = powerInput || !component.inputs.find(input => input.id === 'power').connected;
                    // userStateを保存して、実際の出力状態を計算
                    if (component.userState === undefined) {
                        component.userState = component.state; // 初期化
                    }
                    component.state = component.userState && hasPower;
                    return;
                }
                
                // 入力値を取得
                const inputs = (component.inputs || []).map(port => {
                    if (!port.connected) return false;
                    
                    const connection = this.connections.find(c => c.id === port.connected);
                    if (!connection) return false;
                    
                    // フリップフロップの場合、特定の出力ピンの状態を取得
                    const fromComponent = connection.from.component;
                    if (['DFF', 'JKFF', 'TFF', 'RSFF'].includes(fromComponent.type)) {
                        const fromPort = connection.from.port;
                        if (fromPort.id === 'Q') {
                            return fromComponent.qState;
                        } else if (fromPort.id === 'Qn') {
                            return !fromComponent.qState;
                        }
                    }
                    
                    return connection.from.component.state || false;
                });
                
                // 論理演算を実行
                switch (component.type) {
                    case 'AND':
                        component.state = inputs.length >= 2 && inputs.every(Boolean);
                        break;
                    case 'OR':
                        component.state = inputs.some(Boolean);
                        break;
                    case 'NOT':
                        component.state = inputs.length > 0 && !inputs[0];
                        break;
                    case 'XOR':
                        component.state = inputs.length >= 2 && inputs.filter(Boolean).length === 1;
                        break;
                    case 'NAND':
                        component.state = !(inputs.length >= 2 && inputs.every(Boolean));
                        break;
                    case 'NOR':
                        component.state = !inputs.some(Boolean);
                        break;
                    case 'OUTPUT':
                    case 'LED':
                        component.state = inputs.length > 0 && inputs[0];
                        break;
                    case 'DFF':
                        this.updateDFlipFlop(component);
                        break;
                    case 'JKFF':
                        this.updateJKFlipFlop(component);
                        break;
                    case 'TFF':
                        this.updateTFlipFlop(component);
                        break;
                    case 'RSFF':
                        this.updateRSFlipFlop(component);
                        break;
                    case 'VCC':
                        component.state = true; // 常に高レベル
                        break;
                    case 'OSC':
                        this.updateOscillator(component);
                        break;
                    default:
                        component.state = false;
                }
            }

            updateDFlipFlop(component) {
                const dInput = this.getInputValue(component, 'D');
                const clkInput = this.getInputValue(component, 'CLK');
                
                // クロックの立ち上がりエッジで状態を更新
                if (clkInput && !component.prevClk) {
                    component.qState = dInput;
                }
                component.prevClk = clkInput;
                
                // 出力を設定
                this.setOutputValue(component, 'Q', component.qState);
                this.setOutputValue(component, 'Qn', !component.qState);
                component.state = component.qState;
            }

            updateJKFlipFlop(component) {
                const jInput = this.getInputValue(component, 'J');
                const kInput = this.getInputValue(component, 'K');
                const clkInput = this.getInputValue(component, 'CLK');
                
                // クロックの立ち上がりエッジで状態を更新
                if (clkInput && !component.prevClk) {
                    if (jInput && kInput) {
                        // J=1, K=1: トグル
                        component.qState = !component.qState;
                    } else if (jInput) {
                        // J=1, K=0: セット
                        component.qState = true;
                    } else if (kInput) {
                        // J=0, K=1: リセット
                        component.qState = false;
                    }
                    // J=0, K=0: 保持（何もしない）
                }
                component.prevClk = clkInput;
                
                // 出力を設定
                this.setOutputValue(component, 'Q', component.qState);
                this.setOutputValue(component, 'Qn', !component.qState);
                component.state = component.qState;
            }

            updateTFlipFlop(component) {
                const tInput = this.getInputValue(component, 'T');
                
                // T入力の立ち上がりエッジで状態を更新
                if (tInput && !component.prevT) {
                    component.qState = !component.qState;
                }
                component.prevT = tInput;
                
                // 出力を設定
                this.setOutputValue(component, 'Q', component.qState);
                this.setOutputValue(component, 'Qn', !component.qState);
                component.state = component.qState;
            }

            updateRSFlipFlop(component) {
                const rInput = this.getInputValue(component, 'R');
                const sInput = this.getInputValue(component, 'S');
                const clkInput = this.getInputValue(component, 'CLK');
                
                // 同期型（クロックエッジ）と非同期型（即座）の両方をサポート
                let shouldUpdate = false;
                
                // クロック信号が接続されている場合は同期型として動作
                const clkConnected = component.inputs.find(i => i.id === 'CLK')?.connected;
                if (clkConnected) {
                    // クロックの立ち上がりエッジで状態を更新
                    shouldUpdate = clkInput && !component.prevClk;
                    component.prevClk = clkInput;
                } else {
                    // クロック未接続の場合は非同期型として動作（即座に更新）
                    shouldUpdate = true;
                }
                
                if (shouldUpdate) {
                    if (!rInput && sInput) {
                        // R=0, S=1: セット
                        component.qState = true;
                    } else if (rInput && !sInput) {
                        // R=1, S=0: リセット
                        component.qState = false;
                    }
                    // R=0, S=0: 保持
                    // R=1, S=1: 不定（通常は使用しない）
                }
                
                // 出力を設定
                this.setOutputValue(component, 'Q', component.qState);
                this.setOutputValue(component, 'Qn', !component.qState);
                component.state = component.qState;
            }

            updateOscillator(component) {
                const now = Date.now();
                
                // 周波数に基づいてトグル
                const interval = 1000 / (component.frequency * 2); // 半周期
                if (now - component.lastToggleTime >= interval) {
                    component.state = !component.state;
                    component.lastToggleTime = now;
                }
            }

            getInputValue(component, inputId) {
                const input = component.inputs?.find(i => i.id === inputId);
                if (!input?.connected) return false;
                
                const connection = this.connections.find(conn => 
                    conn.to.component === component && conn.to.port === input
                );
                
                if (!connection) return false;
                
                // フリップフロップの場合、特定の出力ピンの状態を取得
                const fromComponent = connection.from.component;
                if (['DFF', 'JKFF', 'TFF', 'RSFF'].includes(fromComponent.type)) {
                    const fromPort = connection.from.port;
                    if (fromPort.id === 'Q') {
                        return fromComponent.qState;
                    } else if (fromPort.id === 'Qn') {
                        return !fromComponent.qState;
                    }
                }
                
                return connection.from.component.state || false;
            }

            setOutputValue(component, outputId, value) {
                const output = component.outputs?.find(o => o.id === outputId);
                if (output) {
                    output.state = value;
                    // 接続されたコンポーネントに状態を伝播
                    if (output.connected && output.connected.length > 0) {
                        output.connected.forEach(connectedPort => {
                            if (connectedPort.component) {
                                // 接続先のコンポーネントの入力状態を更新
                                connectedPort.state = value;
                            }
                        });
                    }
                }
            }

            getComponentAt(x, y, cycleSelection = false) {
                // 指定位置の全てのコンポーネントを取得（Z-index降順でソート）
                const componentsAtPosition = [];
                for (const component of this.components.values()) {
                    if (x >= component.x && x <= component.x + component.width &&
                        y >= component.y && y <= component.y + component.height) {
                        componentsAtPosition.push(component);
                    }
                }
                
                // Z-indexで降順ソート（最前面のコンポーネントが最初に来る）
                componentsAtPosition.sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0));
                
                if (componentsAtPosition.length === 0) {
                    // console.log('No component found at', x, y);
                    this.overlappingComponents = [];
                    this.currentOverlapIndex = 0;
                    this.lastClickPosition = null;
                    return null;
                }
                
                if (componentsAtPosition.length === 1) {
                    // 重なりなし
                    return componentsAtPosition[0];
                }
                
                // 重なりあり - 循環選択の処理
                const clickThreshold = 20; // 同じ位置判定の許容範囲
                const isSamePosition = this.lastClickPosition && 
                    Math.abs(x - this.lastClickPosition.x) < clickThreshold &&
                    Math.abs(y - this.lastClickPosition.y) < clickThreshold;
                
                if (cycleSelection && isSamePosition && 
                    JSON.stringify(this.overlappingComponents.map(c => c.id)) === 
                    JSON.stringify(componentsAtPosition.map(c => c.id))) {
                    // 同じ位置での連続クリック - 次のコンポーネントを選択
                    this.currentOverlapIndex = (this.currentOverlapIndex + 1) % componentsAtPosition.length;
                } else {
                    // 新しい位置または初回 - 最初のコンポーネントを選択
                    this.overlappingComponents = componentsAtPosition;
                    this.currentOverlapIndex = 0;
                }
                
                this.lastClickPosition = { x, y };
                
                const selectedComponent = componentsAtPosition[this.currentOverlapIndex];
                console.log(`Selected component ${this.currentOverlapIndex + 1}/${componentsAtPosition.length}:`, 
                           selectedComponent.type, selectedComponent.id);
                
                return selectedComponent;
            }
            
            isInComponentCenter(component, x, y) {
                // 部品の中心部分（端子から離れた部分）かどうかを判定
                const centerX = component.x + component.width / 2;
                const centerY = component.y + component.height / 2;
                const centerRadius = Math.min(component.width, component.height) * 0.4; // 中心部の判定半径（0.3→0.4に拡大）
                
                const distanceToCenter = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                const isInCenter = distanceToCenter <= centerRadius;
                
                console.log(`isInComponentCenter: distance=${distanceToCenter.toFixed(2)}, radius=${centerRadius.toFixed(2)}, isCenter=${isInCenter}`);
                return isInCenter;
            }

            findNearbyConnection(x, y, searchRadius) {
                // 指定半径内に接続線があるかを判定（直接ヒットしない場合の補助判定用）
                for (const connection of this.connections) {
                    const fromX = connection.from.component.x + connection.from.port.x;
                    const fromY = connection.from.component.y + connection.from.port.y;
                    const toX = connection.to.component.x + connection.to.port.x;
                    const toY = connection.to.component.y + connection.to.port.y;
                    
                    // ベジエ曲線の複数点での距離チェック
                    const midX = (fromX + toX) / 2;
                    
                    for (let i = 0; i <= 10; i++) {
                        const t = i / 10;
                        const bezierX = Math.pow(1-t, 3) * fromX + 
                                       3 * Math.pow(1-t, 2) * t * midX + 
                                       3 * (1-t) * Math.pow(t, 2) * midX + 
                                       Math.pow(t, 3) * toX;
                        const bezierY = Math.pow(1-t, 3) * fromY + 
                                       3 * Math.pow(1-t, 2) * t * fromY + 
                                       3 * (1-t) * Math.pow(t, 2) * toY + 
                                       Math.pow(t, 3) * toY;
                        
                        const distance = Math.sqrt(Math.pow(x - bezierX, 2) + Math.pow(y - bezierY, 2));
                        if (distance <= searchRadius) {
                            return connection;
                        }
                    }
                }
                return null;
            }

            getConnectionAt(x, y) {
                const tolerance = 35; // 接続線の当たり判定の許容範囲（端子より優先させるために拡大）
                
                // 接続線を接続されている部品の最大Z-indexでソート（高い順）
                const sortedConnections = this.connections.slice().sort((a, b) => {
                    const aMaxZ = Math.max(a.from.component.zIndex || 0, a.to.component.zIndex || 0);
                    const bMaxZ = Math.max(b.from.component.zIndex || 0, b.to.component.zIndex || 0);
                    return bMaxZ - aMaxZ;
                });
                
                for (const connection of sortedConnections) {
                    const fromX = connection.from.component.x + connection.from.port.x;
                    const fromY = connection.from.component.y + connection.from.port.y;
                    const toX = connection.to.component.x + connection.to.port.x;
                    const toY = connection.to.component.y + connection.to.port.y;
                    
                    // ベジエ曲線の詳細な当たり判定（より多くの点で判定）
                    const midX = (fromX + toX) / 2;
                    
                    // ベジエ曲線の複数点での当たり判定
                    const points = [];
                    for (let i = 0; i <= 20; i++) {
                        const t = i / 20;
                        // 正確なベジエ曲線の計算（3次ベジエ曲線）
                        const bezierX = Math.pow(1-t, 3) * fromX + 
                                       3 * Math.pow(1-t, 2) * t * midX + 
                                       3 * (1-t) * Math.pow(t, 2) * midX + 
                                       Math.pow(t, 3) * toX;
                        const bezierY = Math.pow(1-t, 3) * fromY + 
                                       3 * Math.pow(1-t, 2) * t * fromY + 
                                       3 * (1-t) * Math.pow(t, 2) * toY + 
                                       Math.pow(t, 3) * toY;
                        
                        points.push({ x: bezierX, y: bezierY });
                    }
                    
                    // この接続線の最短距離を計算
                    let minDistanceForConnection = Infinity;
                    for (const point of points) {
                        const distance = Math.sqrt(Math.pow(x - point.x, 2) + Math.pow(y - point.y, 2));
                        minDistanceForConnection = Math.min(minDistanceForConnection, distance);
                    }
                    
                    // tolerance内の最初の接続線を返す（Z-index順で最上位）
                    if (minDistanceForConnection <= tolerance) {
                        const maxZ = Math.max(connection.from.component.zIndex || 0, connection.to.component.zIndex || 0);
                        console.log('getConnectionAt - Found connection with maxZ:', maxZ);
                        return connection;
                    }
                }
                
                return null;
            }

            deleteSelected() {
                if (this.selectedComponent) {
                    // 削除するコンポーネントに接続された接続線をすべて削除
                    const componentToDelete = this.selectedComponent;
                    const connectionsToDelete = this.connections.filter(connection => 
                        connection.from.component.id === componentToDelete.id || 
                        connection.to.component.id === componentToDelete.id
                    );
                    
                    // 接続線を削除
                    connectionsToDelete.forEach(connection => {
                        this.removeConnection(connection.id);
                    });
                    
                    // コンポーネントを削除
                    this.components.delete(componentToDelete.id);
                    this.selectedComponent = null;
                    this.render();
                    this.saveState();
                    this.updateSimulation();
                } else if (this.selectedConnection) {
                    this.removeConnection(this.selectedConnection.id);
                    this.selectedConnection = null;
                    this.render();
                    this.saveState();
                    this.updateSimulation();
                }
            }

            clearAll() {
                if (confirm('すべての部品を削除しますか？')) {
                    this.components.clear();
                    this.connections = [];
                    this.selectedComponent = null;
                    this.selectedConnection = null;
                    this.render();
                    this.saveState();
                }
            }

            saveState() {
                const state = {
                    components: Array.from(this.components.values()),
                    connections: [...this.connections]
                };
                
                this.history = this.history.slice(0, this.historyIndex + 1);
                this.history.push(JSON.stringify(state));
                this.historyIndex++;
                
                // 履歴の制限
                if (this.history.length > 50) {
                    this.history.shift();
                    this.historyIndex--;
                }
            }

            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.loadState(this.history[this.historyIndex]);
                }
            }

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.loadState(this.history[this.historyIndex]);
                }
            }

            loadState(stateStr) {
                const state = JSON.parse(stateStr);
                this.components.clear();
                
                // コンポーネントを復元
                state.components.forEach(comp => {
                    this.components.set(comp.id, comp);
                });
                
                // まず全てのポートの接続情報をクリア
                for (const component of this.components.values()) {
                    // 入力ポートの接続情報をクリア
                    if (component.inputs) {
                        component.inputs.forEach(port => {
                            port.connected = null;
                        });
                    }
                    // 出力ポートの接続情報をクリア
                    if (component.outputs) {
                        component.outputs.forEach(port => {
                            port.connected = [];
                        });
                    }
                }
                
                // 接続線を復元（コンポーネント参照を再構築）
                this.connections = state.connections.map(connection => {
                    const fromComponent = this.components.get(connection.from.component.id);
                    const toComponent = this.components.get(connection.to.component.id);
                    
                    if (fromComponent && toComponent) {
                        // 正しいポート参照を取得
                        const fromPort = fromComponent.outputs?.find(p => p.id === connection.from.port.id);
                        const toPort = toComponent.inputs?.find(p => p.id === connection.to.port.id);
                        
                        if (fromPort && toPort) {
                            const restoredConnection = {
                                ...connection,
                                from: {
                                    component: fromComponent,
                                    port: fromPort
                                },
                                to: {
                                    component: toComponent,
                                    port: toPort
                                }
                            };
                            
                            // ポートの接続情報も復元
                            toPort.connected = connection.id;
                            if (!fromPort.connected) {
                                fromPort.connected = [];
                            }
                            fromPort.connected.push(connection.id);
                            
                            return restoredConnection;
                        }
                    }
                    return null; // 無効な接続線は除外
                }).filter(Boolean); // null を除去
                
                this.selectedComponent = null;
                this.selectedConnection = null;
                this.render();
                this.updateSimulation();
            }


            saveCircuit() {
                // 接続情報を明示的に含めたデータ構造を作成
                const componentsData = Array.from(this.components.values()).map(component => ({
                    ...component,
                    inputs: component.inputs ? component.inputs.map(port => ({
                        id: port.id,
                        x: port.x,
                        y: port.y,
                        connected: port.connected
                    })) : [],
                    outputs: component.outputs ? component.outputs.map(port => ({
                        id: port.id,
                        x: port.x,
                        y: port.y,
                        connected: port.connected
                    })) : []
                }));
                
                const connectionsData = this.connections.map(connection => ({
                    id: connection.id,
                    from: {
                        component: { id: connection.from.component.id },
                        port: { id: connection.from.port.id }
                    },
                    to: {
                        component: { id: connection.to.component.id },
                        port: { id: connection.to.port.id }
                    }
                }));
                
                const data = {
                    version: "1.0",
                    components: componentsData,
                    connections: connectionsData
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'circuit.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            loadCircuit() {
                document.getElementById('file-input').click();
            }

            handleFileLoad(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        this.components.clear();
                        
                        // コンポーネントを復元
                        data.components.forEach(comp => {
                            this.components.set(comp.id, comp);
                        });
                        
                        // まず全てのポートの接続情報をクリア
                        for (const component of this.components.values()) {
                            if (component.inputs) {
                                component.inputs.forEach(port => {
                                    port.connected = null;
                                });
                            }
                            if (component.outputs) {
                                component.outputs.forEach(port => {
                                    port.connected = [];
                                });
                            }
                        }
                        
                        // 接続線を復元（コンポーネント参照を再構築）
                        this.connections = (data.connections || []).map(connection => {
                            const fromComponent = this.components.get(connection.from.component.id);
                            const toComponent = this.components.get(connection.to.component.id);
                            
                            if (fromComponent && toComponent) {
                                const fromPort = fromComponent.outputs?.find(p => p.id === connection.from.port.id);
                                const toPort = toComponent.inputs?.find(p => p.id === connection.to.port.id);
                                
                                if (fromPort && toPort) {
                                    const restoredConnection = {
                                        ...connection,
                                        from: {
                                            component: fromComponent,
                                            port: fromPort
                                        },
                                        to: {
                                            component: toComponent,
                                            port: toPort
                                        }
                                    };
                                    
                                    // ポートの接続情報も復元
                                    toPort.connected = connection.id;
                                    if (!fromPort.connected) {
                                        fromPort.connected = [];
                                    }
                                    fromPort.connected.push(connection.id);
                                    
                                    return restoredConnection;
                                }
                            }
                            return null;
                        }).filter(Boolean);
                        
                        this.selectedComponent = null;
                        this.selectedConnection = null;
                        this.render();
                        this.updateSimulation();
                        this.saveState();
                    } catch (error) {
                        alert('ファイルの読み込みに失敗しました');
                    }
                };
                reader.readAsText(file);
            }

            exportImage() {
                const link = document.createElement('a');
                link.download = 'circuit.png';
                link.href = this.canvas.toDataURL();
                link.click();
            }

            render() {
                const ctx = this.ctx;
                const width = this.canvas.clientWidth;
                const height = this.canvas.clientHeight;
                
                // クリア
                ctx.clearRect(0, 0, width, height);
                
                // 座標変換
                ctx.save();
                ctx.translate(this.panX, this.panY);
                ctx.scale(this.scale, this.scale);
                
                // 部品描画（Z-index順）
                const sortedComponents = Array.from(this.components.values())
                    .sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0));
                for (const component of sortedComponents) {
                    this.drawComponent(ctx, component);
                }
                
                // 接続線描画（部品の上に表示）
                this.drawConnections(ctx);
                
                // 接続中の線描画
                if (this.isConnecting && this.connectionStart) {
                    this.drawConnectionPreview(ctx);
                }
                
                ctx.restore();
            }

            drawComponent(ctx, component) {
                const isSelected = component === this.selectedComponent;
                const isActive = component.state;
                
                // 論理回路記号を描画
                this.drawLogicGateSymbol(ctx, component, isSelected, isActive);
                
                // LEDは豆電球として描画
                if (component.type === 'LED') {
                    const x = component.x;
                    const y = component.y;
                    const w = component.width;
                    const h = component.height;
                    
                    // 枠の描画
                    let bgColor = '#ffffff';
                    if (isActive) {
                        bgColor = '#ffeb3b'; // アクティブな出力は黄色
                    } else if (isSelected) {
                        bgColor = '#e3f2fd'; // 選択状態
                    }
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(x, y, w, h);
                    
                    // 枠線
                    ctx.strokeStyle = isSelected ? '#2196f3' : '#666666';
                    ctx.lineWidth = isSelected ? 2 : 1;
                    ctx.strokeRect(x, y, w, h);
                    
                    // 豆電球の描画
                    this.drawLightBulb(ctx, x + 8, y + 8, w - 16, h - 16, isActive);
                    
                    // ラベル
                    ctx.fillStyle = '#333333';
                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        'LED',
                        x + w / 2,
                        y + h - 8
                    );
                }
                // OUTPUTは1/0表示、その他は従来通り
                else if (component.type === 'OUTPUT') {
                    // 背景色は白固定
                    let bgColor = '#ffffff';
                    if (isSelected) {
                        bgColor = '#e3f2fd'; // 選択状態
                    }
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(component.x, component.y, component.width, component.height);
                    
                    // 枠線
                    ctx.strokeStyle = isSelected ? '#2196f3' : '#666666';
                    ctx.lineWidth = isSelected ? 2 : 1;
                    ctx.strokeRect(component.x, component.y, component.width, component.height);
                    
                    // 上部にOUTPUTラベル
                    ctx.fillStyle = '#666666';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        'OUTPUT',
                        component.x + component.width / 2,
                        component.y + component.height * 0.25
                    );
                    
                    // 中央に大きな1または0を表示
                    ctx.fillStyle = isActive ? '#4caf50' : '#f44336'; // 1は緑、0は赤
                    ctx.font = 'bold 24px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        isActive ? '1' : '0',
                        component.x + component.width / 2,
                        component.y + component.height * 0.65
                    );
                }
                // INPUTは1/0表示、SWITCHは従来通り
                else if (component.type === 'INPUT') {
                    // 背景色は白固定
                    let bgColor = '#ffffff';
                    if (isSelected) {
                        bgColor = '#e3f2fd'; // 選択状態
                    }
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(component.x, component.y, component.width, component.height);
                    
                    // 枠線
                    ctx.strokeStyle = isSelected ? '#2196f3' : '#666666';
                    ctx.lineWidth = isSelected ? 2 : 1;
                    ctx.strokeRect(component.x, component.y, component.width, component.height);
                    
                    // 上部にINPUTラベル
                    ctx.fillStyle = '#666666';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        'INPUT',
                        component.x + component.width / 2,
                        component.y + component.height * 0.25
                    );
                    
                    // 中央に大きな1または0を表示
                    ctx.fillStyle = isActive ? '#4caf50' : '#f44336'; // 1は緑、0は赤
                    ctx.font = 'bold 24px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        isActive ? '1' : '0',
                        component.x + component.width / 2,
                        component.y + component.height * 0.65
                    );
                }
                // スイッチは従来通り四角形で描画
                else if (component.type === 'SWITCH') {
                    
                    // 背景色を状態に応じて変更
                    let bgColor = '#ffffff';
                    if (isActive) {
                        bgColor = '#4caf50'; // アクティブな入力は緑色
                    } else if (isSelected) {
                        bgColor = '#e3f2fd'; // 選択状態は最後に判定
                    }
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(component.x, component.y, component.width, component.height);
                    
                    // 枠線
                    ctx.strokeStyle = isSelected ? '#2196f3' : '#666666';
                    ctx.lineWidth = isSelected ? 2 : 1;
                    ctx.strokeRect(component.x, component.y, component.width, component.height);
                    
                    // ラベル
                    ctx.fillStyle = '#333333';
                    ctx.font = '14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        component.type,
                        component.x + component.width / 2,
                        component.y + component.height / 2
                    );
                }
                // VCC（電源）の描画
                else if (component.type === 'VCC') {
                    let bgColor = '#ffffff';
                    if (isSelected) {
                        bgColor = '#e3f2fd';
                    }
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(component.x, component.y, component.width, component.height);
                    
                    ctx.strokeStyle = isSelected ? '#2196f3' : '#666666';
                    ctx.lineWidth = isSelected ? 2 : 1;
                    ctx.strokeRect(component.x, component.y, component.width, component.height);
                    
                    // VCCラベルと雷マーク
                    ctx.fillStyle = '#4caf50'; // 常に緑色（高レベル）
                    ctx.font = 'bold 16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        '⚡ VCC',
                        component.x + component.width / 2,
                        component.y + component.height / 2
                    );
                }
                // OSC（オシレーター）の描画
                else if (component.type === 'OSC') {
                    let bgColor = isActive ? '#ffeb3b' : '#ffffff';
                    if (isSelected) {
                        bgColor = '#e3f2fd';
                    }
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(component.x, component.y, component.width, component.height);
                    
                    ctx.strokeStyle = isSelected ? '#2196f3' : '#666666';
                    ctx.lineWidth = isSelected ? 2 : 1;
                    ctx.strokeRect(component.x, component.y, component.width, component.height);
                    
                    // OSCラベルとクロックマーク、周波数表示
                    ctx.fillStyle = '#333333';
                    ctx.font = 'bold 12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        '⏰ OSC',
                        component.x + component.width / 2,
                        component.y + component.height / 2 - 8
                    );
                    
                    // 周波数表示
                    ctx.font = '10px sans-serif';
                    ctx.fillText(
                        `${component.frequency || 1}Hz`,
                        component.x + component.width / 2,
                        component.y + component.height / 2 + 8
                    );
                }
                
                // ピン描画
                // 入力ピン
                component.inputs?.forEach(pin => {
                    ctx.fillStyle = pin.connected ? '#2196f3' : '#4caf50';
                    ctx.beginPath();
                    ctx.arc(component.x + pin.x, component.y + pin.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
                
                // 出力ピン
                component.outputs?.forEach(pin => {
                    ctx.fillStyle = (pin.connected && pin.connected.length > 0) ? '#2196f3' : '#ff9800';
                    ctx.beginPath();
                    ctx.arc(component.x + pin.x, component.y + pin.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
            }
            
            drawLogicGateSymbol(ctx, component, isSelected, isActive) {
                const x = component.x;
                const y = component.y;
                const w = component.width;
                const h = component.height;
                
                // 論理ゲートとフリップフロップ以外はここでは描画しない
                if (!['AND', 'OR', 'XOR', 'NAND', 'NOR', 'NOT', 'DFF', 'JKFF', 'TFF', 'RSFF'].includes(component.type)) {
                    return;
                }
                
                // 色設定
                const fillColor = isSelected ? '#e3f2fd' : '#ffffff';
                const strokeColor = isSelected ? '#2196f3' : '#333333';
                const lineWidth = isSelected ? 2 : 1;
                
                // 基本ゲートの場合は枠を描画
                if (['AND', 'OR', 'XOR', 'NAND', 'NOR', 'NOT'].includes(component.type)) {
                    // 枠の描画
                    ctx.fillStyle = fillColor;
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = lineWidth;
                    ctx.fillRect(x, y, w, h);
                    ctx.strokeRect(x, y, w, h);
                    
                    // 図形の描画（枠の中に描画）
                    ctx.fillStyle = '#ffffff'; // 図形は白色
                    ctx.strokeStyle = '#333333'; // 図形の線は濃いグレー
                    ctx.lineWidth = 1;
                    
                    switch (component.type) {
                        case 'AND':
                            this.drawANDGateInside(ctx, x + 8, y + 8, w - 16, h - 16);
                            this.drawGateLabel(ctx, 'AND', x, y, w, h);
                            break;
                        case 'OR':
                            this.drawORGateInside(ctx, x + 8, y + 8, w - 16, h - 16);
                            this.drawGateLabel(ctx, 'OR', x, y, w, h);
                            break;
                        case 'XOR':
                            this.drawXORGateInside(ctx, x + 8, y + 8, w - 16, h - 16);
                            this.drawGateLabel(ctx, 'XOR', x, y, w, h);
                            break;
                        case 'NAND':
                            this.drawANDGateInside(ctx, x + 8, y + 8, w - 26, h - 16);
                            this.drawNotBubble(ctx, x + w - 29, y + h/2, 4);
                            this.drawGateLabel(ctx, 'NAND', x, y, w, h);
                            break;
                        case 'NOR':
                            this.drawORGateInside(ctx, x + 8, y + 8, w - 26, h - 16);
                            this.drawNotBubble(ctx, x + w - 18, y + h/2, 4);
                            this.drawGateLabel(ctx, 'NOR', x, y, w, h);
                            break;
                        case 'NOT':
                            this.drawNOTGateInside(ctx, x + 8, y + 8, w - 26, h - 16);
                            this.drawNotBubble(ctx, x + w - 18, y + h/2, 4);
                            this.drawGateLabel(ctx, 'NOT', x, y, w, h);
                            break;
                    }
                } 
                // フリップフロップの場合
                else if (['DFF', 'JKFF', 'TFF', 'RSFF'].includes(component.type)) {
                    switch (component.type) {
                        case 'DFF':
                            this.drawFlipFlop(ctx, x, y, w, h, 'D', component);
                            break;
                        case 'JKFF':
                            this.drawFlipFlop(ctx, x, y, w, h, 'JK', component);
                            break;
                        case 'TFF':
                            this.drawFlipFlop(ctx, x, y, w, h, 'T', component);
                            break;
                        case 'RSFF':
                            this.drawFlipFlop(ctx, x, y, w, h, 'RS', component);
                            break;
                    }
                } else {
                    // 他の部品（INPUT、OUTPUT等）は従来通り
                    ctx.fillStyle = fillColor;
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = lineWidth;
                }
            }
            
            // 枠内描画用のゲート関数群
            drawANDGateInside(ctx, x, y, w, h) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + w * 0.6, y);
                ctx.arc(x + w * 0.6, y + h/2, h/2, -Math.PI/2, Math.PI/2);
                ctx.lineTo(x, y + h);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            drawORGateInside(ctx, x, y, w, h) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.quadraticCurveTo(x + w * 0.6, y, x + w, y + h/2);
                ctx.quadraticCurveTo(x + w * 0.6, y + h, x, y + h);
                ctx.quadraticCurveTo(x + w * 0.2, y + h/2, x, y);
                ctx.fill();
                ctx.stroke();
            }
            
            drawXORGateInside(ctx, x, y, w, h) {
                // 外側の曲線
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.quadraticCurveTo(x + w * 0.6, y, x + w, y + h/2);
                ctx.quadraticCurveTo(x + w * 0.6, y + h, x, y + h);
                ctx.quadraticCurveTo(x + w * 0.2, y + h/2, x, y);
                ctx.fill();
                ctx.stroke();
                
                // 内側の追加線
                ctx.beginPath();
                ctx.moveTo(x - 4, y);
                ctx.quadraticCurveTo(x + w * 0.2 - 4, y + h/2, x - 4, y + h);
                ctx.stroke();
            }
            
            drawNOTGateInside(ctx, x, y, w, h) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y + h);
                ctx.lineTo(x + w, y + h/2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            drawLightBulb(ctx, x, y, w, h, isActive) {
                ctx.save();
                
                const centerX = x + w / 2;
                const centerY = y + h / 2;
                const bulbWidth = w * 0.7;
                const bulbHeight = h * 0.8;
                
                // エレガントな豆電球の形（涙滴形）
                ctx.beginPath();
                
                // 上部の丸い部分
                const topRadius = bulbWidth * 0.35;
                const topCenterY = centerY - bulbHeight * 0.15;
                ctx.arc(centerX, topCenterY, topRadius, 0, Math.PI, true);
                
                // 下部のとがった部分（ベジェ曲線で滑らかに）
                ctx.bezierCurveTo(
                    centerX - topRadius, topCenterY,
                    centerX - bulbWidth * 0.2, centerY + bulbHeight * 0.3,
                    centerX, centerY + bulbHeight * 0.4
                );
                ctx.bezierCurveTo(
                    centerX + bulbWidth * 0.2, centerY + bulbHeight * 0.3,
                    centerX + topRadius, topCenterY,
                    centerX + topRadius, topCenterY
                );
                
                ctx.closePath();
                
                // グラデーション効果
                if (isActive) {
                    // 点灯時のグラデーション
                    const gradient = ctx.createRadialGradient(
                        centerX - topRadius * 0.3, topCenterY - topRadius * 0.3, 0,
                        centerX, centerY, topRadius
                    );
                    gradient.addColorStop(0, '#fffacd');
                    gradient.addColorStop(0.6, '#ffff00');
                    gradient.addColorStop(1, '#ffa500');
                    ctx.fillStyle = gradient;
                } else {
                    // 消灯時のグラデーション
                    const gradient = ctx.createRadialGradient(
                        centerX - topRadius * 0.3, topCenterY - topRadius * 0.3, 0,
                        centerX, centerY, topRadius
                    );
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.6, '#f0f0f0');
                    gradient.addColorStop(1, '#d0d0d0');
                    ctx.fillStyle = gradient;
                }
                
                ctx.fill();
                
                // 外枠
                ctx.strokeStyle = isActive ? '#cc8800' : '#999999';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // ソケット部分（下部の金属キャップ）
                const socketY = centerY + bulbHeight * 0.35;
                const socketHeight = h * 0.15;
                
                ctx.fillStyle = '#b8860b';
                ctx.fillRect(centerX - bulbWidth * 0.2, socketY, bulbWidth * 0.4, socketHeight);
                
                // ソケットの螺旋模様
                ctx.strokeStyle = '#8b7355';
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    const lineY = socketY + (socketHeight / 4) * (i + 1);
                    ctx.beginPath();
                    ctx.moveTo(centerX - bulbWidth * 0.18, lineY);
                    ctx.lineTo(centerX + bulbWidth * 0.18, lineY);
                    ctx.stroke();
                }
                
                // フィラメント（エレガントな曲線）
                if (isActive) {
                    ctx.strokeStyle = '#ff4500';
                    ctx.lineWidth = 1.5;
                } else {
                    ctx.strokeStyle = '#aaaaaa';
                    ctx.lineWidth = 1;
                }
                
                ctx.beginPath();
                // 中央の支柱
                ctx.moveTo(centerX, centerY + bulbHeight * 0.2);
                ctx.lineTo(centerX, topCenterY);
                
                // 美しい曲線のフィラメント
                ctx.moveTo(centerX - topRadius * 0.4, topCenterY - topRadius * 0.2);
                ctx.quadraticCurveTo(centerX, topCenterY - topRadius * 0.4, centerX + topRadius * 0.4, topCenterY - topRadius * 0.2);
                ctx.moveTo(centerX - topRadius * 0.3, topCenterY);
                ctx.quadraticCurveTo(centerX, topCenterY + topRadius * 0.3, centerX + topRadius * 0.3, topCenterY);
                
                ctx.stroke();
                
                // 点灯時の光のオーラ
                if (isActive) {
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.15)';
                    ctx.beginPath();
                    ctx.arc(centerX, topCenterY, topRadius * 1.8, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // 光の線
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI * 2) / 8;
                        const x1 = centerX + Math.cos(angle) * topRadius * 1.2;
                        const y1 = topCenterY + Math.sin(angle) * topRadius * 1.2;
                        const x2 = centerX + Math.cos(angle) * topRadius * 1.6;
                        const y2 = topCenterY + Math.sin(angle) * topRadius * 1.6;
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
            }
            
            // 従来のゲート関数（後方互換性のため残す）
            drawANDGate(ctx, x, y, w, h) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + w - h/2, y);
                ctx.arc(x + w - h/2, y + h/2, h/2, -Math.PI/2, Math.PI/2);
                ctx.lineTo(x, y + h);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            drawORGate(ctx, x, y, w, h) {
                ctx.beginPath();
                // 左側の曲線
                ctx.moveTo(x, y);
                ctx.quadraticCurveTo(x + w * 0.3, y + h/2, x, y + h);
                // 右側の曲線
                ctx.quadraticCurveTo(x + w * 0.7, y + h * 0.8, x + w, y + h/2);
                ctx.quadraticCurveTo(x + w * 0.7, y + h * 0.2, x, y);
                ctx.fill();
                ctx.stroke();
            }
            
            drawXORGate(ctx, x, y, w, h) {
                // ORゲートを描画
                this.drawORGate(ctx, x + 8, y, w - 8, h);
                
                // 左側の追加線
                ctx.beginPath();
                ctx.moveTo(x, y + h * 0.2);
                ctx.quadraticCurveTo(x + w * 0.2, y + h/2, x, y + h * 0.8);
                ctx.stroke();
            }
            
            drawNOTGate(ctx, x, y, w, h) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y + h);
                ctx.lineTo(x + w - 10, y + h/2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // NOTバブル (右端近くに配置)
                this.drawNotBubble(ctx, x + w - 8, y + h/2, 3);
            }
            
            drawNOTTriangle(ctx, x, y, w, h) {
                // NOT gate triangle only (without bubble)
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y + h);
                ctx.lineTo(x + w, y + h/2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            drawNotBubble(ctx, x, y, radius = 5) {
                ctx.beginPath();
                ctx.arc(x + radius, y, radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
            }
            
            drawGateLabel(ctx, label, x, y, w, h) {
                // テキストスタイル設定
                ctx.save();
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // ゲートタイプに応じて位置を微調整
                let centerX = x + w / 2;
                const centerY = y + h / 2 + 1; // 全てのラベルを1px下に移動
                
                switch (label) {
                    case 'AND':
                        centerX = x + w / 2 - 5; // 左に5px移動
                        break;
                    case 'NOT':
                        centerX = x + w / 2 - 8; // 左に8px移動（さらに3px左へ）
                        break;
                    case 'NAND':
                        centerX = x + w / 2 - 2; // 左に2px移動
                        break;
                    case 'NOR':
                        centerX = x + w / 2 - 2; // 左に2px移動
                        break;
                    case 'OR':
                    case 'XOR':
                        // ORとXORはそのまま中央
                        break;
                }
                
                ctx.fillText(label, centerX, centerY);
                ctx.restore();
            }
            
            drawFlipFlopIcon(ctx, x, y, w, h, type) {
                // フリップフロップの基本四角形
                ctx.fillRect(x, y, w, h);
                ctx.strokeRect(x, y, w, h);
                
                // タイプラベルを描画
                ctx.save();
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 8px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                if (type === 'JK') {
                    // JK-FFの場合、JとKを上下に分けて表示
                    ctx.fillText('J', x + w/2, y + h/3);
                    ctx.fillText('K', x + w/2, y + 2*h/3);
                } else if (type === 'RS') {
                    // RS-FFの場合、RとSを上下に分けて表示
                    ctx.fillText('R', x + w/2, y + h/3);
                    ctx.fillText('S', x + w/2, y + 2*h/3);
                } else {
                    // D-FF、T-FFの場合は中央に表示
                    ctx.fillText(type, x + w/2, y + h/2);
                }
                
                // クロック入力を示す小さな三角形（TFFを除く）
                if (type !== 'T') {
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x - 1, y + h/2 + 2);
                    ctx.lineTo(x + 2, y + h/2);
                    ctx.lineTo(x - 1, y + h/2 - 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            drawFlipFlop(ctx, x, y, w, h, type, component) {
                // フリップフロップの基本四角形
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(x, y, w, h);
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);
                
                // タイプラベルを描画
                ctx.save();
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                if (type === 'JK') {
                    // JK-FFの場合、JとKを分けて表示
                    ctx.fillText('JK-FF', x + w/2, y + 15);
                    // 入力ラベル
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText('J', x + 5, y + 15);
                    ctx.fillText('>', x + 5, y + 35); // クロック
                    ctx.fillText('K', x + 5, y + 55);
                } else if (type === 'RS') {
                    // RS-FFの場合、RとSを分けて表示
                    ctx.fillText('RS-FF', x + w/2, y + 15);
                    // 入力ラベル
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText('R', x + 5, y + 15);
                    ctx.fillText('>', x + 5, y + 35); // クロック
                    ctx.fillText('S', x + 5, y + 55);
                } else if (type === 'T') {
                    // T-FFの場合（クロック入力なし）
                    ctx.fillText(type + '-FF', x + w/2, y + 15);
                    // 入力ラベル
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(type, x + 5, y + 35);
                } else {
                    // D-FFの場合
                    ctx.fillText(type + '-FF', x + w/2, y + 15);
                    // 入力ラベル
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(type, x + 5, y + 20);
                    ctx.fillText('>', x + 5, y + 50); // クロック
                }
                
                // 出力ラベル
                ctx.font = '10px Arial';
                ctx.textAlign = 'right';
                ctx.fillText('Q', x + w - 5, y + 20);
                ctx.fillText('Q̄', x + w - 5, y + 50);
                
                // 状態表示（Q出力の現在値）
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = component.qState ? '#4caf50' : '#f44336';
                ctx.fillText(component.qState ? '1' : '0', x + w/2, y + h - 15);
                
                ctx.restore();
            }
            
            drawPaletteIcons() {
                const canvases = document.querySelectorAll('.component-icon-canvas');
                canvases.forEach(canvas => {
                    const ctx = canvas.getContext('2d');
                    const gateType = canvas.dataset.gate;
                    const w = canvas.width;
                    const h = canvas.height;
                    
                    // 背景をクリア
                    ctx.clearRect(0, 0, w, h);
                    
                    // スタイル設定
                    ctx.fillStyle = '#ffffff';
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 1;
                    
                    // 小さなサイズで描画
                    switch (gateType) {
                        case 'AND':
                            this.drawANDGate(ctx, 2, 2, w - 4, h - 4);
                            break;
                        case 'OR':
                            this.drawORGate(ctx, 2, 2, w - 4, h - 4);
                            break;
                        case 'XOR':
                            this.drawXORGate(ctx, 2, 2, w - 4, h - 4);
                            break;
                        case 'NAND':
                            // AND gate with space for bubble
                            this.drawANDGate(ctx, 2, 2, w - 12, h - 4);
                            // Position bubble with proper clearance
                            this.drawNotBubble(ctx, w - 9, h/2, 2.5);
                            break;
                        case 'NOR':
                            // OR gate with space for bubble  
                            this.drawORGate(ctx, 2, 2, w - 12, h - 4);
                            // Position bubble with proper clearance
                            this.drawNotBubble(ctx, w - 9, h/2, 2.5);
                            break;
                        case 'NOT':
                            // NOT triangle with space for bubble
                            this.drawNOTTriangle(ctx, 2, 2, w - 12, h - 4);
                            // Position bubble with proper clearance
                            this.drawNotBubble(ctx, w - 9, h/2, 2.5);
                            break;
                        case 'DFF':
                            this.drawFlipFlopIcon(ctx, 2, 2, w - 4, h - 4, 'D');
                            break;
                        case 'JKFF':
                            this.drawFlipFlopIcon(ctx, 2, 2, w - 4, h - 4, 'JK');
                            break;
                        case 'TFF':
                            this.drawFlipFlopIcon(ctx, 2, 2, w - 4, h - 4, 'T');
                            break;
                        case 'RSFF':
                            this.drawFlipFlopIcon(ctx, 2, 2, w - 4, h - 4, 'RS');
                            break;
                    }
                });
            }
            
            drawConnections(ctx) {
                for (const connection of this.connections) {
                    const fromX = connection.from.component.x + connection.from.port.x;
                    const fromY = connection.from.component.y + connection.from.port.y;
                    const toX = connection.to.component.x + connection.to.port.x;
                    const toY = connection.to.component.y + connection.to.port.y;
                    
                    // 選択された接続線かどうかチェック
                    const isSelected = this.selectedConnection === connection;
                    
                    // 線の色を信号状態に応じて変更
                    if (isSelected) {
                        ctx.strokeStyle = '#ff5722'; // 選択時は赤色
                        ctx.lineWidth = 6;
                    } else {
                        ctx.strokeStyle = connection.from.component.state ? '#4caf50' : '#9e9e9e';
                        ctx.lineWidth = 4;
                    }
                    
                    ctx.beginPath();
                    ctx.moveTo(fromX, fromY);
                    
                    // 曲線で接続を描画
                    const midX = (fromX + toX) / 2;
                    ctx.bezierCurveTo(midX, fromY, midX, toY, toX, toY);
                    ctx.stroke();
                }
            }
            
            drawConnectionPreview(ctx) {
                if (!this.connectionStart) return;
                
                const startX = this.connectionStart.component.x + this.connectionStart.port.x;
                const startY = this.connectionStart.component.y + this.connectionStart.port.y;
                const endX = this.currentMousePos.x;
                const endY = this.currentMousePos.y;
                
                ctx.strokeStyle = '#ff5722';
                ctx.lineWidth = 4;
                ctx.setLineDash([8, 8]);
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                
                const midX = (startX + endX) / 2;
                ctx.bezierCurveTo(midX, startY, midX, endY, endX, endY);
                ctx.stroke();
                
                ctx.setLineDash([]);
            }
            
            handleTouchStart(event) {
                event.preventDefault();
                this.touches = Array.from(event.touches);
                
                if (this.touches.length === 1) {
                    // シングルタッチは通常のポインターイベントとして処理
                    this.handlePointerDown(event);
                } else if (this.touches.length === 2) {
                    // ピンチズーム開始
                    this.isPanning = false;
                    this.isDragging = false;
                    this.isConnecting = false;
                    this.selectedComponent = null;
                    this.selectedConnection = null;
                    this.cancelConnection();
                }
            }
            
            handleTouchMove(event) {
                event.preventDefault();
                this.touches = Array.from(event.touches);
                
                if (this.touches.length === 1) {
                    // シングルタッチは通常のポインターイベントとして処理
                    this.handlePointerMove(event);
                } else if (this.touches.length === 2) {
                    // ピンチズーム処理
                    this.handlePinchZoom(event);
                    
                    // ピンチ中は他の操作をキャンセル
                    this.isDragging = false;
                    this.isPanning = false;
                    this.isConnecting = false;
                    this.cancelConnection();
                }
            }
            
            handleTouchEnd(event) {
                event.preventDefault();
                this.touches = Array.from(event.touches);
                
                if (this.touches.length === 0) {
                    // すべてのタッチが終了
                    this.handlePointerUp(event);
                    this.lastPinchDistance = null;
                    this.lastPinchCenter = null;
                    this.isPaletteScrolling = false;
                } else if (this.touches.length === 1) {
                    // ピンチからシングルタッチに変更
                    this.lastPinchDistance = null;
                    this.lastPinchCenter = null;
                }
            }
            
            handlePinchZoom(event) {
                const touch1 = this.touches[0];
                const touch2 = this.touches[1];
                
                const rect = this.canvas.getBoundingClientRect();
                const x1 = touch1.clientX - rect.left;
                const y1 = touch1.clientY - rect.top;
                const x2 = touch2.clientX - rect.left;
                const y2 = touch2.clientY - rect.top;
                
                const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const centerX = (x1 + x2) / 2;
                const centerY = (y1 + y2) / 2;
                
                if (this.lastPinchDistance && this.lastPinchCenter) {
                    // ズーム処理
                    const scale = distance / this.lastPinchDistance;
                    const newScale = Math.max(0.1, Math.min(5, this.scale * scale));
                    
                    // ズーム中心をタッチポイントの中点に設定
                    this.panX = centerX - (centerX - this.panX) * (newScale / this.scale);
                    this.panY = centerY - (centerY - this.panY) * (newScale / this.scale);
                    
                    this.scale = newScale;
                    
                    // パン処理（ピンチ中心点の移動を追跡）
                    const centerDeltaX = centerX - this.lastPinchCenter.x;
                    const centerDeltaY = centerY - this.lastPinchCenter.y;
                    this.panX += centerDeltaX;
                    this.panY += centerDeltaY;
                    
                    this.render();
                }
                
                this.lastPinchDistance = distance;
                this.lastPinchCenter = { x: centerX, y: centerY };
            }
            
            // パレットスクロール処理
            handlePaletteScrollStart(event) {
                // 狭い画面（1024px以下）でパレットスクロールを有効化
                if (window.innerWidth > 1024) {
                    return;
                }
                
                const touch = event.touches[0];
                this.paletteScrollStartX = touch.clientX;
                this.paletteScrollStartY = touch.clientY;
                
                // パレットコンテンツの現在のスクロール位置を記録
                const paletteContent = document.querySelector('.palette-content');
                this.paletteScrollStartScrollLeft = paletteContent ? paletteContent.scrollLeft : 0;
                
                // 常にスクロール状態をリセット（部品アイテムタッチでも背景タッチでも）
                console.log('handlePaletteScrollStart: resetting isPaletteScrolling from', this.isPaletteScrolling, 'to false');
                this.isPaletteScrolling = false;
                
                // component-itemでのタッチ開始の場合は、部品ドラッグ処理を設定
                const componentItem = event.target.closest('.component-item');
                if (componentItem) {
                    console.log('🎯 Touch on component item:', componentItem.dataset.type);
                    this.isPaletteScrolling = false;
                    this.pendingComponentDrag = {
                        type: componentItem.dataset.type,
                        event: event
                    };
                    
                    console.log('pendingComponentDrag set to:', this.pendingComponentDrag);
                    // 部品アイコン上でも最初はpreventDefaultしない（スクロール可能にする）
                    return;
                } else {
                    console.log('📋 Touch on palette background, ready for scroll');
                }
                
                // 背景タッチの場合はpreventDefaultしない（ネイティブスクロールを有効化）
            }
            
            handlePaletteScrollMove(event) {
                // 狭い画面（1024px以下）でパレットスクロールを有効化
                if (window.innerWidth > 1024) {
                    return;
                }
                
                // 既にドラッグ中の場合はスキップ
                if (this.isDragging) {
                    console.log('handlePaletteScrollMove: skipping because already dragging');
                    return;
                }
                
                const touch = event.touches[0];
                const deltaX = Math.abs(touch.clientX - this.paletteScrollStartX);
                const deltaY = Math.abs(touch.clientY - this.paletteScrollStartY);
                
                // デバッグ用ログ
                console.log('Palette scroll move:', {
                    deltaX,
                    deltaY,
                    threshold: this.paletteScrollThreshold,
                    isScrolling: this.isPaletteScrolling,
                    targetClass: event.target.className,
                    closestItem: event.target.closest('.component-item') ? 'found' : 'none',
                    pendingComponentDrag: this.pendingComponentDrag ? 'exists' : 'null'
                });
                
                // 移動判定の改善：縦方向の移動が大きい場合は部品ドラッグを優先
                if (deltaX > this.paletteScrollThreshold || deltaY > this.paletteScrollThreshold) {
                    // 部品ドラッグ待機中の場合
                    if (this.pendingComponentDrag) {
                        console.log('Evaluating movement: deltaY:', deltaY, 'deltaX:', deltaX, 'deltaY > deltaX:', deltaY > deltaX);
                        // 部品ドラッグ判定を緩く（斜め移動も含む）
                        if ((deltaY > 12 || deltaX > 12) && deltaY > 8) {
                            console.log('🔽 Starting component drag (vertical movement), deltaY:', deltaY, 'deltaX:', deltaX);
                            this.startActualComponentDrag(this.pendingComponentDrag.type, event);
                            this.pendingComponentDrag = null;
                            return; // スクロール処理は実行しない
                        }
                        // 横方向の移動が大きい場合は常にスクロール優先
                        else if (deltaX > 8) { // スクロール検出範囲を緩く
                            this.isPaletteScrolling = true;
                            console.log('◀️▶️ Palette scroll activated (horizontal movement)! deltaX:', deltaX);
                            this.pendingComponentDrag = null;
                            // スクロールを明示的に許可（preventDefaultしない）
                        }
                        // 横方向の移動が大きく、移動距離が長い場合はドラッグ
                        else {
                            console.log('🔽 Starting component drag (long horizontal movement), deltaX:', deltaX);
                            this.startActualComponentDrag(this.pendingComponentDrag.type, event);
                            this.pendingComponentDrag = null;
                            return; // スクロール処理は実行しない
                        }
                    } else {
                        console.log('No pending component drag, deltaX:', deltaX, 'deltaY:', deltaY);
                        // 部品ドラッグ待機中でない場合で、横方向の移動が大きい場合はスクロール
                        if (deltaX > deltaY) {
                            this.isPaletteScrolling = true;
                            console.log('Palette scroll activated!');
                        }
                    }
                }
                
                // スクロール中は実際にパレットをスクロールさせる
                if (this.isPaletteScrolling) {
                    const paletteContent = document.querySelector('.palette-content');
                    if (paletteContent) {
                        const deltaX = touch.clientX - this.paletteScrollStartX;
                        const newScrollLeft = this.paletteScrollStartScrollLeft - deltaX;
                        paletteContent.scrollLeft = Math.max(0, Math.min(newScrollLeft, paletteContent.scrollWidth - paletteContent.clientWidth));
                    }
                    event.preventDefault();
                    return;
                }
            }
            
            handlePaletteScrollEnd(event) {
                // 狭い画面（1024px以下）でパレットスクロールを有効化
                if (window.innerWidth > 1024) {
                    return;
                }
                
                // 待機中の部品ドラッグをクリア
                console.log('handlePaletteScrollEnd: clearing pendingComponentDrag from', this.pendingComponentDrag ? 'exists' : 'null');
                this.isPaletteScrolling = false;
                this.pendingComponentDrag = null;
                
                // preventDefaultしない（ネイティブスクロールを有効化）
            }
            
            // 狭い画面での部品タッチ処理（スクロール優先）
            handleComponentTouch(event) {
                // passive: trueなのでpreventDefaultは使えない
                // パレットスクロールハンドラーで判定処理を行う
                console.log('Component touch detected (passive mode)');
            }

            // 部品ドラッグを実行する関数（元のstartComponentDragの処理を抽出）
            executeComponentDrag(type, event) {
                // パレットスクロール状態をリセット
                this.isPaletteScrolling = false;
                
                // パレットアイテムの場合は、適切なキャンバス座標に部品を作成
                let x, y;
                const canvasRect = this.canvas.getBoundingClientRect();
                
                if (event.type === 'touchstart' && event.touches && event.touches.length > 0) {
                    // タッチの場合
                    const touch = event.touches[0];
                    console.log('Touch position:', touch.clientX, touch.clientY);
                    console.log('Canvas rect:', canvasRect);
                    
                    // タッチ位置がキャンバス内かチェック（横レイアウト時はパレット領域を除外）
                    let isWithinCanvas = false;
                    const isLandscape = this.isMobileLandscape();
                    
                    if (isLandscape) {
                        // 横レイアウト時：パレット領域（下部140px）を除外
                        isWithinCanvas = touch.clientX >= canvasRect.left && touch.clientX <= canvasRect.right &&
                                       touch.clientY >= canvasRect.top && touch.clientY <= (canvasRect.bottom - 140);
                    } else {
                        // 縦レイアウト時：通常の判定
                        isWithinCanvas = touch.clientX >= canvasRect.left && touch.clientX <= canvasRect.right &&
                                       touch.clientY >= canvasRect.top && touch.clientY <= canvasRect.bottom;
                    }
                    
                    if (isWithinCanvas) {
                        // キャンバス内の場合、その座標を使用
                        x = (touch.clientX - canvasRect.left - this.panX) / this.scale;
                        y = (touch.clientY - canvasRect.top - this.panY) / this.scale;
                        console.log('Touch within canvas, using touch position:', x, y);
                    } else {
                        // キャンバス外（パレット）の場合、キャンバス中央に配置
                        if (isLandscape) {
                            // 横レイアウト時：パレット領域を除いたキャンバス中央
                            x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                            y = ((this.canvas.clientHeight - 140) / 2 - this.panY) / this.scale;
                        } else {
                            // 縦レイアウト時：通常のキャンバス中央
                            x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                            y = (this.canvas.clientHeight / 2 - this.panY) / this.scale;
                        }
                        console.log('Touch outside canvas (palette), using center:', x, y);
                    }
                } else {
                    // マウスの場合も同様の処理
                    x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                    y = (this.canvas.clientHeight / 2 - this.panY) / this.scale;
                    console.log('Mouse event, using center:', x, y);
                }
                
                const component = this.createComponent(type, x, y);
                component.isNewFromPalette = true; // パレットから作成されたことを記録
                
                // 重要：まだマップには追加せず、一時的に保持
                this.pendingComponent = component;
                this.selectedComponent = component;
                this.isDragging = true;
                this.dragOffset = { x: 0, y: 0 };
                this.dragStarted = false; // 実際のドラッグが開始されたかのフラグ
                
                // タッチイベントの場合、グローバルなイベントリスナーを追加
                if (event.type === 'touchstart') {
                    this.setupGlobalTouchHandlers();
                }
                
                // 実際のドラッグ開始フラグを設定
                this.dragStarted = true;
                
                this.render();
            }
            
            // 実際のドラッグを開始する関数（現在のタッチイベントを使用）
            startActualComponentDrag(type, currentEvent) {
                console.log('startActualComponentDrag called with type:', type);
                
                // パレットスクロール状態をリセット
                this.isPaletteScrolling = false;
                
                // 現在のタッチ位置を取得
                const touch = currentEvent.touches[0];
                const canvasRect = this.canvas.getBoundingClientRect();
                
                // 横レイアウトの場合、パレット領域を除いた中央に配置
                const isLandscape = this.isMobileLandscape();
                let x, y;
                
                if (isLandscape) {
                    // 横レイアウト時：パレット領域を除いたキャンバス中央
                    x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                    y = ((this.canvas.clientHeight - 140) / 2 - this.panY) / this.scale;
                } else {
                    // 縦レイアウト時：通常のキャンバス中央
                    x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                    y = (this.canvas.clientHeight / 2 - this.panY) / this.scale;
                }
                
                console.log('Creating component at position:', x, y);
                
                const component = this.createComponent(type, x, y);
                component.isNewFromPalette = true;
                
                // 重要：まだマップには追加せず、一時的に保持
                this.pendingComponent = component;
                this.selectedComponent = component;
                this.isDragging = true;
                this.dragOffset = { x: 0, y: 0 };
                this.dragStarted = true;
                
                // 実際にマップに追加
                this.components.set(component.id, component);
                console.log('Component added to map with ID:', component.id, 'Total components:', this.components.size);
                
                // 現在のタッチ位置を記録
                this.currentMousePos = {
                    x: (touch.clientX - canvasRect.left - this.panX) / this.scale,
                    y: (touch.clientY - canvasRect.top - this.panY) / this.scale
                };
                
                console.log('Component drag started, isDragging:', this.isDragging, 'selectedComponent:', this.selectedComponent);
                
                // タッチイベントの場合、グローバルなイベントリスナーを追加
                if (currentEvent.type === 'touchstart' || currentEvent.type === 'touchmove') {
                    console.log('Setting up global touch handlers');
                    this.setupGlobalTouchHandlers();
                }
                
                this.render();
                
                // デバッグ用：配置後の状態を確認
                console.log('After render - components.size:', this.components.size);
                console.log('After render - pendingComponent:', this.pendingComponent);
                console.log('After render - canvas dimensions:', this.canvas.width, 'x', this.canvas.height);
                console.log('After render - scale:', this.scale, 'panX:', this.panX, 'panY:', this.panY);
            }
        }

        // アプリケーション開始 - 初回アクセス時の表示問題を解決するため、レイアウト確定を待つ
        function initializeSimulator() {
            // 強制的にapp-containerのスタイルを設定
            const appContainer = document.querySelector('.app-container');
            if (appContainer && window.innerWidth <= 768) {
                appContainer.style.margin = '0';
                appContainer.style.padding = '0';
                appContainer.style.height = '100vh';
                appContainer.style.width = '100vw';
                appContainer.style.maxHeight = '100vh';
                appContainer.style.minHeight = '100vh';
                appContainer.style.display = 'flex';
                appContainer.style.flexDirection = 'column';
                appContainer.style.overflow = 'hidden';
                appContainer.style.boxSizing = 'border-box';
                console.log('Forced app-container styles applied');
            }
            
            // キャンバスコンテナのサイズが確定するまで待つ
            const canvasContainer = document.querySelector('.canvas-container');
            if (!canvasContainer) {
                console.log('Canvas container not found, retrying...');
                setTimeout(initializeSimulator, 50);
                return;
            }
            
            // コンテナのサイズが0でない場合のみ初期化
            const containerRect = canvasContainer.getBoundingClientRect();
            if (containerRect.width === 0 || containerRect.height === 0) {
                console.log('Canvas container size not ready:', containerRect, 'retrying...');
                setTimeout(initializeSimulator, 50);
                return;
            }
            
            console.log('Canvas container ready:', containerRect);
            new MobileCircuitSimulator();
        }

        window.addEventListener('DOMContentLoaded', () => {
            // iOS Safari で Safe Area やレイアウト計算の完了を待つ
            if (navigator.userAgent.includes('Safari') && navigator.userAgent.includes('Mobile')) {
                // iOS Safari の場合はさらに待つ
                setTimeout(initializeSimulator, 200);
            } else {
                // 他のブラウザでも少し待つ
                setTimeout(initializeSimulator, 100);
            }
        });
    </script>
</Layout>