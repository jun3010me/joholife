---
// mobile-circuit-simulator.astro
import Layout from '../layouts/Layout.astro';
---

<Layout title="ã‚¹ãƒãƒ›å¯¾å¿œè«–ç†å›è·¯ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            overflow: hidden;
            height: 100vh;
        }

        .app-container {
            display: flex;
            height: 100vh;
            width: 100vw;
            position: relative;
        }

        /* éƒ¨å“ãƒ‘ãƒ¬ãƒƒãƒˆ */
        .component-palette {
            width: 280px;
            background: white;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
            z-index: 1000;
        }

        .palette-header {
            padding: 12px;
            border-bottom: 1px solid #eee;
            background: #fafafa;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .palette-title {
            font-weight: bold;
            font-size: 14px;
        }

        .palette-toggle {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            padding: 4px;
            touch-action: manipulation; /* ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã‚ºãƒ¼ãƒ ã‚’ç„¡åŠ¹åŒ– */
        }

        .palette-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .component-category {
            margin-bottom: 16px;
        }

        .category-title {
            font-size: 12px;
            font-weight: bold;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .component-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .component-item {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .component-item:hover {
            border-color: #2196f3;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2);
        }

        .component-icon {
            font-size: 20px;
            margin-bottom: 4px;
        }

        .component-icon-canvas {
            margin-bottom: 4px;
            background: transparent;
        }

        .component-name {
            font-size: 10px;
            color: #666;
            font-weight: 500;
        }

        /* ãƒ¡ã‚¤ãƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ */
        .main-canvas {
            flex: 1;
            position: relative;
            background: white;
            overflow: hidden;
        }

        .canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
            touch-action: none;
        }

        #circuit-canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 10px 10px, #ddd 1px, transparent 1px),
                radial-gradient(circle at 30px 30px, #ddd 1px, transparent 1px);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
        }

        /* ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ */
        .toolbar {
            position: fixed;
            top: 12px;
            right: 12px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            z-index: 1000;
        }

        .toolbar-button {
            background: none;
            border: none;
            padding: 12px;
            font-size: 18px;
            cursor: pointer;
            transition: background-color 0.2s;
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation; /* ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã‚ºãƒ¼ãƒ ã‚’ç„¡åŠ¹åŒ– */
        }

        .toolbar-button:hover {
            background: #f5f5f5;
        }

        .toolbar-button:first-child {
            border-radius: 8px 8px 0 0;
        }

        .toolbar-button:last-child {
            border-radius: 0 0 8px 8px;
        }

        .toolbar-button + .toolbar-button {
            border-top: 1px solid #eee;
        }

        /* ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ */
        .file-menu {
            position: fixed;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border-radius: 24px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            display: flex;
            padding: 4px;
            z-index: 1000;
            white-space: nowrap; /* æ”¹è¡Œã‚’é˜²ã */
        }

        .file-button {
            background: none;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            font-weight: 500;
            min-height: 36px;
            display: flex;
            align-items: center;
            gap: 4px;
            flex-shrink: 0; /* ãƒœã‚¿ãƒ³ã®ç¸®å°ã‚’é˜²ã */
        }

        .file-button:hover {
            background: #f5f5f5;
        }

        /* ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œ */
        @media (max-width: 768px) {
            .component-palette {
                position: fixed;
                left: 0;
                top: 0;
                height: 100vh;
                transform: translateX(-100%);
                width: 280px;
                box-shadow: 2px 0 8px rgba(0,0,0,0.1);
            }

            .component-palette.open {
                transform: translateX(0);
            }
        }

        /* ã‚¹ãƒãƒ›æ¨ªç”»é¢å¯¾å¿œ */
        @media (max-width: 768px) and (max-height: 500px) and (orientation: landscape) {
            .component-palette {
                position: fixed;
                left: 0;
                right: 0;
                bottom: 0;
                top: auto;
                height: 140px;
                width: 100%;
                transform: translateY(100%);
                flex-direction: row;
                overflow-x: auto;
                overflow-y: hidden;
                box-shadow: 0 -2px 8px rgba(0,0,0,0.1);
            }

            .component-palette.open {
                transform: translateY(0);
            }

            .palette-content {
                display: flex;
                flex-direction: row;
                overflow-x: auto;
                overflow-y: hidden;
                padding: 10px;
            }

            .component-category {
                display: flex;
                flex-direction: row;
                margin-right: 0;
                margin-bottom: 0;
            }

            .component-grid {
                display: flex;
                flex-wrap: nowrap;
                gap: 10px;
                margin-right: 20px;
            }

            .component-item {
                min-width: 60px;
                flex-shrink: 0;
            }

            /* ãƒãƒ³ãƒãƒ¼ã‚¬ãƒ¼ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’ä¸‹éƒ¨ã«ç§»å‹• */
            .mobile-toggle {
                bottom: 160px;
                top: auto;
                left: 12px;
            }

            /* ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚’ä¸­å¤®å³ã«é…ç½® */
            .toolbar {
                top: 50%;
                transform: translateY(-50%);
                right: 12px;
            }

            /* ãƒ¡ã‚¤ãƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ã®é«˜ã•èª¿æ•´ */
            .main-canvas {
                height: calc(100vh - 140px);
            }

            /* ãƒ‘ãƒ¬ãƒƒãƒˆãƒ˜ãƒƒãƒ€ãƒ¼ã‚’æ¨ªå‘ãç”¨ã«èª¿æ•´ */
            .palette-header {
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                padding: 10px 15px;
                min-height: 40px;
                border-bottom: 1px solid #eee;
            }

            .palette-title {
                font-size: 16px;
                font-weight: bold;
            }
        }

        .palette-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.3);
            z-index: 999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .palette-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .main-canvas {
            width: 100vw;
        }

        .mobile-toggle {
            position: fixed;
            top: 12px;
            left: 12px;
            background: white;
            border: none;
            border-radius: 8px;
            padding: 12px;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 1001;
            min-width: 44px;
            min-height: 44px;
            touch-action: manipulation; /* ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã‚ºãƒ¼ãƒ ã‚’ç„¡åŠ¹åŒ– */
        }

        /* ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®éƒ¨å“ã‚¹ã‚¿ã‚¤ãƒ« */
        .dragging-component {
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            opacity: 0.8;
            transform: scale(1.1);
        }

        /* éš ã—ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ› */
        .hidden-file-input {
            display: none;
        }
    </style>

    <!-- ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ -->
    <div class="app-container">
        <!-- ãƒ¢ãƒã‚¤ãƒ«ç”¨ãƒ‘ãƒ¬ãƒƒãƒˆåˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ -->
        <button class="mobile-toggle" id="mobile-toggle">â˜°</button>
        
        <!-- ãƒ‘ãƒ¬ãƒƒãƒˆã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆãƒ¢ãƒã‚¤ãƒ«ç”¨ï¼‰ -->
        <div class="palette-overlay" id="palette-overlay"></div>
        
        <!-- éƒ¨å“ãƒ‘ãƒ¬ãƒƒãƒˆ -->
        <div class="component-palette" id="component-palette">
            <div class="palette-header">
                <span class="palette-title">éƒ¨å“ãƒ‘ãƒ¬ãƒƒãƒˆ</span>
                <button class="palette-toggle" id="palette-toggle">âœ•</button>
            </div>
            <div class="palette-content">
                <!-- åŸºæœ¬ã‚²ãƒ¼ãƒˆ -->
                <div class="component-category">
                    <div class="category-title">åŸºæœ¬ã‚²ãƒ¼ãƒˆ</div>
                    <div class="component-grid">
                        <div class="component-item" data-type="AND">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="AND"></canvas>
                            <div class="component-name">AND</div>
                        </div>
                        <div class="component-item" data-type="OR">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="OR"></canvas>
                            <div class="component-name">OR</div>
                        </div>
                        <div class="component-item" data-type="NOT">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="NOT"></canvas>
                            <div class="component-name">NOT</div>
                        </div>
                        <div class="component-item" data-type="XOR">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="XOR"></canvas>
                            <div class="component-name">XOR</div>
                        </div>
                        <div class="component-item" data-type="NAND">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="NAND"></canvas>
                            <div class="component-name">NAND</div>
                        </div>
                        <div class="component-item" data-type="NOR">
                            <canvas class="component-icon-canvas" width="40" height="30" data-gate="NOR"></canvas>
                            <div class="component-name">NOR</div>
                        </div>
                    </div>
                </div>

                <!-- å…¥å‡ºåŠ› -->
                <div class="component-category">
                    <div class="category-title">å…¥å‡ºåŠ›</div>
                    <div class="component-grid">
                        <div class="component-item" data-type="INPUT">
                            <div class="component-icon">â—¯</div>
                            <div class="component-name">å…¥åŠ›</div>
                        </div>
                        <div class="component-item" data-type="OUTPUT">
                            <div class="component-icon">â—</div>
                            <div class="component-name">å‡ºåŠ›</div>
                        </div>
                        <div class="component-item" data-type="LED">
                            <div class="component-icon">ğŸ’¡</div>
                            <div class="component-name">LED</div>
                        </div>
                        <div class="component-item" data-type="SWITCH">
                            <div class="component-icon">ğŸ”˜</div>
                            <div class="component-name">ã‚¹ã‚¤ãƒƒãƒ</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ãƒ¡ã‚¤ãƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ -->
        <div class="main-canvas">
            <div class="canvas-container">
                <canvas id="circuit-canvas"></canvas>
            </div>
        </div>

        <!-- ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ -->
        <div class="toolbar">
            <button class="toolbar-button" id="delete-btn" title="å‰Šé™¤ï¼ˆæ¥ç¶šç·šã¯ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ã‚‚å‰Šé™¤å¯èƒ½ï¼‰">ğŸ—‘ï¸</button>
            <button class="toolbar-button" id="clear-btn" title="ã™ã¹ã¦ã‚¯ãƒªã‚¢">ğŸ§¹</button>
            <button class="toolbar-button" id="undo-btn" title="å…ƒã«æˆ»ã™">â†¶</button>
            <button class="toolbar-button" id="redo-btn" title="ã‚„ã‚Šç›´ã—">â†·</button>
        </div>

        <!-- ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ -->
        <div class="file-menu">
            <button class="file-button" id="save-btn">ğŸ’¾ ä¿å­˜</button>
            <button class="file-button" id="load-btn">ğŸ“ èª­è¾¼</button>
            <button class="file-button" id="export-btn">ğŸ“· ç”»åƒ</button>
        </div>

        <!-- éš ã—ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ› -->
        <input type="file" class="hidden-file-input" id="file-input" accept=".json">
    </div>

    <script type="module">
        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–
        class MobileCircuitSimulator {
            constructor() {
                this.canvas = document.getElementById('circuit-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.components = new Map();
                this.connections = [];
                this.selectedComponent = null;
                this.isDragging = false;
                this.dragOffset = { x: 0, y: 0 };
                this.scale = 1;
                this.panX = 0;
                this.panY = 0;
                this.history = [];
                this.historyIndex = -1;
                this.isConnecting = false;
                this.connectionStart = null;
                this.currentMousePos = { x: 0, y: 0 };
                this.isSimulating = true;
                this.simulationInterval = null;
                this.isPanning = false;
                this.lastPanPoint = null;
                this.touches = [];
                this.lastPinchDistance = null;
                this.lastPinchCenter = null;
                this.touchStartTime = 0;
                this.touchStartPos = null;
                this.dragThreshold = 10; // ãƒ”ã‚¯ã‚»ãƒ«å˜ä½ã§ã®ãƒ‰ãƒ©ãƒƒã‚°åˆ¤å®šã—ãã„å€¤
                this.selectedConnection = null;
                this.lastClickTime = 0;
                this.doubleClickDelay = 300; // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯åˆ¤å®šæ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰
                this.lastClickPosition = null; // æœ€å¾Œã®ã‚¯ãƒªãƒƒã‚¯ä½ç½®
                this.overlappingComponents = []; // é‡ãªã£ãŸã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ãƒªã‚¹ãƒˆ
                
                // ãƒ‘ãƒ¬ãƒƒãƒˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯¾å¿œ
                this.isPaletteScrolling = false;
                this.paletteScrollStartX = 0;
                this.paletteScrollStartY = 0;
                this.paletteScrollThreshold = 5;
                this.paletteScrollStartScrollLeft = 0;
                this.pendingComponentDrag = null; // éƒ¨å“ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹å¾…æ©Ÿç”¨
                this.currentOverlapIndex = 0; // ç¾åœ¨é¸æŠä¸­ã®é‡ãªã‚Šã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
                this.nextZIndex = 1; // Z-indexç®¡ç†ç”¨ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
                this.pendingComponent = null; // ãƒ‘ãƒ¬ãƒƒãƒˆã‹ã‚‰ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®éƒ¨å“ï¼ˆã¾ã ãƒãƒƒãƒ—ã«è¿½åŠ ã•ã‚Œã¦ã„ãªã„ï¼‰
                this.dragStarted = false; // å®Ÿéš›ã®ãƒ‰ãƒ©ãƒƒã‚°ç§»å‹•ãŒé–‹å§‹ã•ã‚ŒãŸã‹ã®ãƒ•ãƒ©ã‚°
                
                this.init();
            }

            init() {
                this.setupCanvas();
                this.setupEventListeners();
                this.setupPalette();
                this.setupFileHandling();
                this.drawPaletteIcons();
                this.startSimulation();
                this.render();
            }
            
            startSimulation() {
                this.simulationInterval = setInterval(() => {
                    if (this.isSimulating) {
                        this.updateSimulation();
                    }
                }, 100); // 10Hzã§ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
            }

            setupCanvas() {
                this.resizeCanvas = () => {
                    const container = this.canvas.parentElement;
                    const dpr = window.devicePixelRatio || 1;
                    
                    this.canvas.width = container.clientWidth * dpr;
                    this.canvas.height = container.clientHeight * dpr;
                    this.canvas.style.width = container.clientWidth + 'px';
                    this.canvas.style.height = container.clientHeight + 'px';
                    
                    this.ctx.scale(dpr, dpr);
                    this.render();
                };

                window.addEventListener('resize', this.resizeCanvas);
                this.resizeCanvas();
            }

            setupEventListeners() {
                // ã‚¿ãƒƒãƒãƒ»ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
                this.canvas.addEventListener('mousedown', this.handlePointerDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handlePointerMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handlePointerUp.bind(this));
                
                this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });

                // ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ 
                this.canvas.addEventListener('wheel', this.handleWheel.bind(this), { passive: false });

                // ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ãƒœã‚¿ãƒ³
                document.getElementById('delete-btn').addEventListener('click', this.deleteSelected.bind(this));
                document.getElementById('clear-btn').addEventListener('click', this.clearAll.bind(this));
                document.getElementById('undo-btn').addEventListener('click', this.undo.bind(this));
                document.getElementById('redo-btn').addEventListener('click', this.redo.bind(this));

                // ãƒ¢ãƒã‚¤ãƒ«UI
                document.getElementById('mobile-toggle').addEventListener('click', this.togglePalette.bind(this));
                document.getElementById('palette-toggle').addEventListener('click', this.togglePalette.bind(this));
                document.getElementById('palette-overlay').addEventListener('click', this.togglePalette.bind(this));
            }

            setupPalette() {
                const palette = document.getElementById('component-palette');
                const items = palette.querySelectorAll('.component-item');

                items.forEach(item => {
                    item.addEventListener('mousedown', this.startComponentDrag.bind(this));
                    item.addEventListener('touchstart', this.startComponentDrag.bind(this), { passive: false });
                });
                
                // ãƒ‘ãƒ¬ãƒƒãƒˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯¾å¿œ
                const paletteContent = document.querySelector('.palette-content');
                if (paletteContent) {
                    paletteContent.addEventListener('touchstart', this.handlePaletteScrollStart.bind(this), { passive: false });
                    paletteContent.addEventListener('touchmove', this.handlePaletteScrollMove.bind(this), { passive: false });
                    paletteContent.addEventListener('touchend', this.handlePaletteScrollEnd.bind(this), { passive: false });
                }
            }

            setupFileHandling() {
                document.getElementById('save-btn').addEventListener('click', this.saveCircuit.bind(this));
                document.getElementById('load-btn').addEventListener('click', this.loadCircuit.bind(this));
                document.getElementById('export-btn').addEventListener('click', this.exportImage.bind(this));
                document.getElementById('file-input').addEventListener('change', this.handleFileLoad.bind(this));
            }

            getPointerPos(event) {
                const rect = this.canvas.getBoundingClientRect();
                let clientX, clientY;
                
                // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã‹ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆã‹ã‚’åˆ¤å®š
                if (event.touches && event.touches.length > 0) {
                    // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆ
                    clientX = event.touches[0].clientX;
                    clientY = event.touches[0].clientY;
                } else if (event.changedTouches && event.changedTouches.length > 0) {
                    // ã‚¿ãƒƒãƒã‚¨ãƒ³ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆ
                    clientX = event.changedTouches[0].clientX;
                    clientY = event.changedTouches[0].clientY;
                } else {
                    // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆ
                    clientX = event.clientX;
                    clientY = event.clientY;
                }
                
                return {
                    x: (clientX - rect.left - this.panX) / this.scale,
                    y: (clientY - rect.top - this.panY) / this.scale
                };
            }

            handlePointerDown(event) {
                event.preventDefault();
                console.log('PointerDown triggered, event type:', event.type);
                
                // ãƒãƒ«ãƒã‚¿ãƒƒãƒã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                if (event.touches && event.touches.length > 1) return;
                
                const pos = this.getPointerPos(event);
                this.touchStartTime = Date.now();
                this.touchStartPos = { x: pos.x, y: pos.y };
                
                // ãƒãƒ¼ãƒˆæ¥ç¶šãƒã‚§ãƒƒã‚¯
                const port = this.getPortAt(pos.x, pos.y);
                console.log('Checking for port at', pos.x, pos.y, 'found:', port ? port.type : 'none');
                if (port) {
                    console.log('Starting connection from port:', port.type);
                    // æ¥ç¶šé–‹å§‹æ™‚ã«ãƒã‚¦ã‚¹åº§æ¨™ã‚’æ›´æ–°ï¼ˆç‚¹ç·šãŒæ­£ã—ã„ä½ç½®ã‹ã‚‰å§‹ã¾ã‚‹ã‚ˆã†ã«ï¼‰
                    this.currentMousePos = pos;
                    this.startConnection(port);
                    return;
                }
                
                // éƒ¨å“é¸æŠï¼ˆå¾ªç’°é¸æŠæœ‰åŠ¹ï¼‰- æ¥ç¶šç·šã‚ˆã‚Šå„ªå…ˆ
                const component = this.getComponentAt(pos.x, pos.y, true);
                console.log('Looking for component at', pos.x, pos.y, 'found:', component ? component.type : 'none');
                if (component) {
                    // éƒ¨å“é¸æŠãƒ»ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
                    console.log('Component selected for dragging:', component.type);
                    this.selectedComponent = component;
                    this.selectedConnection = null; // éƒ¨å“é¸æŠæ™‚ã¯æ¥ç¶šç·šé¸æŠã‚’ãƒªã‚»ãƒƒãƒˆ
                    
                    // é¸æŠã•ã‚ŒãŸã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å‰é¢ã«ç§»å‹•
                    component.zIndex = this.nextZIndex++;
                    
                    this.isDragging = true;
                    this.dragOffset = {
                        x: pos.x - component.x,
                        y: pos.y - component.y
                    };
                    this.isPanning = false; // éƒ¨å“é¸æŠæ™‚ã¯ãƒ‘ãƒ³ã‚’ç„¡åŠ¹åŒ–
                    return;
                }
                
                // æ¥ç¶šç·šãƒã‚§ãƒƒã‚¯ï¼ˆéƒ¨å“ãŒãªã„å ´åˆã®ã¿ï¼‰
                const connection = this.getConnectionAt(pos.x, pos.y);
                if (connection) {
                    const currentTime = Date.now();
                    
                    // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯åˆ¤å®š
                    if (this.selectedConnection === connection && 
                        currentTime - this.lastClickTime < this.doubleClickDelay) {
                        // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ï¼šæ¥ç¶šç·šã‚’å‰Šé™¤
                        this.removeConnection(connection.id);
                        this.selectedConnection = null;
                        this.render();
                        this.saveState();
                        this.updateSimulation();
                        // console.log('Connection deleted via double-click');
                        return;
                    }
                    
                    // ã‚·ãƒ³ã‚°ãƒ«ã‚¯ãƒªãƒƒã‚¯ï¼šæ¥ç¶šç·šã‚’é¸æŠ
                    this.selectedConnection = connection;
                    this.selectedComponent = null; // æ¥ç¶šç·šé¸æŠæ™‚ã¯éƒ¨å“é¸æŠã‚’ãƒªã‚»ãƒƒãƒˆ
                    this.lastClickTime = currentTime;
                    this.render();
                    return;
                }
                
                // ä½•ã‚‚é¸æŠã•ã‚Œãªã‹ã£ãŸå ´åˆã¯ãƒ‘ãƒ³é–‹å§‹
                console.log('No component or connection found, starting pan mode');
                this.selectedComponent = null;
                this.selectedConnection = null;
                this.isDragging = false;
                this.isPanning = true;
                
                // ãƒ‘ãƒ³é–‹å§‹æ™‚ã¯ç”Ÿã®åº§æ¨™ã‚’ä½¿ç”¨
                const rect = this.canvas.getBoundingClientRect();
                const rawX = event.clientX || (event.touches && event.touches[0].clientX);
                const rawY = event.clientY || (event.touches && event.touches[0].clientY);
                this.lastPanPoint = {
                    x: rawX - rect.left,
                    y: rawY - rect.top
                };
                
                this.render();
            }

            handlePointerMove(event) {
                event.preventDefault();
                
                // ãƒãƒ«ãƒã‚¿ãƒƒãƒã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                if (event.touches && event.touches.length > 1) return;
                
                const pos = this.getPointerPos(event);
                this.currentMousePos = pos;
                
                if (this.isConnecting) {
                    this.render();
                } else if (this.isDragging && this.selectedComponent) {
                    // ãƒ‘ãƒ¬ãƒƒãƒˆã‹ã‚‰ä½œæˆã•ã‚ŒãŸéƒ¨å“ã§ã€ã¾ã ãƒãƒƒãƒ—ã«è¿½åŠ ã•ã‚Œã¦ã„ãªã„å ´åˆ
                    if (this.pendingComponent && !this.dragStarted) {
                        console.log('First drag movement detected, adding component to map:', this.pendingComponent.type);
                        this.components.set(this.pendingComponent.id, this.pendingComponent);
                        this.dragStarted = true;
                        this.saveState();
                    }
                    
                    this.selectedComponent.x = pos.x - this.dragOffset.x;
                    this.selectedComponent.y = pos.y - this.dragOffset.y;
                    this.render();
                } else if (this.isPanning && this.lastPanPoint) {
                    // ãƒ‘ãƒ³å‡¦ç†ã¯ç”Ÿã®åº§æ¨™ã‚’ä½¿ç”¨
                    const rect = this.canvas.getBoundingClientRect();
                    const rawX = event.clientX || (event.touches && event.touches[0].clientX);
                    const rawY = event.clientY || (event.touches && event.touches[0].clientY);
                    const currentRawPos = {
                        x: rawX - rect.left,
                        y: rawY - rect.top
                    };
                    
                    const deltaX = currentRawPos.x - this.lastPanPoint.x;
                    const deltaY = currentRawPos.y - this.lastPanPoint.y;
                    this.panX += deltaX;
                    this.panY += deltaY;
                    
                    // æ¬¡å›ã®ãŸã‚ã«ç”Ÿã®åº§æ¨™ã‚’ä¿å­˜
                    this.lastPanPoint = currentRawPos;
                    this.render();
                }
            }

            handlePointerUp(event) {
                event.preventDefault();
                
                // ãƒ‘ãƒ¬ãƒƒãƒˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.isPaletteScrolling = false;
                
                if (this.isConnecting && this.connectionStart) {
                    const pos = this.getPointerPos(event);
                    let port = this.getPortAt(pos.x, pos.y);
                    
                    // ç«¯å­ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã€ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå†…ã§ã®ã‚¹ãƒãƒ¼ãƒˆæ¥ç¶šã‚’è©¦è¡Œ
                    if (!port) {
                        const component = this.getComponentAt(pos.x, pos.y);
                        if (component) {
                            console.log('handlePointerUp - No direct port hit, trying smart connection to:', component.type);
                            
                            // æ¥ç¶šé–‹å§‹ãŒå‡ºåŠ›ç«¯å­ã®å ´åˆã€å…¥åŠ›ç«¯å­ã‚’æ¢ã™
                            if (this.connectionStart.type === 'output') {
                                port = this.findBestInputPort(component, pos.x, pos.y);
                            }
                            // æ¥ç¶šé–‹å§‹ãŒå…¥åŠ›ç«¯å­ã®å ´åˆã€å‡ºåŠ›ç«¯å­ã‚’æ¢ã™  
                            else if (this.connectionStart.type === 'input') {
                                port = this.findBestOutputPort(component, pos.x, pos.y);
                            }
                        }
                    }
                    
                    console.log('handlePointerUp - Connection mode, found port:', port ? port.type : 'none');
                    if (port && port !== this.connectionStart) {
                        this.completeConnection(this.connectionStart, port);
                    } else {
                        console.log('handlePointerUp - No valid end port found');
                    }
                    this.cancelConnection();
                } else if (this.isDragging && this.selectedComponent) {
                    const pos = this.getPointerPos(event);
                    const touchDuration = Date.now() - this.touchStartTime;
                    const touchDistance = this.touchStartPos ? 
                        Math.sqrt(Math.pow(pos.x - this.touchStartPos.x, 2) + Math.pow(pos.y - this.touchStartPos.y, 2)) : 0;
                    
                    // ãƒ‘ãƒ¬ãƒƒãƒˆã‹ã‚‰ä½œæˆã•ã‚ŒãŸéƒ¨å“ã§ã€å®Ÿéš›ã®ãƒ‰ãƒ©ãƒƒã‚°ãŒé–‹å§‹ã•ã‚Œã¦ã„ãªã„å ´åˆ
                    if (this.pendingComponent && !this.dragStarted) {
                        console.log('Canceling pending component - no drag detected:', this.pendingComponent.type);
                        this.pendingComponent = null;
                        this.selectedComponent = null;
                        this.isDragging = false;
                        return;
                    }
                    
                    // çŸ­ã„ã‚¿ãƒƒãƒ—ã‹ã¤ç§»å‹•è·é›¢ãŒå°ã•ã„å ´åˆã¯çŠ¶æ…‹åˆ‡ã‚Šæ›¿ãˆ
                    if ((this.selectedComponent.type === 'INPUT' || this.selectedComponent.type === 'SWITCH') &&
                        touchDuration < 500 && // 500msä»¥ä¸‹
                        touchDistance < this.dragThreshold) { // 10pxä»¥ä¸‹ã®ç§»å‹•
                        this.toggleInput(this.selectedComponent);
                        // console.log('Toggle input:', this.selectedComponent.type, 'to', this.selectedComponent.state);
                    } else {
                        // ãƒ‰ãƒ©ãƒƒã‚°å®Œäº† - ã‚¨ãƒªã‚¢å¤–å‰Šé™¤åˆ¤å®š
                        const component = this.selectedComponent;
                        
                        // ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ç³»ã§ã®è¡¨ç¤ºå¯èƒ½é ˜åŸŸã‚’è¨ˆç®—
                        const visibleLeft = -this.panX / this.scale;
                        const visibleTop = -this.panY / this.scale;
                        const visibleRight = (this.canvas.clientWidth - this.panX) / this.scale;
                        const visibleBottom = (this.canvas.clientHeight - this.panY) / this.scale;
                        
                        // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¨ãƒªã‚¢å¤–ã«å®Œå…¨ã«å‡ºãŸå ´åˆã¯å‰Šé™¤
                        // ãŸã ã—ã€ãƒ‘ãƒ¬ãƒƒãƒˆã‹ã‚‰æ–°ã—ãä½œæˆã•ã‚ŒãŸéƒ¨å“ã®åˆå›ãƒ‰ãƒ­ãƒƒãƒ—ã¯é™¤å¤–
                        if (!component.isNewFromPalette && 
                            (component.x + component.width < visibleLeft || 
                             component.x > visibleRight || 
                             component.y + component.height < visibleTop || 
                             component.y > visibleBottom)) {
                            
                            console.log('Component dragged outside canvas, deleting:', component.type);
                            
                            // å‰Šé™¤ã™ã‚‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«æ¥ç¶šã•ã‚ŒãŸæ¥ç¶šç·šã‚’ã™ã¹ã¦å‰Šé™¤
                            const connectionsToDelete = this.connections.filter(connection => 
                                connection.from.component.id === component.id || 
                                connection.to.component.id === component.id
                            );
                            
                            connectionsToDelete.forEach(connection => {
                                this.removeConnection(connection.id);
                            });
                            
                            // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å‰Šé™¤
                            this.components.delete(component.id);
                            this.selectedComponent = null;
                            this.render();
                            this.saveState();
                            this.updateSimulation();
                        } else {
                            // é€šå¸¸ã®ãƒ‰ãƒ©ãƒƒã‚°å®Œäº†
                            // ãƒ‘ãƒ¬ãƒƒãƒˆã‹ã‚‰ä½œæˆã•ã‚ŒãŸãƒ•ãƒ©ã‚°ã‚’ã‚¯ãƒªã‚¢
                            if (component.isNewFromPalette) {
                                component.isNewFromPalette = false;
                                console.log('Component placed from palette:', component.type);
                            }
                            this.saveState();
                            // console.log('Drag completed for:', this.selectedComponent.type);
                        }
                    }
                    
                    this.isDragging = false;
                    this.pendingComponent = null;
                } else if (this.isPanning) {
                    this.isPanning = false;
                    this.lastPanPoint = null;
                }
                
                // çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.touchStartTime = 0;
                this.touchStartPos = null;
            }

            handleWheel(event) {
                event.preventDefault();
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                
                const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.max(0.1, Math.min(3, this.scale * zoomFactor));
                
                // ã‚ºãƒ¼ãƒ ä¸­å¿ƒã‚’èª¿æ•´
                this.panX = mouseX - (mouseX - this.panX) * (newScale / this.scale);
                this.panY = mouseY - (mouseY - this.panY) * (newScale / this.scale);
                
                this.scale = newScale;
                this.render();
            }

            startComponentDrag(event) {
                event.preventDefault();
                
                // æ¨ªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ã¯ã€å³åº§ã«ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ã›ãšã€ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åˆ¤å®šã‚’å¾…ã¤
                const isLandscape = window.innerWidth <= 768 && window.innerHeight <= 500 && window.matchMedia('(orientation: landscape)').matches;
                
                if (isLandscape) {
                    // æ¨ªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šéƒ¨å“ãƒ‰ãƒ©ãƒƒã‚°ã‚’ä¿ç•™ã—ã¦ã€ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«åˆ¤å®šã«å§”ã­ã‚‹
                    this.pendingComponentDrag = {
                        type: event.currentTarget.dataset.type,
                        event: event
                    };
                    return;
                }
                
                // ç¸¦ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šå¾“æ¥é€šã‚Šã®å‡¦ç†
                this.isPaletteScrolling = false;
                const type = event.currentTarget.dataset.type;
                
                // ãƒ‘ãƒ¬ãƒƒãƒˆã‚¢ã‚¤ãƒ†ãƒ ã®å ´åˆã¯ã€é©åˆ‡ãªã‚­ãƒ£ãƒ³ãƒã‚¹åº§æ¨™ã«éƒ¨å“ã‚’ä½œæˆ
                let x, y;
                const canvasRect = this.canvas.getBoundingClientRect();
                
                if (event.type === 'touchstart' && event.touches && event.touches.length > 0) {
                    // ã‚¿ãƒƒãƒã®å ´åˆ
                    const touch = event.touches[0];
                    console.log('Touch position:', touch.clientX, touch.clientY);
                    console.log('Canvas rect:', canvasRect);
                    
                    // ã‚¿ãƒƒãƒä½ç½®ãŒã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆæ¨ªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ã¯ãƒ‘ãƒ¬ãƒƒãƒˆé ˜åŸŸã‚’é™¤å¤–ï¼‰
                    let isWithinCanvas = false;
                    const isLandscape = window.innerWidth <= 768 && window.innerHeight <= 500 && window.matchMedia('(orientation: landscape)').matches;
                    
                    if (isLandscape) {
                        // æ¨ªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šãƒ‘ãƒ¬ãƒƒãƒˆé ˜åŸŸï¼ˆä¸‹éƒ¨140pxï¼‰ã‚’é™¤å¤–
                        isWithinCanvas = touch.clientX >= canvasRect.left && touch.clientX <= canvasRect.right &&
                                       touch.clientY >= canvasRect.top && touch.clientY <= (canvasRect.bottom - 140);
                    } else {
                        // ç¸¦ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šé€šå¸¸ã®åˆ¤å®š
                        isWithinCanvas = touch.clientX >= canvasRect.left && touch.clientX <= canvasRect.right &&
                                       touch.clientY >= canvasRect.top && touch.clientY <= canvasRect.bottom;
                    }
                    
                    if (isWithinCanvas) {
                        // ã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã®å ´åˆã€ãã®åº§æ¨™ã‚’ä½¿ç”¨
                        x = (touch.clientX - canvasRect.left - this.panX) / this.scale;
                        y = (touch.clientY - canvasRect.top - this.panY) / this.scale;
                        console.log('Touch within canvas, using touch position:', x, y);
                    } else {
                        // ã‚­ãƒ£ãƒ³ãƒã‚¹å¤–ï¼ˆãƒ‘ãƒ¬ãƒƒãƒˆï¼‰ã®å ´åˆã€ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸­å¤®ã«é…ç½®
                        if (isLandscape) {
                            // æ¨ªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šãƒ‘ãƒ¬ãƒƒãƒˆé ˜åŸŸã‚’é™¤ã„ãŸã‚­ãƒ£ãƒ³ãƒã‚¹ä¸­å¤®
                            x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                            y = ((this.canvas.clientHeight - 140) / 2 - this.panY) / this.scale;
                        } else {
                            // ç¸¦ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šé€šå¸¸ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸­å¤®
                            x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                            y = (this.canvas.clientHeight / 2 - this.panY) / this.scale;
                        }
                        console.log('Touch outside canvas (palette), using center:', x, y);
                    }
                } else {
                    // ãƒã‚¦ã‚¹ã®å ´åˆã‚‚åŒæ§˜ã®å‡¦ç†
                    x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                    y = (this.canvas.clientHeight / 2 - this.panY) / this.scale;
                    console.log('Mouse event, using center:', x, y);
                }
                
                const component = this.createComponent(type, x, y);
                component.isNewFromPalette = true; // ãƒ‘ãƒ¬ãƒƒãƒˆã‹ã‚‰ä½œæˆã•ã‚ŒãŸã“ã¨ã‚’è¨˜éŒ²
                
                // é‡è¦ï¼šã¾ã ãƒãƒƒãƒ—ã«ã¯è¿½åŠ ã›ãšã€ä¸€æ™‚çš„ã«ä¿æŒ
                this.pendingComponent = component;
                this.selectedComponent = component;
                this.isDragging = true;
                this.dragOffset = { x: 0, y: 0 };
                this.dragStarted = false; // å®Ÿéš›ã®ãƒ‰ãƒ©ãƒƒã‚°ãŒé–‹å§‹ã•ã‚ŒãŸã‹ã®ãƒ•ãƒ©ã‚°
                
                // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
                if (event.type === 'touchstart') {
                    this.setupGlobalTouchHandlers();
                }
                
                // ã¾ã æç”»ã¯ã—ãªã„ï¼ˆéƒ¨å“ã¯è¡¨ç¤ºã•ã‚Œãªã„ï¼‰
                console.log('Component prepared for drag, not yet visible:', component.type);
            }
            
            setupGlobalTouchHandlers() {
                // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚¿ãƒƒãƒãƒ ãƒ¼ãƒ–ã¨ã‚¿ãƒƒãƒã‚¨ãƒ³ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ 
                const handleGlobalTouchMove = (event) => {
                    if (this.isDragging) {
                        event.preventDefault();
                        this.handlePointerMove(event);
                    }
                };
                
                const handleGlobalTouchEnd = (event) => {
                    if (this.isDragging) {
                        event.preventDefault();
                        this.handlePointerUp(event);
                    }
                    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
                    document.removeEventListener('touchmove', handleGlobalTouchMove);
                    document.removeEventListener('touchend', handleGlobalTouchEnd);
                };
                
                document.addEventListener('touchmove', handleGlobalTouchMove, { passive: false });
                document.addEventListener('touchend', handleGlobalTouchEnd, { passive: false });
            }

            createComponent(type, x, y) {
                const id = 'comp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                
                // åŸºæœ¬ã‚²ãƒ¼ãƒˆã¯ä¸€å›ã‚Šå¤§ãã
                let width = 90;
                let height = 50;
                if (['AND', 'OR', 'XOR', 'NAND', 'NOR', 'NOT'].includes(type)) {
                    width = 110;
                    height = 60;
                }
                
                const baseComponent = {
                    id,
                    type,
                    x,
                    y,
                    width,
                    height,
                    inputs: [],
                    outputs: [],
                    state: false,
                    zIndex: this.nextZIndex++ // Z-indexè¨­å®š
                };

                // ã‚¿ã‚¤ãƒ—åˆ¥ã®è¨­å®š
                switch (type) {
                    case 'AND':
                    case 'OR':
                    case 'XOR':
                        baseComponent.inputs = [
                            { id: 'in1', x: 0, y: 15, connected: null },
                            { id: 'in2', x: 0, y: 45, connected: null }
                        ];
                        baseComponent.outputs = [
                            { id: 'out', x: 110, y: 30, connected: [] }
                        ];
                        break;
                    case 'NAND':
                    case 'NOR':
                        baseComponent.inputs = [
                            { id: 'in1', x: 0, y: 15, connected: null },
                            { id: 'in2', x: 0, y: 45, connected: null }
                        ];
                        baseComponent.outputs = [
                            { id: 'out', x: 110, y: 30, connected: [] }
                        ];
                        break;
                    case 'NOT':
                        baseComponent.inputs = [
                            { id: 'in', x: 0, y: 30, connected: null }
                        ];
                        baseComponent.outputs = [
                            { id: 'out', x: 110, y: 30, connected: [] }
                        ];
                        break;
                    case 'INPUT':
                    case 'SWITCH':
                        baseComponent.outputs = [
                            { id: 'out', x: 90, y: 25, connected: [] }
                        ];
                        break;
                    case 'OUTPUT':
                    case 'LED':
                        baseComponent.inputs = [
                            { id: 'in', x: 0, y: 25, connected: null }
                        ];
                        break;
                }

                return baseComponent;
            }
            
            getPortAt(x, y) {
                const tolerance = 20; // ã‚¿ãƒƒãƒæ“ä½œã«é©ã—ãŸã‚µã‚¤ã‚ºã«æ‹¡å¤§
                
                for (const component of this.components.values()) {
                    // å…¥åŠ›ãƒãƒ¼ãƒˆã‚’ãƒã‚§ãƒƒã‚¯
                    for (const port of component.inputs || []) {
                        const portX = component.x + port.x;
                        const portY = component.y + port.y;
                        if (Math.abs(x - portX) <= tolerance && Math.abs(y - portY) <= tolerance) {
                            console.log('getPortAt - Found input port at', portX, portY);
                            return { component, port, type: 'input' };
                        }
                    }
                    
                    // å‡ºåŠ›ãƒãƒ¼ãƒˆã‚’ãƒã‚§ãƒƒã‚¯
                    for (const port of component.outputs || []) {
                        const portX = component.x + port.x;
                        const portY = component.y + port.y;
                        if (Math.abs(x - portX) <= tolerance && Math.abs(y - portY) <= tolerance) {
                            console.log('getPortAt - Found output port at', portX, portY);
                            return { component, port, type: 'output' };
                        }
                    }
                }
                
                return null;
            }
            
            findBestInputPort(component, x, y) {
                if (!component.inputs || component.inputs.length === 0) return null;
                
                // æœ€ã‚‚è¿‘ã„å…¥åŠ›ç«¯å­ã‚’æ¢ã™
                let bestPort = null;
                let minDistance = Infinity;
                
                for (const port of component.inputs) {
                    const portX = component.x + port.x;
                    const portY = component.y + port.y;
                    const distance = Math.sqrt(Math.pow(x - portX, 2) + Math.pow(y - portY, 2));
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestPort = port;
                    }
                }
                
                return bestPort ? { component, port: bestPort, type: 'input' } : null;
            }
            
            findBestOutputPort(component, x, y) {
                if (!component.outputs || component.outputs.length === 0) return null;
                
                // æœ€ã‚‚è¿‘ã„å‡ºåŠ›ç«¯å­ã‚’æ¢ã™
                let bestPort = null;
                let minDistance = Infinity;
                
                for (const port of component.outputs) {
                    const portX = component.x + port.x;
                    const portY = component.y + port.y;
                    const distance = Math.sqrt(Math.pow(x - portX, 2) + Math.pow(y - portY, 2));
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestPort = port;
                    }
                }
                
                return bestPort ? { component, port: bestPort, type: 'output' } : null;
            }
            
            startConnection(portInfo) {
                this.isConnecting = true;
                this.connectionStart = portInfo;
                console.log('startConnection - Port:', portInfo.type, 'Component:', portInfo.component.type);
            }
            
            completeConnection(startPort, endPort) {
                console.log('completeConnection - Start:', startPort.type, 'End:', endPort.type);
                
                // æ¥ç¶šã®å¦¥å½“æ€§ã‚’ãƒã‚§ãƒƒã‚¯
                if (startPort.type === endPort.type) {
                    console.log('Cannot connect same type ports');
                    return; // åŒã˜ã‚¿ã‚¤ãƒ—ã¯æ¥ç¶šä¸å¯
                }
                if (startPort.component === endPort.component) {
                    console.log('Cannot connect same component');
                    return; // åŒã˜éƒ¨å“å†…ã¯æ¥ç¶šä¸å¯
                }
                
                let outputPort = startPort.type === 'output' ? startPort : endPort;
                let inputPort = startPort.type === 'input' ? startPort : endPort;
                
                // æ—¢å­˜ã®æ¥ç¶šã‚’ãƒã‚§ãƒƒã‚¯
                if (inputPort.port.connected) {
                    this.removeConnection(inputPort.port.connected);
                }
                
                // æ–°ã—ã„æ¥ç¶šã‚’ä½œæˆ
                const connection = {
                    id: 'conn_' + Date.now(),
                    from: { component: outputPort.component, port: outputPort.port },
                    to: { component: inputPort.component, port: inputPort.port }
                };
                
                console.log('Connection created:', connection.id);
                this.connections.push(connection);
                inputPort.port.connected = connection.id;
                outputPort.port.connected = outputPort.port.connected || [];
                outputPort.port.connected.push(connection.id);
                
                this.saveState();
                this.updateSimulation();
            }
            
            cancelConnection() {
                console.log('cancelConnection - Was connecting:', this.isConnecting);
                this.isConnecting = false;
                this.connectionStart = null;
            }
            
            removeConnection(connectionId) {
                const connectionIndex = this.connections.findIndex(c => c.id === connectionId);
                if (connectionIndex === -1) return;
                
                const connection = this.connections[connectionIndex];
                
                // ãƒãƒ¼ãƒˆã‹ã‚‰æ¥ç¶šæƒ…å ±ã‚’å‰Šé™¤
                connection.to.port.connected = null;
                if (connection.from.port.connected) {
                    const index = connection.from.port.connected.indexOf(connectionId);
                    if (index > -1) {
                        connection.from.port.connected.splice(index, 1);
                    }
                }
                
                this.connections.splice(connectionIndex, 1);
            }
            
            toggleInput(component) {
                component.state = !component.state;
                // console.log('toggleInput - Component:', component.type, 'ID:', component.id, 'New state:', component.state);
                this.updateSimulation();
                this.render();
                this.saveState();
            }
            
            updateSimulation() {
                if (!this.isSimulating) return;
                
                // å„éƒ¨å“ã®çŠ¶æ…‹ã‚’è¨ˆç®—
                for (const component of this.components.values()) {
                    this.calculateComponentState(component);
                }
                
                this.render();
            }
            
            calculateComponentState(component) {
                if (component.type === 'INPUT' || component.type === 'SWITCH') {
                    // å…¥åŠ›éƒ¨å“ã¯æ‰‹å‹•ã§çŠ¶æ…‹ã‚’è¨­å®š
                    return;
                }
                
                // å…¥åŠ›å€¤ã‚’å–å¾—
                const inputs = (component.inputs || []).map(port => {
                    if (!port.connected) return false;
                    
                    const connection = this.connections.find(c => c.id === port.connected);
                    if (!connection) return false;
                    
                    return connection.from.component.state || false;
                });
                
                // è«–ç†æ¼”ç®—ã‚’å®Ÿè¡Œ
                switch (component.type) {
                    case 'AND':
                        component.state = inputs.length >= 2 && inputs.every(Boolean);
                        break;
                    case 'OR':
                        component.state = inputs.some(Boolean);
                        break;
                    case 'NOT':
                        component.state = inputs.length > 0 && !inputs[0];
                        break;
                    case 'XOR':
                        component.state = inputs.length >= 2 && inputs.filter(Boolean).length === 1;
                        break;
                    case 'NAND':
                        component.state = !(inputs.length >= 2 && inputs.every(Boolean));
                        break;
                    case 'NOR':
                        component.state = !inputs.some(Boolean);
                        break;
                    case 'OUTPUT':
                    case 'LED':
                        component.state = inputs.length > 0 && inputs[0];
                        break;
                    default:
                        component.state = false;
                }
            }

            getComponentAt(x, y, cycleSelection = false) {
                // æŒ‡å®šä½ç½®ã®å…¨ã¦ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å–å¾—ï¼ˆZ-indexé™é †ã§ã‚½ãƒ¼ãƒˆï¼‰
                const componentsAtPosition = [];
                for (const component of this.components.values()) {
                    if (x >= component.x && x <= component.x + component.width &&
                        y >= component.y && y <= component.y + component.height) {
                        componentsAtPosition.push(component);
                    }
                }
                
                // Z-indexã§é™é †ã‚½ãƒ¼ãƒˆï¼ˆæœ€å‰é¢ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒæœ€åˆã«æ¥ã‚‹ï¼‰
                componentsAtPosition.sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0));
                
                if (componentsAtPosition.length === 0) {
                    // console.log('No component found at', x, y);
                    this.overlappingComponents = [];
                    this.currentOverlapIndex = 0;
                    this.lastClickPosition = null;
                    return null;
                }
                
                if (componentsAtPosition.length === 1) {
                    // é‡ãªã‚Šãªã—
                    return componentsAtPosition[0];
                }
                
                // é‡ãªã‚Šã‚ã‚Š - å¾ªç’°é¸æŠã®å‡¦ç†
                const clickThreshold = 20; // åŒã˜ä½ç½®åˆ¤å®šã®è¨±å®¹ç¯„å›²
                const isSamePosition = this.lastClickPosition && 
                    Math.abs(x - this.lastClickPosition.x) < clickThreshold &&
                    Math.abs(y - this.lastClickPosition.y) < clickThreshold;
                
                if (cycleSelection && isSamePosition && 
                    JSON.stringify(this.overlappingComponents.map(c => c.id)) === 
                    JSON.stringify(componentsAtPosition.map(c => c.id))) {
                    // åŒã˜ä½ç½®ã§ã®é€£ç¶šã‚¯ãƒªãƒƒã‚¯ - æ¬¡ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’é¸æŠ
                    this.currentOverlapIndex = (this.currentOverlapIndex + 1) % componentsAtPosition.length;
                } else {
                    // æ–°ã—ã„ä½ç½®ã¾ãŸã¯åˆå› - æœ€åˆã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’é¸æŠ
                    this.overlappingComponents = componentsAtPosition;
                    this.currentOverlapIndex = 0;
                }
                
                this.lastClickPosition = { x, y };
                
                const selectedComponent = componentsAtPosition[this.currentOverlapIndex];
                console.log(`Selected component ${this.currentOverlapIndex + 1}/${componentsAtPosition.length}:`, 
                           selectedComponent.type, selectedComponent.id);
                
                return selectedComponent;
            }
            
            getConnectionAt(x, y) {
                const tolerance = 30; // æ¥ç¶šç·šã®å½“ãŸã‚Šåˆ¤å®šã®è¨±å®¹ç¯„å›²ï¼ˆã•ã‚‰ã«ã‚¿ãƒƒãƒã—ã‚„ã™ãæ‹¡å¤§ï¼‰
                let closestConnection = null;
                let closestDistance = Infinity;
                
                for (const connection of this.connections) {
                    const fromX = connection.from.component.x + connection.from.port.x;
                    const fromY = connection.from.component.y + connection.from.port.y;
                    const toX = connection.to.component.x + connection.to.port.x;
                    const toY = connection.to.component.y + connection.to.port.y;
                    
                    // ãƒ™ã‚¸ã‚¨æ›²ç·šã®è©³ç´°ãªå½“ãŸã‚Šåˆ¤å®šï¼ˆã‚ˆã‚Šå¤šãã®ç‚¹ã§åˆ¤å®šï¼‰
                    const midX = (fromX + toX) / 2;
                    
                    // ãƒ™ã‚¸ã‚¨æ›²ç·šã®è¤‡æ•°ç‚¹ã§ã®å½“ãŸã‚Šåˆ¤å®š
                    const points = [];
                    for (let i = 0; i <= 20; i++) {
                        const t = i / 20;
                        // æ­£ç¢ºãªãƒ™ã‚¸ã‚¨æ›²ç·šã®è¨ˆç®—ï¼ˆ3æ¬¡ãƒ™ã‚¸ã‚¨æ›²ç·šï¼‰
                        const bezierX = Math.pow(1-t, 3) * fromX + 
                                       3 * Math.pow(1-t, 2) * t * midX + 
                                       3 * (1-t) * Math.pow(t, 2) * midX + 
                                       Math.pow(t, 3) * toX;
                        const bezierY = Math.pow(1-t, 3) * fromY + 
                                       3 * Math.pow(1-t, 2) * t * fromY + 
                                       3 * (1-t) * Math.pow(t, 2) * toY + 
                                       Math.pow(t, 3) * toY;
                        
                        points.push({ x: bezierX, y: bezierY });
                    }
                    
                    // ã“ã®æ¥ç¶šç·šã®æœ€çŸ­è·é›¢ã‚’è¨ˆç®—
                    let minDistanceForConnection = Infinity;
                    for (const point of points) {
                        const distance = Math.sqrt(Math.pow(x - point.x, 2) + Math.pow(y - point.y, 2));
                        minDistanceForConnection = Math.min(minDistanceForConnection, distance);
                    }
                    
                    // toleranceå†…ã§æœ€ã‚‚è¿‘ã„æ¥ç¶šç·šã‚’è¨˜éŒ²
                    if (minDistanceForConnection <= tolerance && minDistanceForConnection < closestDistance) {
                        closestDistance = minDistanceForConnection;
                        closestConnection = connection;
                    }
                }
                
                return closestConnection;
            }

            deleteSelected() {
                if (this.selectedComponent) {
                    // å‰Šé™¤ã™ã‚‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«æ¥ç¶šã•ã‚ŒãŸæ¥ç¶šç·šã‚’ã™ã¹ã¦å‰Šé™¤
                    const componentToDelete = this.selectedComponent;
                    const connectionsToDelete = this.connections.filter(connection => 
                        connection.from.component.id === componentToDelete.id || 
                        connection.to.component.id === componentToDelete.id
                    );
                    
                    // æ¥ç¶šç·šã‚’å‰Šé™¤
                    connectionsToDelete.forEach(connection => {
                        this.removeConnection(connection.id);
                    });
                    
                    // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å‰Šé™¤
                    this.components.delete(componentToDelete.id);
                    this.selectedComponent = null;
                    this.render();
                    this.saveState();
                    this.updateSimulation();
                } else if (this.selectedConnection) {
                    this.removeConnection(this.selectedConnection.id);
                    this.selectedConnection = null;
                    this.render();
                    this.saveState();
                    this.updateSimulation();
                }
            }

            clearAll() {
                if (confirm('ã™ã¹ã¦ã®éƒ¨å“ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
                    this.components.clear();
                    this.connections = [];
                    this.selectedComponent = null;
                    this.selectedConnection = null;
                    this.render();
                    this.saveState();
                }
            }

            saveState() {
                const state = {
                    components: Array.from(this.components.values()),
                    connections: [...this.connections]
                };
                
                this.history = this.history.slice(0, this.historyIndex + 1);
                this.history.push(JSON.stringify(state));
                this.historyIndex++;
                
                // å±¥æ­´ã®åˆ¶é™
                if (this.history.length > 50) {
                    this.history.shift();
                    this.historyIndex--;
                }
            }

            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.loadState(this.history[this.historyIndex]);
                }
            }

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.loadState(this.history[this.historyIndex]);
                }
            }

            loadState(stateStr) {
                const state = JSON.parse(stateStr);
                this.components.clear();
                
                // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å¾©å…ƒ
                state.components.forEach(comp => {
                    this.components.set(comp.id, comp);
                });
                
                // ã¾ãšå…¨ã¦ã®ãƒãƒ¼ãƒˆã®æ¥ç¶šæƒ…å ±ã‚’ã‚¯ãƒªã‚¢
                for (const component of this.components.values()) {
                    // å…¥åŠ›ãƒãƒ¼ãƒˆã®æ¥ç¶šæƒ…å ±ã‚’ã‚¯ãƒªã‚¢
                    if (component.inputs) {
                        component.inputs.forEach(port => {
                            port.connected = null;
                        });
                    }
                    // å‡ºåŠ›ãƒãƒ¼ãƒˆã®æ¥ç¶šæƒ…å ±ã‚’ã‚¯ãƒªã‚¢
                    if (component.outputs) {
                        component.outputs.forEach(port => {
                            port.connected = [];
                        });
                    }
                }
                
                // æ¥ç¶šç·šã‚’å¾©å…ƒï¼ˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå‚ç…§ã‚’å†æ§‹ç¯‰ï¼‰
                this.connections = state.connections.map(connection => {
                    const fromComponent = this.components.get(connection.from.component.id);
                    const toComponent = this.components.get(connection.to.component.id);
                    
                    if (fromComponent && toComponent) {
                        // æ­£ã—ã„ãƒãƒ¼ãƒˆå‚ç…§ã‚’å–å¾—
                        const fromPort = fromComponent.outputs?.find(p => p.id === connection.from.port.id);
                        const toPort = toComponent.inputs?.find(p => p.id === connection.to.port.id);
                        
                        if (fromPort && toPort) {
                            const restoredConnection = {
                                ...connection,
                                from: {
                                    component: fromComponent,
                                    port: fromPort
                                },
                                to: {
                                    component: toComponent,
                                    port: toPort
                                }
                            };
                            
                            // ãƒãƒ¼ãƒˆã®æ¥ç¶šæƒ…å ±ã‚‚å¾©å…ƒ
                            toPort.connected = connection.id;
                            if (!fromPort.connected) {
                                fromPort.connected = [];
                            }
                            fromPort.connected.push(connection.id);
                            
                            return restoredConnection;
                        }
                    }
                    return null; // ç„¡åŠ¹ãªæ¥ç¶šç·šã¯é™¤å¤–
                }).filter(Boolean); // null ã‚’é™¤å»
                
                this.selectedComponent = null;
                this.selectedConnection = null;
                this.render();
                this.updateSimulation();
            }

            togglePalette() {
                const palette = document.getElementById('component-palette');
                const overlay = document.getElementById('palette-overlay');
                
                palette.classList.toggle('open');
                overlay.classList.toggle('visible');
                
                // ãƒ‘ãƒ¬ãƒƒãƒˆã®è¡¨ç¤ºçŠ¶æ…‹å¤‰æ›´å¾Œã€canvasã‚µã‚¤ã‚ºã‚’å†è¨ˆç®—
                setTimeout(() => {
                    this.resizeCanvas();
                }, 100); // CSS transitionã®å®Œäº†ã‚’å¾…ã¤
            }

            saveCircuit() {
                // æ¥ç¶šæƒ…å ±ã‚’æ˜ç¤ºçš„ã«å«ã‚ãŸãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ä½œæˆ
                const componentsData = Array.from(this.components.values()).map(component => ({
                    ...component,
                    inputs: component.inputs ? component.inputs.map(port => ({
                        id: port.id,
                        x: port.x,
                        y: port.y,
                        connected: port.connected
                    })) : [],
                    outputs: component.outputs ? component.outputs.map(port => ({
                        id: port.id,
                        x: port.x,
                        y: port.y,
                        connected: port.connected
                    })) : []
                }));
                
                const connectionsData = this.connections.map(connection => ({
                    id: connection.id,
                    from: {
                        component: { id: connection.from.component.id },
                        port: { id: connection.from.port.id }
                    },
                    to: {
                        component: { id: connection.to.component.id },
                        port: { id: connection.to.port.id }
                    }
                }));
                
                const data = {
                    version: "1.0",
                    components: componentsData,
                    connections: connectionsData
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'circuit.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            loadCircuit() {
                document.getElementById('file-input').click();
            }

            handleFileLoad(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        this.components.clear();
                        
                        // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å¾©å…ƒ
                        data.components.forEach(comp => {
                            this.components.set(comp.id, comp);
                        });
                        
                        // ã¾ãšå…¨ã¦ã®ãƒãƒ¼ãƒˆã®æ¥ç¶šæƒ…å ±ã‚’ã‚¯ãƒªã‚¢
                        for (const component of this.components.values()) {
                            if (component.inputs) {
                                component.inputs.forEach(port => {
                                    port.connected = null;
                                });
                            }
                            if (component.outputs) {
                                component.outputs.forEach(port => {
                                    port.connected = [];
                                });
                            }
                        }
                        
                        // æ¥ç¶šç·šã‚’å¾©å…ƒï¼ˆã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå‚ç…§ã‚’å†æ§‹ç¯‰ï¼‰
                        this.connections = (data.connections || []).map(connection => {
                            const fromComponent = this.components.get(connection.from.component.id);
                            const toComponent = this.components.get(connection.to.component.id);
                            
                            if (fromComponent && toComponent) {
                                const fromPort = fromComponent.outputs?.find(p => p.id === connection.from.port.id);
                                const toPort = toComponent.inputs?.find(p => p.id === connection.to.port.id);
                                
                                if (fromPort && toPort) {
                                    const restoredConnection = {
                                        ...connection,
                                        from: {
                                            component: fromComponent,
                                            port: fromPort
                                        },
                                        to: {
                                            component: toComponent,
                                            port: toPort
                                        }
                                    };
                                    
                                    // ãƒãƒ¼ãƒˆã®æ¥ç¶šæƒ…å ±ã‚‚å¾©å…ƒ
                                    toPort.connected = connection.id;
                                    if (!fromPort.connected) {
                                        fromPort.connected = [];
                                    }
                                    fromPort.connected.push(connection.id);
                                    
                                    return restoredConnection;
                                }
                            }
                            return null;
                        }).filter(Boolean);
                        
                        this.selectedComponent = null;
                        this.selectedConnection = null;
                        this.render();
                        this.updateSimulation();
                        this.saveState();
                    } catch (error) {
                        alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    }
                };
                reader.readAsText(file);
            }

            exportImage() {
                const link = document.createElement('a');
                link.download = 'circuit.png';
                link.href = this.canvas.toDataURL();
                link.click();
            }

            render() {
                const ctx = this.ctx;
                const width = this.canvas.clientWidth;
                const height = this.canvas.clientHeight;
                
                // ã‚¯ãƒªã‚¢
                ctx.clearRect(0, 0, width, height);
                
                // åº§æ¨™å¤‰æ›
                ctx.save();
                ctx.translate(this.panX, this.panY);
                ctx.scale(this.scale, this.scale);
                
                // éƒ¨å“æç”»ï¼ˆZ-indexé †ï¼‰
                const sortedComponents = Array.from(this.components.values())
                    .sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0));
                for (const component of sortedComponents) {
                    this.drawComponent(ctx, component);
                }
                
                // æ¥ç¶šç·šæç”»ï¼ˆéƒ¨å“ã®ä¸Šã«è¡¨ç¤ºï¼‰
                this.drawConnections(ctx);
                
                // æ¥ç¶šä¸­ã®ç·šæç”»
                if (this.isConnecting && this.connectionStart) {
                    this.drawConnectionPreview(ctx);
                }
                
                ctx.restore();
            }

            drawComponent(ctx, component) {
                const isSelected = component === this.selectedComponent;
                const isActive = component.state;
                
                // è«–ç†å›è·¯è¨˜å·ã‚’æç”»
                this.drawLogicGateSymbol(ctx, component, isSelected, isActive);
                
                // LEDã¯è±†é›»çƒã¨ã—ã¦æç”»
                if (component.type === 'LED') {
                    const x = component.x;
                    const y = component.y;
                    const w = component.width;
                    const h = component.height;
                    
                    // æ ã®æç”»
                    let bgColor = '#ffffff';
                    if (isActive) {
                        bgColor = '#ffeb3b'; // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå‡ºåŠ›ã¯é»„è‰²
                    } else if (isSelected) {
                        bgColor = '#e3f2fd'; // é¸æŠçŠ¶æ…‹
                    }
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(x, y, w, h);
                    
                    // æ ç·š
                    ctx.strokeStyle = isSelected ? '#2196f3' : '#666666';
                    ctx.lineWidth = isSelected ? 2 : 1;
                    ctx.strokeRect(x, y, w, h);
                    
                    // è±†é›»çƒã®æç”»
                    this.drawLightBulb(ctx, x + 8, y + 8, w - 16, h - 16, isActive);
                    
                    // ãƒ©ãƒ™ãƒ«
                    ctx.fillStyle = '#333333';
                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        'LED',
                        x + w / 2,
                        y + h - 8
                    );
                }
                // OUTPUTã¯1/0è¡¨ç¤ºã€ãã®ä»–ã¯å¾“æ¥é€šã‚Š
                else if (component.type === 'OUTPUT') {
                    // èƒŒæ™¯è‰²ã¯ç™½å›ºå®š
                    let bgColor = '#ffffff';
                    if (isSelected) {
                        bgColor = '#e3f2fd'; // é¸æŠçŠ¶æ…‹
                    }
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(component.x, component.y, component.width, component.height);
                    
                    // æ ç·š
                    ctx.strokeStyle = isSelected ? '#2196f3' : '#666666';
                    ctx.lineWidth = isSelected ? 2 : 1;
                    ctx.strokeRect(component.x, component.y, component.width, component.height);
                    
                    // ä¸Šéƒ¨ã«OUTPUTãƒ©ãƒ™ãƒ«
                    ctx.fillStyle = '#666666';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        'OUTPUT',
                        component.x + component.width / 2,
                        component.y + component.height * 0.25
                    );
                    
                    // ä¸­å¤®ã«å¤§ããª1ã¾ãŸã¯0ã‚’è¡¨ç¤º
                    ctx.fillStyle = isActive ? '#4caf50' : '#f44336'; // 1ã¯ç·‘ã€0ã¯èµ¤
                    ctx.font = 'bold 24px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        isActive ? '1' : '0',
                        component.x + component.width / 2,
                        component.y + component.height * 0.65
                    );
                }
                // INPUTã¯1/0è¡¨ç¤ºã€SWITCHã¯å¾“æ¥é€šã‚Š
                else if (component.type === 'INPUT') {
                    // èƒŒæ™¯è‰²ã¯ç™½å›ºå®š
                    let bgColor = '#ffffff';
                    if (isSelected) {
                        bgColor = '#e3f2fd'; // é¸æŠçŠ¶æ…‹
                    }
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(component.x, component.y, component.width, component.height);
                    
                    // æ ç·š
                    ctx.strokeStyle = isSelected ? '#2196f3' : '#666666';
                    ctx.lineWidth = isSelected ? 2 : 1;
                    ctx.strokeRect(component.x, component.y, component.width, component.height);
                    
                    // ä¸Šéƒ¨ã«INPUTãƒ©ãƒ™ãƒ«
                    ctx.fillStyle = '#666666';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        'INPUT',
                        component.x + component.width / 2,
                        component.y + component.height * 0.25
                    );
                    
                    // ä¸­å¤®ã«å¤§ããª1ã¾ãŸã¯0ã‚’è¡¨ç¤º
                    ctx.fillStyle = isActive ? '#4caf50' : '#f44336'; // 1ã¯ç·‘ã€0ã¯èµ¤
                    ctx.font = 'bold 24px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        isActive ? '1' : '0',
                        component.x + component.width / 2,
                        component.y + component.height * 0.65
                    );
                }
                // ã‚¹ã‚¤ãƒƒãƒã¯å¾“æ¥é€šã‚Šå››è§’å½¢ã§æç”»
                else if (component.type === 'SWITCH') {
                    
                    // èƒŒæ™¯è‰²ã‚’çŠ¶æ…‹ã«å¿œã˜ã¦å¤‰æ›´
                    let bgColor = '#ffffff';
                    if (isActive) {
                        bgColor = '#4caf50'; // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå…¥åŠ›ã¯ç·‘è‰²
                    } else if (isSelected) {
                        bgColor = '#e3f2fd'; // é¸æŠçŠ¶æ…‹ã¯æœ€å¾Œã«åˆ¤å®š
                    }
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(component.x, component.y, component.width, component.height);
                    
                    // æ ç·š
                    ctx.strokeStyle = isSelected ? '#2196f3' : '#666666';
                    ctx.lineWidth = isSelected ? 2 : 1;
                    ctx.strokeRect(component.x, component.y, component.width, component.height);
                    
                    // ãƒ©ãƒ™ãƒ«
                    ctx.fillStyle = '#333333';
                    ctx.font = '14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        component.type,
                        component.x + component.width / 2,
                        component.y + component.height / 2
                    );
                }
                
                // ãƒ”ãƒ³æç”»
                // å…¥åŠ›ãƒ”ãƒ³
                component.inputs?.forEach(pin => {
                    ctx.fillStyle = pin.connected ? '#2196f3' : '#4caf50';
                    ctx.beginPath();
                    ctx.arc(component.x + pin.x, component.y + pin.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
                
                // å‡ºåŠ›ãƒ”ãƒ³
                component.outputs?.forEach(pin => {
                    ctx.fillStyle = (pin.connected && pin.connected.length > 0) ? '#2196f3' : '#ff9800';
                    ctx.beginPath();
                    ctx.arc(component.x + pin.x, component.y + pin.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
            }
            
            drawLogicGateSymbol(ctx, component, isSelected, isActive) {
                const x = component.x;
                const y = component.y;
                const w = component.width;
                const h = component.height;
                
                // è«–ç†ã‚²ãƒ¼ãƒˆä»¥å¤–ã¯ã“ã“ã§ã¯æç”»ã—ãªã„
                if (!['AND', 'OR', 'XOR', 'NAND', 'NOR', 'NOT'].includes(component.type)) {
                    return;
                }
                
                // è‰²è¨­å®š
                const fillColor = isSelected ? '#e3f2fd' : '#ffffff';
                const strokeColor = isSelected ? '#2196f3' : '#333333';
                const lineWidth = isSelected ? 2 : 1;
                
                // åŸºæœ¬ã‚²ãƒ¼ãƒˆã®å ´åˆã¯æ ã‚’æç”»
                if (['AND', 'OR', 'XOR', 'NAND', 'NOR', 'NOT'].includes(component.type)) {
                    // æ ã®æç”»
                    ctx.fillStyle = fillColor;
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = lineWidth;
                    ctx.fillRect(x, y, w, h);
                    ctx.strokeRect(x, y, w, h);
                    
                    // å›³å½¢ã®æç”»ï¼ˆæ ã®ä¸­ã«æç”»ï¼‰
                    ctx.fillStyle = '#ffffff'; // å›³å½¢ã¯ç™½è‰²
                    ctx.strokeStyle = '#333333'; // å›³å½¢ã®ç·šã¯æ¿ƒã„ã‚°ãƒ¬ãƒ¼
                    ctx.lineWidth = 1;
                    
                    switch (component.type) {
                        case 'AND':
                            this.drawANDGateInside(ctx, x + 8, y + 8, w - 16, h - 16);
                            this.drawGateLabel(ctx, 'AND', x, y, w, h);
                            break;
                        case 'OR':
                            this.drawORGateInside(ctx, x + 8, y + 8, w - 16, h - 16);
                            this.drawGateLabel(ctx, 'OR', x, y, w, h);
                            break;
                        case 'XOR':
                            this.drawXORGateInside(ctx, x + 8, y + 8, w - 16, h - 16);
                            this.drawGateLabel(ctx, 'XOR', x, y, w, h);
                            break;
                        case 'NAND':
                            this.drawANDGateInside(ctx, x + 8, y + 8, w - 26, h - 16);
                            this.drawNotBubble(ctx, x + w - 29, y + h/2, 4);
                            this.drawGateLabel(ctx, 'NAND', x, y, w, h);
                            break;
                        case 'NOR':
                            this.drawORGateInside(ctx, x + 8, y + 8, w - 26, h - 16);
                            this.drawNotBubble(ctx, x + w - 18, y + h/2, 4);
                            this.drawGateLabel(ctx, 'NOR', x, y, w, h);
                            break;
                        case 'NOT':
                            this.drawNOTGateInside(ctx, x + 8, y + 8, w - 26, h - 16);
                            this.drawNotBubble(ctx, x + w - 18, y + h/2, 4);
                            this.drawGateLabel(ctx, 'NOT', x, y, w, h);
                            break;
                    }
                } else {
                    // ä»–ã®éƒ¨å“ï¼ˆINPUTã€OUTPUTç­‰ï¼‰ã¯å¾“æ¥é€šã‚Š
                    ctx.fillStyle = fillColor;
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = lineWidth;
                }
            }
            
            // æ å†…æç”»ç”¨ã®ã‚²ãƒ¼ãƒˆé–¢æ•°ç¾¤
            drawANDGateInside(ctx, x, y, w, h) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + w * 0.6, y);
                ctx.arc(x + w * 0.6, y + h/2, h/2, -Math.PI/2, Math.PI/2);
                ctx.lineTo(x, y + h);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            drawORGateInside(ctx, x, y, w, h) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.quadraticCurveTo(x + w * 0.6, y, x + w, y + h/2);
                ctx.quadraticCurveTo(x + w * 0.6, y + h, x, y + h);
                ctx.quadraticCurveTo(x + w * 0.2, y + h/2, x, y);
                ctx.fill();
                ctx.stroke();
            }
            
            drawXORGateInside(ctx, x, y, w, h) {
                // å¤–å´ã®æ›²ç·š
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.quadraticCurveTo(x + w * 0.6, y, x + w, y + h/2);
                ctx.quadraticCurveTo(x + w * 0.6, y + h, x, y + h);
                ctx.quadraticCurveTo(x + w * 0.2, y + h/2, x, y);
                ctx.fill();
                ctx.stroke();
                
                // å†…å´ã®è¿½åŠ ç·š
                ctx.beginPath();
                ctx.moveTo(x - 4, y);
                ctx.quadraticCurveTo(x + w * 0.2 - 4, y + h/2, x - 4, y + h);
                ctx.stroke();
            }
            
            drawNOTGateInside(ctx, x, y, w, h) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y + h);
                ctx.lineTo(x + w, y + h/2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            drawLightBulb(ctx, x, y, w, h, isActive) {
                ctx.save();
                
                const centerX = x + w / 2;
                const centerY = y + h / 2;
                const bulbWidth = w * 0.7;
                const bulbHeight = h * 0.8;
                
                // ã‚¨ãƒ¬ã‚¬ãƒ³ãƒˆãªè±†é›»çƒã®å½¢ï¼ˆæ¶™æ»´å½¢ï¼‰
                ctx.beginPath();
                
                // ä¸Šéƒ¨ã®ä¸¸ã„éƒ¨åˆ†
                const topRadius = bulbWidth * 0.35;
                const topCenterY = centerY - bulbHeight * 0.15;
                ctx.arc(centerX, topCenterY, topRadius, 0, Math.PI, true);
                
                // ä¸‹éƒ¨ã®ã¨ãŒã£ãŸéƒ¨åˆ†ï¼ˆãƒ™ã‚¸ã‚§æ›²ç·šã§æ»‘ã‚‰ã‹ã«ï¼‰
                ctx.bezierCurveTo(
                    centerX - topRadius, topCenterY,
                    centerX - bulbWidth * 0.2, centerY + bulbHeight * 0.3,
                    centerX, centerY + bulbHeight * 0.4
                );
                ctx.bezierCurveTo(
                    centerX + bulbWidth * 0.2, centerY + bulbHeight * 0.3,
                    centerX + topRadius, topCenterY,
                    centerX + topRadius, topCenterY
                );
                
                ctx.closePath();
                
                // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœ
                if (isActive) {
                    // ç‚¹ç¯æ™‚ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                    const gradient = ctx.createRadialGradient(
                        centerX - topRadius * 0.3, topCenterY - topRadius * 0.3, 0,
                        centerX, centerY, topRadius
                    );
                    gradient.addColorStop(0, '#fffacd');
                    gradient.addColorStop(0.6, '#ffff00');
                    gradient.addColorStop(1, '#ffa500');
                    ctx.fillStyle = gradient;
                } else {
                    // æ¶ˆç¯æ™‚ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                    const gradient = ctx.createRadialGradient(
                        centerX - topRadius * 0.3, topCenterY - topRadius * 0.3, 0,
                        centerX, centerY, topRadius
                    );
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.6, '#f0f0f0');
                    gradient.addColorStop(1, '#d0d0d0');
                    ctx.fillStyle = gradient;
                }
                
                ctx.fill();
                
                // å¤–æ 
                ctx.strokeStyle = isActive ? '#cc8800' : '#999999';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // ã‚½ã‚±ãƒƒãƒˆéƒ¨åˆ†ï¼ˆä¸‹éƒ¨ã®é‡‘å±ã‚­ãƒ£ãƒƒãƒ—ï¼‰
                const socketY = centerY + bulbHeight * 0.35;
                const socketHeight = h * 0.15;
                
                ctx.fillStyle = '#b8860b';
                ctx.fillRect(centerX - bulbWidth * 0.2, socketY, bulbWidth * 0.4, socketHeight);
                
                // ã‚½ã‚±ãƒƒãƒˆã®èºæ—‹æ¨¡æ§˜
                ctx.strokeStyle = '#8b7355';
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    const lineY = socketY + (socketHeight / 4) * (i + 1);
                    ctx.beginPath();
                    ctx.moveTo(centerX - bulbWidth * 0.18, lineY);
                    ctx.lineTo(centerX + bulbWidth * 0.18, lineY);
                    ctx.stroke();
                }
                
                // ãƒ•ã‚£ãƒ©ãƒ¡ãƒ³ãƒˆï¼ˆã‚¨ãƒ¬ã‚¬ãƒ³ãƒˆãªæ›²ç·šï¼‰
                if (isActive) {
                    ctx.strokeStyle = '#ff4500';
                    ctx.lineWidth = 1.5;
                } else {
                    ctx.strokeStyle = '#aaaaaa';
                    ctx.lineWidth = 1;
                }
                
                ctx.beginPath();
                // ä¸­å¤®ã®æ”¯æŸ±
                ctx.moveTo(centerX, centerY + bulbHeight * 0.2);
                ctx.lineTo(centerX, topCenterY);
                
                // ç¾ã—ã„æ›²ç·šã®ãƒ•ã‚£ãƒ©ãƒ¡ãƒ³ãƒˆ
                ctx.moveTo(centerX - topRadius * 0.4, topCenterY - topRadius * 0.2);
                ctx.quadraticCurveTo(centerX, topCenterY - topRadius * 0.4, centerX + topRadius * 0.4, topCenterY - topRadius * 0.2);
                ctx.moveTo(centerX - topRadius * 0.3, topCenterY);
                ctx.quadraticCurveTo(centerX, topCenterY + topRadius * 0.3, centerX + topRadius * 0.3, topCenterY);
                
                ctx.stroke();
                
                // ç‚¹ç¯æ™‚ã®å…‰ã®ã‚ªãƒ¼ãƒ©
                if (isActive) {
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.15)';
                    ctx.beginPath();
                    ctx.arc(centerX, topCenterY, topRadius * 1.8, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // å…‰ã®ç·š
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI * 2) / 8;
                        const x1 = centerX + Math.cos(angle) * topRadius * 1.2;
                        const y1 = topCenterY + Math.sin(angle) * topRadius * 1.2;
                        const x2 = centerX + Math.cos(angle) * topRadius * 1.6;
                        const y2 = topCenterY + Math.sin(angle) * topRadius * 1.6;
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
            }
            
            // å¾“æ¥ã®ã‚²ãƒ¼ãƒˆé–¢æ•°ï¼ˆå¾Œæ–¹äº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰
            drawANDGate(ctx, x, y, w, h) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + w - h/2, y);
                ctx.arc(x + w - h/2, y + h/2, h/2, -Math.PI/2, Math.PI/2);
                ctx.lineTo(x, y + h);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            drawORGate(ctx, x, y, w, h) {
                ctx.beginPath();
                // å·¦å´ã®æ›²ç·š
                ctx.moveTo(x, y);
                ctx.quadraticCurveTo(x + w * 0.3, y + h/2, x, y + h);
                // å³å´ã®æ›²ç·š
                ctx.quadraticCurveTo(x + w * 0.7, y + h * 0.8, x + w, y + h/2);
                ctx.quadraticCurveTo(x + w * 0.7, y + h * 0.2, x, y);
                ctx.fill();
                ctx.stroke();
            }
            
            drawXORGate(ctx, x, y, w, h) {
                // ORã‚²ãƒ¼ãƒˆã‚’æç”»
                this.drawORGate(ctx, x + 8, y, w - 8, h);
                
                // å·¦å´ã®è¿½åŠ ç·š
                ctx.beginPath();
                ctx.moveTo(x, y + h * 0.2);
                ctx.quadraticCurveTo(x + w * 0.2, y + h/2, x, y + h * 0.8);
                ctx.stroke();
            }
            
            drawNOTGate(ctx, x, y, w, h) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y + h);
                ctx.lineTo(x + w - 10, y + h/2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // NOTãƒãƒ–ãƒ« (å³ç«¯è¿‘ãã«é…ç½®)
                this.drawNotBubble(ctx, x + w - 8, y + h/2, 3);
            }
            
            drawNOTTriangle(ctx, x, y, w, h) {
                // NOT gate triangle only (without bubble)
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y + h);
                ctx.lineTo(x + w, y + h/2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            drawNotBubble(ctx, x, y, radius = 5) {
                ctx.beginPath();
                ctx.arc(x + radius, y, radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
            }
            
            drawGateLabel(ctx, label, x, y, w, h) {
                // ãƒ†ã‚­ã‚¹ãƒˆã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š
                ctx.save();
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // ã‚²ãƒ¼ãƒˆã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦ä½ç½®ã‚’å¾®èª¿æ•´
                let centerX = x + w / 2;
                const centerY = y + h / 2 + 1; // å…¨ã¦ã®ãƒ©ãƒ™ãƒ«ã‚’1pxä¸‹ã«ç§»å‹•
                
                switch (label) {
                    case 'AND':
                        centerX = x + w / 2 - 5; // å·¦ã«5pxç§»å‹•
                        break;
                    case 'NOT':
                        centerX = x + w / 2 - 8; // å·¦ã«8pxç§»å‹•ï¼ˆã•ã‚‰ã«3pxå·¦ã¸ï¼‰
                        break;
                    case 'NAND':
                        centerX = x + w / 2 - 2; // å·¦ã«2pxç§»å‹•
                        break;
                    case 'NOR':
                        centerX = x + w / 2 - 2; // å·¦ã«2pxç§»å‹•
                        break;
                    case 'OR':
                    case 'XOR':
                        // ORã¨XORã¯ãã®ã¾ã¾ä¸­å¤®
                        break;
                }
                
                ctx.fillText(label, centerX, centerY);
                ctx.restore();
            }
            
            drawPaletteIcons() {
                const canvases = document.querySelectorAll('.component-icon-canvas');
                canvases.forEach(canvas => {
                    const ctx = canvas.getContext('2d');
                    const gateType = canvas.dataset.gate;
                    const w = canvas.width;
                    const h = canvas.height;
                    
                    // èƒŒæ™¯ã‚’ã‚¯ãƒªã‚¢
                    ctx.clearRect(0, 0, w, h);
                    
                    // ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š
                    ctx.fillStyle = '#ffffff';
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 1;
                    
                    // å°ã•ãªã‚µã‚¤ã‚ºã§æç”»
                    switch (gateType) {
                        case 'AND':
                            this.drawANDGate(ctx, 2, 2, w - 4, h - 4);
                            break;
                        case 'OR':
                            this.drawORGate(ctx, 2, 2, w - 4, h - 4);
                            break;
                        case 'XOR':
                            this.drawXORGate(ctx, 2, 2, w - 4, h - 4);
                            break;
                        case 'NAND':
                            // AND gate with space for bubble
                            this.drawANDGate(ctx, 2, 2, w - 12, h - 4);
                            // Position bubble with proper clearance
                            this.drawNotBubble(ctx, w - 9, h/2, 2.5);
                            break;
                        case 'NOR':
                            // OR gate with space for bubble  
                            this.drawORGate(ctx, 2, 2, w - 12, h - 4);
                            // Position bubble with proper clearance
                            this.drawNotBubble(ctx, w - 9, h/2, 2.5);
                            break;
                        case 'NOT':
                            // NOT triangle with space for bubble
                            this.drawNOTTriangle(ctx, 2, 2, w - 12, h - 4);
                            // Position bubble with proper clearance
                            this.drawNotBubble(ctx, w - 9, h/2, 2.5);
                            break;
                    }
                });
            }
            
            drawConnections(ctx) {
                for (const connection of this.connections) {
                    const fromX = connection.from.component.x + connection.from.port.x;
                    const fromY = connection.from.component.y + connection.from.port.y;
                    const toX = connection.to.component.x + connection.to.port.x;
                    const toY = connection.to.component.y + connection.to.port.y;
                    
                    // é¸æŠã•ã‚ŒãŸæ¥ç¶šç·šã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
                    const isSelected = this.selectedConnection === connection;
                    
                    // ç·šã®è‰²ã‚’ä¿¡å·çŠ¶æ…‹ã«å¿œã˜ã¦å¤‰æ›´
                    if (isSelected) {
                        ctx.strokeStyle = '#ff5722'; // é¸æŠæ™‚ã¯èµ¤è‰²
                        ctx.lineWidth = 6;
                    } else {
                        ctx.strokeStyle = connection.from.component.state ? '#4caf50' : '#9e9e9e';
                        ctx.lineWidth = 4;
                    }
                    
                    ctx.beginPath();
                    ctx.moveTo(fromX, fromY);
                    
                    // æ›²ç·šã§æ¥ç¶šã‚’æç”»
                    const midX = (fromX + toX) / 2;
                    ctx.bezierCurveTo(midX, fromY, midX, toY, toX, toY);
                    ctx.stroke();
                }
            }
            
            drawConnectionPreview(ctx) {
                if (!this.connectionStart) return;
                
                const startX = this.connectionStart.component.x + this.connectionStart.port.x;
                const startY = this.connectionStart.component.y + this.connectionStart.port.y;
                const endX = this.currentMousePos.x;
                const endY = this.currentMousePos.y;
                
                ctx.strokeStyle = '#ff5722';
                ctx.lineWidth = 4;
                ctx.setLineDash([8, 8]);
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                
                const midX = (startX + endX) / 2;
                ctx.bezierCurveTo(midX, startY, midX, endY, endX, endY);
                ctx.stroke();
                
                ctx.setLineDash([]);
            }
            
            handleTouchStart(event) {
                event.preventDefault();
                this.touches = Array.from(event.touches);
                
                if (this.touches.length === 1) {
                    // ã‚·ãƒ³ã‚°ãƒ«ã‚¿ãƒƒãƒã¯é€šå¸¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã¨ã—ã¦å‡¦ç†
                    this.handlePointerDown(event);
                } else if (this.touches.length === 2) {
                    // ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ é–‹å§‹
                    this.isPanning = false;
                    this.isDragging = false;
                    this.isConnecting = false;
                    this.selectedComponent = null;
                    this.selectedConnection = null;
                    this.cancelConnection();
                }
            }
            
            handleTouchMove(event) {
                event.preventDefault();
                this.touches = Array.from(event.touches);
                
                if (this.touches.length === 1) {
                    // ã‚·ãƒ³ã‚°ãƒ«ã‚¿ãƒƒãƒã¯é€šå¸¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã¨ã—ã¦å‡¦ç†
                    this.handlePointerMove(event);
                } else if (this.touches.length === 2) {
                    // ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ å‡¦ç†
                    this.handlePinchZoom(event);
                    
                    // ãƒ”ãƒ³ãƒä¸­ã¯ä»–ã®æ“ä½œã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                    this.isDragging = false;
                    this.isPanning = false;
                    this.isConnecting = false;
                    this.cancelConnection();
                }
            }
            
            handleTouchEnd(event) {
                event.preventDefault();
                this.touches = Array.from(event.touches);
                
                if (this.touches.length === 0) {
                    // ã™ã¹ã¦ã®ã‚¿ãƒƒãƒãŒçµ‚äº†
                    this.handlePointerUp(event);
                    this.lastPinchDistance = null;
                    this.lastPinchCenter = null;
                    this.isPaletteScrolling = false;
                } else if (this.touches.length === 1) {
                    // ãƒ”ãƒ³ãƒã‹ã‚‰ã‚·ãƒ³ã‚°ãƒ«ã‚¿ãƒƒãƒã«å¤‰æ›´
                    this.lastPinchDistance = null;
                    this.lastPinchCenter = null;
                }
            }
            
            handlePinchZoom(event) {
                const touch1 = this.touches[0];
                const touch2 = this.touches[1];
                
                const rect = this.canvas.getBoundingClientRect();
                const x1 = touch1.clientX - rect.left;
                const y1 = touch1.clientY - rect.top;
                const x2 = touch2.clientX - rect.left;
                const y2 = touch2.clientY - rect.top;
                
                const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const centerX = (x1 + x2) / 2;
                const centerY = (y1 + y2) / 2;
                
                if (this.lastPinchDistance && this.lastPinchCenter) {
                    // ã‚ºãƒ¼ãƒ å‡¦ç†
                    const scale = distance / this.lastPinchDistance;
                    const newScale = Math.max(0.1, Math.min(5, this.scale * scale));
                    
                    // ã‚ºãƒ¼ãƒ ä¸­å¿ƒã‚’ã‚¿ãƒƒãƒãƒã‚¤ãƒ³ãƒˆã®ä¸­ç‚¹ã«è¨­å®š
                    this.panX = centerX - (centerX - this.panX) * (newScale / this.scale);
                    this.panY = centerY - (centerY - this.panY) * (newScale / this.scale);
                    
                    this.scale = newScale;
                    
                    // ãƒ‘ãƒ³å‡¦ç†ï¼ˆãƒ”ãƒ³ãƒä¸­å¿ƒç‚¹ã®ç§»å‹•ã‚’è¿½è·¡ï¼‰
                    const centerDeltaX = centerX - this.lastPinchCenter.x;
                    const centerDeltaY = centerY - this.lastPinchCenter.y;
                    this.panX += centerDeltaX;
                    this.panY += centerDeltaY;
                    
                    this.render();
                }
                
                this.lastPinchDistance = distance;
                this.lastPinchCenter = { x: centerX, y: centerY };
            }
            
            // ãƒ‘ãƒ¬ãƒƒãƒˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å‡¦ç†
            handlePaletteScrollStart(event) {
                // ã‚¹ãƒãƒ›æ¨ªç”»é¢ã§ãƒ‘ãƒ¬ãƒƒãƒˆãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã®ã¿æœ‰åŠ¹
                if (window.innerWidth > 768 || window.innerHeight > 500 || !window.matchMedia('(orientation: landscape)').matches) {
                    return;
                }
                
                const palette = document.getElementById('component-palette');
                if (!palette.classList.contains('open')) {
                    return;
                }
                
                const touch = event.touches[0];
                this.paletteScrollStartX = touch.clientX;
                this.paletteScrollStartY = touch.clientY;
                
                // ãƒ‘ãƒ¬ãƒƒãƒˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ç¾åœ¨ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã‚’è¨˜éŒ²
                const paletteContent = document.querySelector('.palette-content');
                this.paletteScrollStartScrollLeft = paletteContent ? paletteContent.scrollLeft : 0;
                
                // component-itemã§ã®ã‚¿ãƒƒãƒé–‹å§‹ã®å ´åˆã¯é€šå¸¸ã®å‡¦ç†ã‚’ç¶™ç¶š
                if (event.target.closest('.component-item')) {
                    return;
                }
                
                // ãƒ‘ãƒ¬ãƒƒãƒˆèƒŒæ™¯ã®ã‚¿ãƒƒãƒé–‹å§‹æ™‚ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.isPaletteScrolling = false;
                
                event.preventDefault();
            }
            
            handlePaletteScrollMove(event) {
                // ã‚¹ãƒãƒ›æ¨ªç”»é¢ã§ãƒ‘ãƒ¬ãƒƒãƒˆãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã®ã¿æœ‰åŠ¹
                if (window.innerWidth > 768 || window.innerHeight > 500 || !window.matchMedia('(orientation: landscape)').matches) {
                    return;
                }
                
                const palette = document.getElementById('component-palette');
                if (!palette.classList.contains('open')) {
                    return;
                }
                
                const touch = event.touches[0];
                const deltaX = Math.abs(touch.clientX - this.paletteScrollStartX);
                const deltaY = Math.abs(touch.clientY - this.paletteScrollStartY);
                
                // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ­ã‚°
                console.log('Palette scroll move:', {
                    deltaX,
                    deltaY,
                    threshold: this.paletteScrollThreshold,
                    isScrolling: this.isPaletteScrolling,
                    targetClass: event.target.className,
                    closestItem: event.target.closest('.component-item') ? 'found' : 'none'
                });
                
                // æ¨ªæ–¹å‘ã®ç§»å‹•ãŒã—ãã„å€¤ã‚’è¶…ãˆãŸå ´åˆã¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                if (deltaX > this.paletteScrollThreshold) {
                    this.isPaletteScrolling = true;
                    console.log('Palette scroll activated!');
                    
                    // éƒ¨å“ãƒ‰ãƒ©ãƒƒã‚°å¾…æ©Ÿä¸­ã®å ´åˆã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«
                    if (this.pendingComponentDrag) {
                        console.log('Canceling pending component drag due to scroll');
                        this.pendingComponentDrag = null;
                    }
                }
                
                // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä¸­ã¯å®Ÿéš›ã«ãƒ‘ãƒ¬ãƒƒãƒˆã‚’ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã•ã›ã‚‹
                if (this.isPaletteScrolling) {
                    const paletteContent = document.querySelector('.palette-content');
                    if (paletteContent) {
                        const deltaX = touch.clientX - this.paletteScrollStartX;
                        const newScrollLeft = this.paletteScrollStartScrollLeft - deltaX;
                        paletteContent.scrollLeft = Math.max(0, Math.min(newScrollLeft, paletteContent.scrollWidth - paletteContent.clientWidth));
                    }
                    event.preventDefault();
                    return;
                }
            }
            
            handlePaletteScrollEnd(event) {
                // ã‚¹ãƒãƒ›æ¨ªç”»é¢ã§ãƒ‘ãƒ¬ãƒƒãƒˆãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã®ã¿æœ‰åŠ¹
                if (window.innerWidth > 768 || window.innerHeight > 500 || !window.matchMedia('(orientation: landscape)').matches) {
                    return;
                }
                
                // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãŒç™ºç”Ÿã—ãªã‹ã£ãŸå ´åˆã€éƒ¨å“ãƒ‰ãƒ©ãƒƒã‚°ã‚’é–‹å§‹
                if (!this.isPaletteScrolling && this.pendingComponentDrag) {
                    console.log('Starting component drag after no scroll detected');
                    this.executeComponentDrag(this.pendingComponentDrag.type, this.pendingComponentDrag.event);
                }
                
                this.isPaletteScrolling = false;
                this.pendingComponentDrag = null;
                
                event.preventDefault();
            }
            
            // éƒ¨å“ãƒ‰ãƒ©ãƒƒã‚°ã‚’å®Ÿè¡Œã™ã‚‹é–¢æ•°ï¼ˆå…ƒã®startComponentDragã®å‡¦ç†ã‚’æŠ½å‡ºï¼‰
            executeComponentDrag(type, event) {
                // ãƒ‘ãƒ¬ãƒƒãƒˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.isPaletteScrolling = false;
                
                // ãƒ‘ãƒ¬ãƒƒãƒˆã‚¢ã‚¤ãƒ†ãƒ ã®å ´åˆã¯ã€é©åˆ‡ãªã‚­ãƒ£ãƒ³ãƒã‚¹åº§æ¨™ã«éƒ¨å“ã‚’ä½œæˆ
                let x, y;
                const canvasRect = this.canvas.getBoundingClientRect();
                
                if (event.type === 'touchstart' && event.touches && event.touches.length > 0) {
                    // ã‚¿ãƒƒãƒã®å ´åˆ
                    const touch = event.touches[0];
                    console.log('Touch position:', touch.clientX, touch.clientY);
                    console.log('Canvas rect:', canvasRect);
                    
                    // ã‚¿ãƒƒãƒä½ç½®ãŒã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆæ¨ªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ã¯ãƒ‘ãƒ¬ãƒƒãƒˆé ˜åŸŸã‚’é™¤å¤–ï¼‰
                    let isWithinCanvas = false;
                    const isLandscape = window.innerWidth <= 768 && window.innerHeight <= 500 && window.matchMedia('(orientation: landscape)').matches;
                    
                    if (isLandscape) {
                        // æ¨ªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šãƒ‘ãƒ¬ãƒƒãƒˆé ˜åŸŸï¼ˆä¸‹éƒ¨140pxï¼‰ã‚’é™¤å¤–
                        isWithinCanvas = touch.clientX >= canvasRect.left && touch.clientX <= canvasRect.right &&
                                       touch.clientY >= canvasRect.top && touch.clientY <= (canvasRect.bottom - 140);
                    } else {
                        // ç¸¦ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šé€šå¸¸ã®åˆ¤å®š
                        isWithinCanvas = touch.clientX >= canvasRect.left && touch.clientX <= canvasRect.right &&
                                       touch.clientY >= canvasRect.top && touch.clientY <= canvasRect.bottom;
                    }
                    
                    if (isWithinCanvas) {
                        // ã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã®å ´åˆã€ãã®åº§æ¨™ã‚’ä½¿ç”¨
                        x = (touch.clientX - canvasRect.left - this.panX) / this.scale;
                        y = (touch.clientY - canvasRect.top - this.panY) / this.scale;
                        console.log('Touch within canvas, using touch position:', x, y);
                    } else {
                        // ã‚­ãƒ£ãƒ³ãƒã‚¹å¤–ï¼ˆãƒ‘ãƒ¬ãƒƒãƒˆï¼‰ã®å ´åˆã€ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸­å¤®ã«é…ç½®
                        if (isLandscape) {
                            // æ¨ªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šãƒ‘ãƒ¬ãƒƒãƒˆé ˜åŸŸã‚’é™¤ã„ãŸã‚­ãƒ£ãƒ³ãƒã‚¹ä¸­å¤®
                            x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                            y = ((this.canvas.clientHeight - 140) / 2 - this.panY) / this.scale;
                        } else {
                            // ç¸¦ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ï¼šé€šå¸¸ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸­å¤®
                            x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                            y = (this.canvas.clientHeight / 2 - this.panY) / this.scale;
                        }
                        console.log('Touch outside canvas (palette), using center:', x, y);
                    }
                } else {
                    // ãƒã‚¦ã‚¹ã®å ´åˆã‚‚åŒæ§˜ã®å‡¦ç†
                    x = (this.canvas.clientWidth / 2 - this.panX) / this.scale;
                    y = (this.canvas.clientHeight / 2 - this.panY) / this.scale;
                    console.log('Mouse event, using center:', x, y);
                }
                
                const component = this.createComponent(type, x, y);
                component.isNewFromPalette = true; // ãƒ‘ãƒ¬ãƒƒãƒˆã‹ã‚‰ä½œæˆã•ã‚ŒãŸã“ã¨ã‚’è¨˜éŒ²
                
                // é‡è¦ï¼šã¾ã ãƒãƒƒãƒ—ã«ã¯è¿½åŠ ã›ãšã€ä¸€æ™‚çš„ã«ä¿æŒ
                this.pendingComponent = component;
                this.selectedComponent = component;
                this.isDragging = true;
                this.dragOffset = { x: 0, y: 0 };
                this.dragStarted = false; // å®Ÿéš›ã®ãƒ‰ãƒ©ãƒƒã‚°ãŒé–‹å§‹ã•ã‚ŒãŸã‹ã®ãƒ•ãƒ©ã‚°
                
                // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆã€ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
                if (event.type === 'touchstart') {
                    this.setupGlobalTouchHandlers();
                }
                
                this.render();
            }
        }

        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
        window.addEventListener('DOMContentLoaded', () => {
            new MobileCircuitSimulator();
        });
    </script>
</Layout>